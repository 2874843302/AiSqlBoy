"use strict";
const require$$1$5 = require("electron");
const require$$1$3 = require("path");
const require$$1$2 = require("fs");
const require$$0$1 = require("constants");
const require$$0$2 = require("stream");
const require$$1$1 = require("util");
const require$$5$1 = require("assert");
const require$$1$6 = require("child_process");
const require$$0$3 = require("events");
const require$$0$4 = require("crypto");
const require$$1$4 = require("tty");
const require$$2$1 = require("os");
const require$$2$2 = require("url");
const require$$14 = require("zlib");
const require$$4$1 = require("http");
const module$1 = require("module");
const require$$0$6 = require("process");
const require$$0$7 = require("net");
const require$$2$3 = require("tls");
const require$$1$8 = require("timers");
const require$$0$5 = require("buffer");
const require$$1$7 = require("string_decoder");
const pg = require("pg");
const redis = require("redis");
var _documentCurrentScript = typeof document !== "undefined" ? document.currentScript : null;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var main$1 = {};
var fs = {};
var universalify = {};
var hasRequiredUniversalify;
function requireUniversalify() {
  if (hasRequiredUniversalify) return universalify;
  hasRequiredUniversalify = 1;
  universalify.fromCallback = function(fn) {
    return Object.defineProperty(function(...args) {
      if (typeof args[args.length - 1] === "function") fn.apply(this, args);
      else {
        return new Promise((resolve, reject) => {
          args.push((err, res) => err != null ? reject(err) : resolve(res));
          fn.apply(this, args);
        });
      }
    }, "name", { value: fn.name });
  };
  universalify.fromPromise = function(fn) {
    return Object.defineProperty(function(...args) {
      const cb = args[args.length - 1];
      if (typeof cb !== "function") return fn.apply(this, args);
      else {
        args.pop();
        fn.apply(this, args).then((r) => cb(null, r), cb);
      }
    }, "name", { value: fn.name });
  };
  return universalify;
}
var polyfills;
var hasRequiredPolyfills;
function requirePolyfills() {
  if (hasRequiredPolyfills) return polyfills;
  hasRequiredPolyfills = 1;
  var constants2 = require$$0$1;
  var origCwd = process.cwd;
  var cwd = null;
  var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  if (typeof process.chdir === "function") {
    var chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null;
      chdir.call(process, d);
    };
    if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
  }
  polyfills = patch;
  function patch(fs2) {
    if (constants2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs2);
    }
    if (!fs2.lutimes) {
      patchLutimes(fs2);
    }
    fs2.chown = chownFix(fs2.chown);
    fs2.fchown = chownFix(fs2.fchown);
    fs2.lchown = chownFix(fs2.lchown);
    fs2.chmod = chmodFix(fs2.chmod);
    fs2.fchmod = chmodFix(fs2.fchmod);
    fs2.lchmod = chmodFix(fs2.lchmod);
    fs2.chownSync = chownFixSync(fs2.chownSync);
    fs2.fchownSync = chownFixSync(fs2.fchownSync);
    fs2.lchownSync = chownFixSync(fs2.lchownSync);
    fs2.chmodSync = chmodFixSync(fs2.chmodSync);
    fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
    fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
    fs2.stat = statFix(fs2.stat);
    fs2.fstat = statFix(fs2.fstat);
    fs2.lstat = statFix(fs2.lstat);
    fs2.statSync = statFixSync(fs2.statSync);
    fs2.fstatSync = statFixSync(fs2.fstatSync);
    fs2.lstatSync = statFixSync(fs2.lstatSync);
    if (fs2.chmod && !fs2.lchmod) {
      fs2.lchmod = function(path, mode, cb) {
        if (cb) process.nextTick(cb);
      };
      fs2.lchmodSync = function() {
      };
    }
    if (fs2.chown && !fs2.lchown) {
      fs2.lchown = function(path, uid, gid, cb) {
        if (cb) process.nextTick(cb);
      };
      fs2.lchownSync = function() {
      };
    }
    if (platform === "win32") {
      fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : (function(fs$rename) {
        function rename(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs2.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb) cb(er);
          });
        }
        if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
        return rename;
      })(fs2.rename);
    }
    fs2.read = typeof fs2.read !== "function" ? fs2.read : (function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
      }
      if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
      return read;
    })(fs2.read);
    fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : /* @__PURE__ */ (function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs2, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    })(fs2.readSync);
    function patchLchmod(fs22) {
      fs22.lchmod = function(path, mode, callback) {
        fs22.open(
          path,
          constants2.O_WRONLY | constants2.O_SYMLINK,
          mode,
          function(err, fd) {
            if (err) {
              if (callback) callback(err);
              return;
            }
            fs22.fchmod(fd, mode, function(err2) {
              fs22.close(fd, function(err22) {
                if (callback) callback(err2 || err22);
              });
            });
          }
        );
      };
      fs22.lchmodSync = function(path, mode) {
        var fd = fs22.openSync(path, constants2.O_WRONLY | constants2.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs22.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs22.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs22.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs22) {
      if (constants2.hasOwnProperty("O_SYMLINK") && fs22.futimes) {
        fs22.lutimes = function(path, at, mt, cb) {
          fs22.open(path, constants2.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb) cb(er);
              return;
            }
            fs22.futimes(fd, at, mt, function(er2) {
              fs22.close(fd, function(er22) {
                if (cb) cb(er2 || er22);
              });
            });
          });
        };
        fs22.lutimesSync = function(path, at, mt) {
          var fd = fs22.openSync(path, constants2.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs22.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs22.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs22.closeSync(fd);
            }
          }
          return ret;
        };
      } else if (fs22.futimes) {
        fs22.lutimes = function(_a, _b, _c, cb) {
          if (cb) process.nextTick(cb);
        };
        fs22.lutimesSync = function() {
        };
      }
    }
    function chmodFix(orig) {
      if (!orig) return orig;
      return function(target, mode, cb) {
        return orig.call(fs2, target, mode, function(er) {
          if (chownErOk(er)) er = null;
          if (cb) cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig) return orig;
      return function(target, mode) {
        try {
          return orig.call(fs2, target, mode);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig) return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs2, target, uid, gid, function(er) {
          if (chownErOk(er)) er = null;
          if (cb) cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig) return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs2, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig) return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0) stats.uid += 4294967296;
            if (stats.gid < 0) stats.gid += 4294967296;
          }
          if (cb) cb.apply(this, arguments);
        }
        return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig) return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
        if (stats) {
          if (stats.uid < 0) stats.uid += 4294967296;
          if (stats.gid < 0) stats.gid += 4294967296;
        }
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
  return polyfills;
}
var legacyStreams;
var hasRequiredLegacyStreams;
function requireLegacyStreams() {
  if (hasRequiredLegacyStreams) return legacyStreams;
  hasRequiredLegacyStreams = 1;
  var Stream = require$$0$2.Stream;
  legacyStreams = legacy;
  function legacy(fs2) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path, options) {
      if (!(this instanceof ReadStream)) return new ReadStream(path, options);
      Stream.call(this);
      var self2 = this;
      this.path = path;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding) this.setEncoding(this.encoding);
      if (this.start !== void 0) {
        if ("number" !== typeof this.start) {
          throw TypeError("start must be a Number");
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if ("number" !== typeof this.end) {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs2.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    function WriteStream(path, options) {
      if (!(this instanceof WriteStream)) return new WriteStream(path, options);
      Stream.call(this);
      this.path = path;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== void 0) {
        if ("number" !== typeof this.start) {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs2.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
        this.flush();
      }
    }
  }
  return legacyStreams;
}
var clone_1;
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone_1;
  hasRequiredClone = 1;
  clone_1 = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy2 = { __proto__: getPrototypeOf(obj) };
    else
      var copy2 = /* @__PURE__ */ Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy2;
  }
  return clone_1;
}
var gracefulFs;
var hasRequiredGracefulFs;
function requireGracefulFs() {
  if (hasRequiredGracefulFs) return gracefulFs;
  hasRequiredGracefulFs = 1;
  var fs2 = require$$1$2;
  var polyfills2 = requirePolyfills();
  var legacy = requireLegacyStreams();
  var clone = requireClone();
  var util2 = require$$1$1;
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = /* @__PURE__ */ Symbol.for("graceful-fs.queue");
    previousSymbol = /* @__PURE__ */ Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop() {
  }
  function publishQueue(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  }
  var debug = noop;
  if (util2.debuglog)
    debug = util2.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug = function() {
      var m = util2.format.apply(util2, arguments);
      m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
      console.error(m);
    };
  if (!fs2[gracefulQueue]) {
    var queue = commonjsGlobal[gracefulQueue] || [];
    publishQueue(fs2, queue);
    fs2.close = (function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs2, fd, function(err) {
          if (!err) {
            resetQueue();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    })(fs2.close);
    fs2.closeSync = (function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs2, arguments);
        resetQueue();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    })(fs2.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug(fs2[gracefulQueue]);
        require$$5$1.equal(fs2[gracefulQueue].length, 0);
      });
    }
  }
  if (!commonjsGlobal[gracefulQueue]) {
    publishQueue(commonjsGlobal, fs2[gracefulQueue]);
  }
  gracefulFs = patch(clone(fs2));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
    gracefulFs = patch(fs2);
    fs2.__patched = true;
  }
  function patch(fs22) {
    polyfills2(fs22);
    fs22.gracefulify = patch;
    fs22.createReadStream = createReadStream;
    fs22.createWriteStream = createWriteStream;
    var fs$readFile = fs22.readFile;
    fs22.readFile = readFile;
    function readFile(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path, options, cb);
      function go$readFile(path2, options2, cb2, startTime) {
        return fs$readFile(path2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$writeFile = fs22.writeFile;
    fs22.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path, data, options, cb);
      function go$writeFile(path2, data2, options2, cb2, startTime) {
        return fs$writeFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$appendFile = fs22.appendFile;
    if (fs$appendFile)
      fs22.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path, data, options, cb);
      function go$appendFile(path2, data2, options2, cb2, startTime) {
        return fs$appendFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$copyFile = fs22.copyFile;
    if (fs$copyFile)
      fs22.copyFile = copyFile;
    function copyFile(src2, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return go$copyFile(src2, dest, flags, cb);
      function go$copyFile(src22, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src22, dest2, flags2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$copyFile, [src22, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$readdir = fs22.readdir;
    fs22.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path2, options2, cb2, startTime) {
        return fs$readdir(path2, fs$readdirCallback(
          path2,
          options2,
          cb2,
          startTime
        ));
      } : function go$readdir2(path2, options2, cb2, startTime) {
        return fs$readdir(path2, options2, fs$readdirCallback(
          path2,
          options2,
          cb2,
          startTime
        ));
      };
      return go$readdir(path, options, cb);
      function fs$readdirCallback(path2, options2, cb2, startTime) {
        return function(err, files) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([
              go$readdir,
              [path2, options2, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]);
          else {
            if (files && files.sort)
              files.sort();
            if (typeof cb2 === "function")
              cb2.call(this, err, files);
          }
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs22);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs22.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs22.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs22, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs22, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs22, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs22, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path, options) {
      return new fs22.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
      return new fs22.WriteStream(path, options);
    }
    var fs$open = fs22.open;
    fs22.open = open;
    function open(path, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path, flags, mode, cb);
      function go$open(path2, flags2, mode2, cb2, startTime) {
        return fs$open(path2, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    return fs22;
  }
  function enqueue(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]);
    fs2[gracefulQueue].push(elem);
    retry2();
  }
  var retryTimer;
  function resetQueue() {
    var now = Date.now();
    for (var i = 0; i < fs2[gracefulQueue].length; ++i) {
      if (fs2[gracefulQueue][i].length > 2) {
        fs2[gracefulQueue][i][3] = now;
        fs2[gracefulQueue][i][4] = now;
      }
    }
    retry2();
  }
  function retry2() {
    clearTimeout(retryTimer);
    retryTimer = void 0;
    if (fs2[gracefulQueue].length === 0)
      return;
    var elem = fs2[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    if (startTime === void 0) {
      debug("RETRY", fn.name, args);
      fn.apply(null, args);
    } else if (Date.now() - startTime >= 6e4) {
      debug("TIMEOUT", fn.name, args);
      var cb = args.pop();
      if (typeof cb === "function")
        cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime;
      var sinceStart = Math.max(lastTime - startTime, 1);
      var desiredDelay = Math.min(sinceStart * 1.2, 100);
      if (sinceAttempt >= desiredDelay) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args.concat([startTime]));
      } else {
        fs2[gracefulQueue].push(elem);
      }
    }
    if (retryTimer === void 0) {
      retryTimer = setTimeout(retry2, 0);
    }
  }
  return gracefulFs;
}
var hasRequiredFs;
function requireFs() {
  if (hasRequiredFs) return fs;
  hasRequiredFs = 1;
  (function(exports$1) {
    const u = requireUniversalify().fromCallback;
    const fs2 = requireGracefulFs();
    const api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs2[key] === "function";
    });
    Object.assign(exports$1, fs2);
    api.forEach((method) => {
      exports$1[method] = u(fs2[method]);
    });
    exports$1.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs2.exists(filename, callback);
      }
      return new Promise((resolve) => {
        return fs2.exists(filename, resolve);
      });
    };
    exports$1.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs2.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs2.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err) return reject(err);
          resolve({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports$1.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.write(fd, buffer, ...args);
      }
      return new Promise((resolve, reject) => {
        fs2.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    if (typeof fs2.writev === "function") {
      exports$1.writev = function(fd, buffers, ...args) {
        if (typeof args[args.length - 1] === "function") {
          return fs2.writev(fd, buffers, ...args);
        }
        return new Promise((resolve, reject) => {
          fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
            if (err) return reject(err);
            resolve({ bytesWritten, buffers: buffers2 });
          });
        });
      };
    }
    if (typeof fs2.realpath.native === "function") {
      exports$1.realpath.native = u(fs2.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  })(fs);
  return fs;
}
var makeDir = {};
var utils$1 = {};
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  const path = require$$1$3;
  utils$1.checkPath = function checkPath(pth) {
    if (process.platform === "win32") {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
      if (pathHasInvalidWinCharacters) {
        const error2 = new Error(`Path contains invalid characters: ${pth}`);
        error2.code = "EINVAL";
        throw error2;
      }
    }
  };
  return utils$1;
}
var hasRequiredMakeDir;
function requireMakeDir() {
  if (hasRequiredMakeDir) return makeDir;
  hasRequiredMakeDir = 1;
  const fs2 = /* @__PURE__ */ requireFs();
  const { checkPath } = /* @__PURE__ */ requireUtils$1();
  const getMode = (options) => {
    const defaults2 = { mode: 511 };
    if (typeof options === "number") return options;
    return { ...defaults2, ...options }.mode;
  };
  makeDir.makeDir = async (dir, options) => {
    checkPath(dir);
    return fs2.mkdir(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
  makeDir.makeDirSync = (dir, options) => {
    checkPath(dir);
    return fs2.mkdirSync(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
  return makeDir;
}
var mkdirs;
var hasRequiredMkdirs;
function requireMkdirs() {
  if (hasRequiredMkdirs) return mkdirs;
  hasRequiredMkdirs = 1;
  const u = requireUniversalify().fromPromise;
  const { makeDir: _makeDir, makeDirSync } = /* @__PURE__ */ requireMakeDir();
  const makeDir2 = u(_makeDir);
  mkdirs = {
    mkdirs: makeDir2,
    mkdirsSync: makeDirSync,
    // alias
    mkdirp: makeDir2,
    mkdirpSync: makeDirSync,
    ensureDir: makeDir2,
    ensureDirSync: makeDirSync
  };
  return mkdirs;
}
var pathExists_1;
var hasRequiredPathExists;
function requirePathExists() {
  if (hasRequiredPathExists) return pathExists_1;
  hasRequiredPathExists = 1;
  const u = requireUniversalify().fromPromise;
  const fs2 = /* @__PURE__ */ requireFs();
  function pathExists(path) {
    return fs2.access(path).then(() => true).catch(() => false);
  }
  pathExists_1 = {
    pathExists: u(pathExists),
    pathExistsSync: fs2.existsSync
  };
  return pathExists_1;
}
var utimes;
var hasRequiredUtimes;
function requireUtimes() {
  if (hasRequiredUtimes) return utimes;
  hasRequiredUtimes = 1;
  const fs2 = requireGracefulFs();
  function utimesMillis(path, atime, mtime, callback) {
    fs2.open(path, "r+", (err, fd) => {
      if (err) return callback(err);
      fs2.futimes(fd, atime, mtime, (futimesErr) => {
        fs2.close(fd, (closeErr) => {
          if (callback) callback(futimesErr || closeErr);
        });
      });
    });
  }
  function utimesMillisSync(path, atime, mtime) {
    const fd = fs2.openSync(path, "r+");
    fs2.futimesSync(fd, atime, mtime);
    return fs2.closeSync(fd);
  }
  utimes = {
    utimesMillis,
    utimesMillisSync
  };
  return utimes;
}
var stat;
var hasRequiredStat;
function requireStat() {
  if (hasRequiredStat) return stat;
  hasRequiredStat = 1;
  const fs2 = /* @__PURE__ */ requireFs();
  const path = require$$1$3;
  const util2 = require$$1$1;
  function getStats(src2, dest, opts) {
    const statFunc = opts.dereference ? (file2) => fs2.stat(file2, { bigint: true }) : (file2) => fs2.lstat(file2, { bigint: true });
    return Promise.all([
      statFunc(src2),
      statFunc(dest).catch((err) => {
        if (err.code === "ENOENT") return null;
        throw err;
      })
    ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
  }
  function getStatsSync(src2, dest, opts) {
    let destStat;
    const statFunc = opts.dereference ? (file2) => fs2.statSync(file2, { bigint: true }) : (file2) => fs2.lstatSync(file2, { bigint: true });
    const srcStat = statFunc(src2);
    try {
      destStat = statFunc(dest);
    } catch (err) {
      if (err.code === "ENOENT") return { srcStat, destStat: null };
      throw err;
    }
    return { srcStat, destStat };
  }
  function checkPaths(src2, dest, funcName, opts, cb) {
    util2.callbackify(getStats)(src2, dest, opts, (err, stats) => {
      if (err) return cb(err);
      const { srcStat, destStat } = stats;
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path.basename(src2);
          const destBaseName = path.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return cb(null, { srcStat, destStat, isChangingCase: true });
          }
          return cb(new Error("Source and destination must not be the same."));
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src2}'.`));
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src2}'.`));
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src2, dest)) {
        return cb(new Error(errMsg(src2, dest, funcName)));
      }
      return cb(null, { srcStat, destStat });
    });
  }
  function checkPathsSync(src2, dest, funcName, opts) {
    const { srcStat, destStat } = getStatsSync(src2, dest, opts);
    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        const srcBaseName = path.basename(src2);
        const destBaseName = path.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return { srcStat, destStat, isChangingCase: true };
        }
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src2}'.`);
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src2}'.`);
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src2, dest)) {
      throw new Error(errMsg(src2, dest, funcName));
    }
    return { srcStat, destStat };
  }
  function checkParentPaths(src2, srcStat, dest, funcName, cb) {
    const srcParent = path.resolve(path.dirname(src2));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root) return cb();
    fs2.stat(destParent, { bigint: true }, (err, destStat) => {
      if (err) {
        if (err.code === "ENOENT") return cb();
        return cb(err);
      }
      if (areIdentical(srcStat, destStat)) {
        return cb(new Error(errMsg(src2, dest, funcName)));
      }
      return checkParentPaths(src2, srcStat, destParent, funcName, cb);
    });
  }
  function checkParentPathsSync(src2, srcStat, dest, funcName) {
    const srcParent = path.resolve(path.dirname(src2));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root) return;
    let destStat;
    try {
      destStat = fs2.statSync(destParent, { bigint: true });
    } catch (err) {
      if (err.code === "ENOENT") return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src2, dest, funcName));
    }
    return checkParentPathsSync(src2, srcStat, destParent, funcName);
  }
  function areIdentical(srcStat, destStat) {
    return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
  }
  function isSrcSubdir(src2, dest) {
    const srcArr = path.resolve(src2).split(path.sep).filter((i) => i);
    const destArr = path.resolve(dest).split(path.sep).filter((i) => i);
    return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
  }
  function errMsg(src2, dest, funcName) {
    return `Cannot ${funcName} '${src2}' to a subdirectory of itself, '${dest}'.`;
  }
  stat = {
    checkPaths,
    checkPathsSync,
    checkParentPaths,
    checkParentPathsSync,
    isSrcSubdir,
    areIdentical
  };
  return stat;
}
var copy_1;
var hasRequiredCopy$1;
function requireCopy$1() {
  if (hasRequiredCopy$1) return copy_1;
  hasRequiredCopy$1 = 1;
  const fs2 = requireGracefulFs();
  const path = require$$1$3;
  const mkdirs2 = requireMkdirs().mkdirs;
  const pathExists = requirePathExists().pathExists;
  const utimesMillis = requireUtimes().utimesMillis;
  const stat2 = /* @__PURE__ */ requireStat();
  function copy2(src2, dest, opts, cb) {
    if (typeof opts === "function" && !cb) {
      cb = opts;
      opts = {};
    } else if (typeof opts === "function") {
      opts = { filter: opts };
    }
    cb = cb || function() {
    };
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      process.emitWarning(
        "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
        "Warning",
        "fs-extra-WARN0001"
      );
    }
    stat2.checkPaths(src2, dest, "copy", opts, (err, stats) => {
      if (err) return cb(err);
      const { srcStat, destStat } = stats;
      stat2.checkParentPaths(src2, srcStat, dest, "copy", (err2) => {
        if (err2) return cb(err2);
        if (opts.filter) return handleFilter(checkParentDir, destStat, src2, dest, opts, cb);
        return checkParentDir(destStat, src2, dest, opts, cb);
      });
    });
  }
  function checkParentDir(destStat, src2, dest, opts, cb) {
    const destParent = path.dirname(dest);
    pathExists(destParent, (err, dirExists) => {
      if (err) return cb(err);
      if (dirExists) return getStats(destStat, src2, dest, opts, cb);
      mkdirs2(destParent, (err2) => {
        if (err2) return cb(err2);
        return getStats(destStat, src2, dest, opts, cb);
      });
    });
  }
  function handleFilter(onInclude, destStat, src2, dest, opts, cb) {
    Promise.resolve(opts.filter(src2, dest)).then((include) => {
      if (include) return onInclude(destStat, src2, dest, opts, cb);
      return cb();
    }, (error2) => cb(error2));
  }
  function startCopy(destStat, src2, dest, opts, cb) {
    if (opts.filter) return handleFilter(getStats, destStat, src2, dest, opts, cb);
    return getStats(destStat, src2, dest, opts, cb);
  }
  function getStats(destStat, src2, dest, opts, cb) {
    const stat3 = opts.dereference ? fs2.stat : fs2.lstat;
    stat3(src2, (err, srcStat) => {
      if (err) return cb(err);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src2, dest, opts, cb);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src2, dest, opts, cb);
      else if (srcStat.isSymbolicLink()) return onLink(destStat, src2, dest, opts, cb);
      else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src2}`));
      else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src2}`));
      return cb(new Error(`Unknown file: ${src2}`));
    });
  }
  function onFile(srcStat, destStat, src2, dest, opts, cb) {
    if (!destStat) return copyFile(srcStat, src2, dest, opts, cb);
    return mayCopyFile(srcStat, src2, dest, opts, cb);
  }
  function mayCopyFile(srcStat, src2, dest, opts, cb) {
    if (opts.overwrite) {
      fs2.unlink(dest, (err) => {
        if (err) return cb(err);
        return copyFile(srcStat, src2, dest, opts, cb);
      });
    } else if (opts.errorOnExist) {
      return cb(new Error(`'${dest}' already exists`));
    } else return cb();
  }
  function copyFile(srcStat, src2, dest, opts, cb) {
    fs2.copyFile(src2, dest, (err) => {
      if (err) return cb(err);
      if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src2, dest, cb);
      return setDestMode(dest, srcStat.mode, cb);
    });
  }
  function handleTimestampsAndMode(srcMode, src2, dest, cb) {
    if (fileIsNotWritable(srcMode)) {
      return makeFileWritable(dest, srcMode, (err) => {
        if (err) return cb(err);
        return setDestTimestampsAndMode(srcMode, src2, dest, cb);
      });
    }
    return setDestTimestampsAndMode(srcMode, src2, dest, cb);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode, cb) {
    return setDestMode(dest, srcMode | 128, cb);
  }
  function setDestTimestampsAndMode(srcMode, src2, dest, cb) {
    setDestTimestamps(src2, dest, (err) => {
      if (err) return cb(err);
      return setDestMode(dest, srcMode, cb);
    });
  }
  function setDestMode(dest, srcMode, cb) {
    return fs2.chmod(dest, srcMode, cb);
  }
  function setDestTimestamps(src2, dest, cb) {
    fs2.stat(src2, (err, updatedSrcStat) => {
      if (err) return cb(err);
      return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
    });
  }
  function onDir(srcStat, destStat, src2, dest, opts, cb) {
    if (!destStat) return mkDirAndCopy(srcStat.mode, src2, dest, opts, cb);
    return copyDir(src2, dest, opts, cb);
  }
  function mkDirAndCopy(srcMode, src2, dest, opts, cb) {
    fs2.mkdir(dest, (err) => {
      if (err) return cb(err);
      copyDir(src2, dest, opts, (err2) => {
        if (err2) return cb(err2);
        return setDestMode(dest, srcMode, cb);
      });
    });
  }
  function copyDir(src2, dest, opts, cb) {
    fs2.readdir(src2, (err, items) => {
      if (err) return cb(err);
      return copyDirItems(items, src2, dest, opts, cb);
    });
  }
  function copyDirItems(items, src2, dest, opts, cb) {
    const item = items.pop();
    if (!item) return cb();
    return copyDirItem(items, item, src2, dest, opts, cb);
  }
  function copyDirItem(items, item, src2, dest, opts, cb) {
    const srcItem = path.join(src2, item);
    const destItem = path.join(dest, item);
    stat2.checkPaths(srcItem, destItem, "copy", opts, (err, stats) => {
      if (err) return cb(err);
      const { destStat } = stats;
      startCopy(destStat, srcItem, destItem, opts, (err2) => {
        if (err2) return cb(err2);
        return copyDirItems(items, src2, dest, opts, cb);
      });
    });
  }
  function onLink(destStat, src2, dest, opts, cb) {
    fs2.readlink(src2, (err, resolvedSrc) => {
      if (err) return cb(err);
      if (opts.dereference) {
        resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs2.symlink(resolvedSrc, dest, cb);
      } else {
        fs2.readlink(dest, (err2, resolvedDest) => {
          if (err2) {
            if (err2.code === "EINVAL" || err2.code === "UNKNOWN") return fs2.symlink(resolvedSrc, dest, cb);
            return cb(err2);
          }
          if (opts.dereference) {
            resolvedDest = path.resolve(process.cwd(), resolvedDest);
          }
          if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) {
            return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
          }
          if (destStat.isDirectory() && stat2.isSrcSubdir(resolvedDest, resolvedSrc)) {
            return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
          }
          return copyLink(resolvedSrc, dest, cb);
        });
      }
    });
  }
  function copyLink(resolvedSrc, dest, cb) {
    fs2.unlink(dest, (err) => {
      if (err) return cb(err);
      return fs2.symlink(resolvedSrc, dest, cb);
    });
  }
  copy_1 = copy2;
  return copy_1;
}
var copySync_1;
var hasRequiredCopySync;
function requireCopySync() {
  if (hasRequiredCopySync) return copySync_1;
  hasRequiredCopySync = 1;
  const fs2 = requireGracefulFs();
  const path = require$$1$3;
  const mkdirsSync = requireMkdirs().mkdirsSync;
  const utimesMillisSync = requireUtimes().utimesMillisSync;
  const stat2 = /* @__PURE__ */ requireStat();
  function copySync(src2, dest, opts) {
    if (typeof opts === "function") {
      opts = { filter: opts };
    }
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      process.emitWarning(
        "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
        "Warning",
        "fs-extra-WARN0002"
      );
    }
    const { srcStat, destStat } = stat2.checkPathsSync(src2, dest, "copy", opts);
    stat2.checkParentPathsSync(src2, srcStat, dest, "copy");
    return handleFilterAndCopy(destStat, src2, dest, opts);
  }
  function handleFilterAndCopy(destStat, src2, dest, opts) {
    if (opts.filter && !opts.filter(src2, dest)) return;
    const destParent = path.dirname(dest);
    if (!fs2.existsSync(destParent)) mkdirsSync(destParent);
    return getStats(destStat, src2, dest, opts);
  }
  function startCopy(destStat, src2, dest, opts) {
    if (opts.filter && !opts.filter(src2, dest)) return;
    return getStats(destStat, src2, dest, opts);
  }
  function getStats(destStat, src2, dest, opts) {
    const statSync = opts.dereference ? fs2.statSync : fs2.lstatSync;
    const srcStat = statSync(src2);
    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src2, dest, opts);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src2, dest, opts);
    else if (srcStat.isSymbolicLink()) return onLink(destStat, src2, dest, opts);
    else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src2}`);
    else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src2}`);
    throw new Error(`Unknown file: ${src2}`);
  }
  function onFile(srcStat, destStat, src2, dest, opts) {
    if (!destStat) return copyFile(srcStat, src2, dest, opts);
    return mayCopyFile(srcStat, src2, dest, opts);
  }
  function mayCopyFile(srcStat, src2, dest, opts) {
    if (opts.overwrite) {
      fs2.unlinkSync(dest);
      return copyFile(srcStat, src2, dest, opts);
    } else if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  function copyFile(srcStat, src2, dest, opts) {
    fs2.copyFileSync(src2, dest);
    if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src2, dest);
    return setDestMode(dest, srcStat.mode);
  }
  function handleTimestamps(srcMode, src2, dest) {
    if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
    return setDestTimestamps(src2, dest);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode) {
    return setDestMode(dest, srcMode | 128);
  }
  function setDestMode(dest, srcMode) {
    return fs2.chmodSync(dest, srcMode);
  }
  function setDestTimestamps(src2, dest) {
    const updatedSrcStat = fs2.statSync(src2);
    return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  function onDir(srcStat, destStat, src2, dest, opts) {
    if (!destStat) return mkDirAndCopy(srcStat.mode, src2, dest, opts);
    return copyDir(src2, dest, opts);
  }
  function mkDirAndCopy(srcMode, src2, dest, opts) {
    fs2.mkdirSync(dest);
    copyDir(src2, dest, opts);
    return setDestMode(dest, srcMode);
  }
  function copyDir(src2, dest, opts) {
    fs2.readdirSync(src2).forEach((item) => copyDirItem(item, src2, dest, opts));
  }
  function copyDirItem(item, src2, dest, opts) {
    const srcItem = path.join(src2, item);
    const destItem = path.join(dest, item);
    const { destStat } = stat2.checkPathsSync(srcItem, destItem, "copy", opts);
    return startCopy(destStat, srcItem, destItem, opts);
  }
  function onLink(destStat, src2, dest, opts) {
    let resolvedSrc = fs2.readlinkSync(src2);
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs2.symlinkSync(resolvedSrc, dest);
    } else {
      let resolvedDest;
      try {
        resolvedDest = fs2.readlinkSync(dest);
      } catch (err) {
        if (err.code === "EINVAL" || err.code === "UNKNOWN") return fs2.symlinkSync(resolvedSrc, dest);
        throw err;
      }
      if (opts.dereference) {
        resolvedDest = path.resolve(process.cwd(), resolvedDest);
      }
      if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (fs2.statSync(dest).isDirectory() && stat2.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      return copyLink(resolvedSrc, dest);
    }
  }
  function copyLink(resolvedSrc, dest) {
    fs2.unlinkSync(dest);
    return fs2.symlinkSync(resolvedSrc, dest);
  }
  copySync_1 = copySync;
  return copySync_1;
}
var copy;
var hasRequiredCopy;
function requireCopy() {
  if (hasRequiredCopy) return copy;
  hasRequiredCopy = 1;
  const u = requireUniversalify().fromCallback;
  copy = {
    copy: u(/* @__PURE__ */ requireCopy$1()),
    copySync: /* @__PURE__ */ requireCopySync()
  };
  return copy;
}
var rimraf_1;
var hasRequiredRimraf;
function requireRimraf() {
  if (hasRequiredRimraf) return rimraf_1;
  hasRequiredRimraf = 1;
  const fs2 = requireGracefulFs();
  const path = require$$1$3;
  const assert = require$$5$1;
  const isWindows = process.platform === "win32";
  function defaults2(options) {
    const methods = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods.forEach((m) => {
      options[m] = options[m] || fs2[m];
      m = m + "Sync";
      options[m] = options[m] || fs2[m];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
  }
  function rimraf(p, options, cb) {
    let busyTries = 0;
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    defaults2(options);
    rimraf_(p, options, function CB(er) {
      if (er) {
        if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
          busyTries++;
          const time = busyTries * 100;
          return setTimeout(() => rimraf_(p, options, CB), time);
        }
        if (er.code === "ENOENT") er = null;
      }
      cb(er);
    });
  }
  function rimraf_(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT") {
        return cb(null);
      }
      if (er && er.code === "EPERM" && isWindows) {
        return fixWinEPERM(p, options, er, cb);
      }
      if (st && st.isDirectory()) {
        return rmdir(p, options, er, cb);
      }
      options.unlink(p, (er2) => {
        if (er2) {
          if (er2.code === "ENOENT") {
            return cb(null);
          }
          if (er2.code === "EPERM") {
            return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          }
          if (er2.code === "EISDIR") {
            return rmdir(p, options, er2, cb);
          }
        }
        return cb(er2);
      });
    });
  }
  function fixWinEPERM(p, options, er, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.chmod(p, 438, (er2) => {
      if (er2) {
        cb(er2.code === "ENOENT" ? null : er);
      } else {
        options.stat(p, (er3, stats) => {
          if (er3) {
            cb(er3.code === "ENOENT" ? null : er);
          } else if (stats.isDirectory()) {
            rmdir(p, options, er, cb);
          } else {
            options.unlink(p, cb);
          }
        });
      }
    });
  }
  function fixWinEPERMSync(p, options, er) {
    let stats;
    assert(p);
    assert(options);
    try {
      options.chmodSync(p, 438);
    } catch (er2) {
      if (er2.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    try {
      stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    if (stats.isDirectory()) {
      rmdirSync(p, options, er);
    } else {
      options.unlinkSync(p);
    }
  }
  function rmdir(p, options, originalEr, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.rmdir(p, (er) => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
        rmkids(p, options, cb);
      } else if (er && er.code === "ENOTDIR") {
        cb(originalEr);
      } else {
        cb(er);
      }
    });
  }
  function rmkids(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, (er, files) => {
      if (er) return cb(er);
      let n = files.length;
      let errState;
      if (n === 0) return options.rmdir(p, cb);
      files.forEach((f) => {
        rimraf(path.join(p, f), options, (er2) => {
          if (errState) {
            return;
          }
          if (er2) return cb(errState = er2);
          if (--n === 0) {
            options.rmdir(p, cb);
          }
        });
      });
    });
  }
  function rimrafSync(p, options) {
    let st;
    options = options || {};
    defaults2(options);
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    try {
      st = options.lstatSync(p);
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      }
      if (er.code === "EPERM" && isWindows) {
        fixWinEPERMSync(p, options, er);
      }
    }
    try {
      if (st && st.isDirectory()) {
        rmdirSync(p, options, null);
      } else {
        options.unlinkSync(p);
      }
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      } else if (er.code === "EPERM") {
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
      } else if (er.code !== "EISDIR") {
        throw er;
      }
      rmdirSync(p, options, er);
    }
  }
  function rmdirSync(p, options, originalEr) {
    assert(p);
    assert(options);
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOTDIR") {
        throw originalEr;
      } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
        rmkidsSync(p, options);
      } else if (er.code !== "ENOENT") {
        throw er;
      }
    }
  }
  function rmkidsSync(p, options) {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f) => rimrafSync(path.join(p, f), options));
    if (isWindows) {
      const startTime = Date.now();
      do {
        try {
          const ret = options.rmdirSync(p, options);
          return ret;
        } catch {
        }
      } while (Date.now() - startTime < 500);
    } else {
      const ret = options.rmdirSync(p, options);
      return ret;
    }
  }
  rimraf_1 = rimraf;
  rimraf.sync = rimrafSync;
  return rimraf_1;
}
var remove_1;
var hasRequiredRemove;
function requireRemove() {
  if (hasRequiredRemove) return remove_1;
  hasRequiredRemove = 1;
  const fs2 = requireGracefulFs();
  const u = requireUniversalify().fromCallback;
  const rimraf = /* @__PURE__ */ requireRimraf();
  function remove(path, callback) {
    if (fs2.rm) return fs2.rm(path, { recursive: true, force: true }, callback);
    rimraf(path, callback);
  }
  function removeSync(path) {
    if (fs2.rmSync) return fs2.rmSync(path, { recursive: true, force: true });
    rimraf.sync(path);
  }
  remove_1 = {
    remove: u(remove),
    removeSync
  };
  return remove_1;
}
var empty;
var hasRequiredEmpty;
function requireEmpty() {
  if (hasRequiredEmpty) return empty;
  hasRequiredEmpty = 1;
  const u = requireUniversalify().fromPromise;
  const fs2 = /* @__PURE__ */ requireFs();
  const path = require$$1$3;
  const mkdir = /* @__PURE__ */ requireMkdirs();
  const remove = /* @__PURE__ */ requireRemove();
  const emptyDir = u(async function emptyDir2(dir) {
    let items;
    try {
      items = await fs2.readdir(dir);
    } catch {
      return mkdir.mkdirs(dir);
    }
    return Promise.all(items.map((item) => remove.remove(path.join(dir, item))));
  });
  function emptyDirSync(dir) {
    let items;
    try {
      items = fs2.readdirSync(dir);
    } catch {
      return mkdir.mkdirsSync(dir);
    }
    items.forEach((item) => {
      item = path.join(dir, item);
      remove.removeSync(item);
    });
  }
  empty = {
    emptyDirSync,
    emptydirSync: emptyDirSync,
    emptyDir,
    emptydir: emptyDir
  };
  return empty;
}
var file;
var hasRequiredFile;
function requireFile() {
  if (hasRequiredFile) return file;
  hasRequiredFile = 1;
  const u = requireUniversalify().fromCallback;
  const path = require$$1$3;
  const fs2 = requireGracefulFs();
  const mkdir = /* @__PURE__ */ requireMkdirs();
  function createFile(file2, callback) {
    function makeFile() {
      fs2.writeFile(file2, "", (err) => {
        if (err) return callback(err);
        callback();
      });
    }
    fs2.stat(file2, (err, stats) => {
      if (!err && stats.isFile()) return callback();
      const dir = path.dirname(file2);
      fs2.stat(dir, (err2, stats2) => {
        if (err2) {
          if (err2.code === "ENOENT") {
            return mkdir.mkdirs(dir, (err3) => {
              if (err3) return callback(err3);
              makeFile();
            });
          }
          return callback(err2);
        }
        if (stats2.isDirectory()) makeFile();
        else {
          fs2.readdir(dir, (err3) => {
            if (err3) return callback(err3);
          });
        }
      });
    });
  }
  function createFileSync(file2) {
    let stats;
    try {
      stats = fs2.statSync(file2);
    } catch {
    }
    if (stats && stats.isFile()) return;
    const dir = path.dirname(file2);
    try {
      if (!fs2.statSync(dir).isDirectory()) {
        fs2.readdirSync(dir);
      }
    } catch (err) {
      if (err && err.code === "ENOENT") mkdir.mkdirsSync(dir);
      else throw err;
    }
    fs2.writeFileSync(file2, "");
  }
  file = {
    createFile: u(createFile),
    createFileSync
  };
  return file;
}
var link;
var hasRequiredLink;
function requireLink() {
  if (hasRequiredLink) return link;
  hasRequiredLink = 1;
  const u = requireUniversalify().fromCallback;
  const path = require$$1$3;
  const fs2 = requireGracefulFs();
  const mkdir = /* @__PURE__ */ requireMkdirs();
  const pathExists = requirePathExists().pathExists;
  const { areIdentical } = /* @__PURE__ */ requireStat();
  function createLink(srcpath, dstpath, callback) {
    function makeLink(srcpath2, dstpath2) {
      fs2.link(srcpath2, dstpath2, (err) => {
        if (err) return callback(err);
        callback(null);
      });
    }
    fs2.lstat(dstpath, (_, dstStat) => {
      fs2.lstat(srcpath, (err, srcStat) => {
        if (err) {
          err.message = err.message.replace("lstat", "ensureLink");
          return callback(err);
        }
        if (dstStat && areIdentical(srcStat, dstStat)) return callback(null);
        const dir = path.dirname(dstpath);
        pathExists(dir, (err2, dirExists) => {
          if (err2) return callback(err2);
          if (dirExists) return makeLink(srcpath, dstpath);
          mkdir.mkdirs(dir, (err3) => {
            if (err3) return callback(err3);
            makeLink(srcpath, dstpath);
          });
        });
      });
    });
  }
  function createLinkSync(srcpath, dstpath) {
    let dstStat;
    try {
      dstStat = fs2.lstatSync(dstpath);
    } catch {
    }
    try {
      const srcStat = fs2.lstatSync(srcpath);
      if (dstStat && areIdentical(srcStat, dstStat)) return;
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    const dir = path.dirname(dstpath);
    const dirExists = fs2.existsSync(dir);
    if (dirExists) return fs2.linkSync(srcpath, dstpath);
    mkdir.mkdirsSync(dir);
    return fs2.linkSync(srcpath, dstpath);
  }
  link = {
    createLink: u(createLink),
    createLinkSync
  };
  return link;
}
var symlinkPaths_1;
var hasRequiredSymlinkPaths;
function requireSymlinkPaths() {
  if (hasRequiredSymlinkPaths) return symlinkPaths_1;
  hasRequiredSymlinkPaths = 1;
  const path = require$$1$3;
  const fs2 = requireGracefulFs();
  const pathExists = requirePathExists().pathExists;
  function symlinkPaths(srcpath, dstpath, callback) {
    if (path.isAbsolute(srcpath)) {
      return fs2.lstat(srcpath, (err) => {
        if (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          return callback(err);
        }
        return callback(null, {
          toCwd: srcpath,
          toDst: srcpath
        });
      });
    } else {
      const dstdir = path.dirname(dstpath);
      const relativeToDst = path.join(dstdir, srcpath);
      return pathExists(relativeToDst, (err, exists) => {
        if (err) return callback(err);
        if (exists) {
          return callback(null, {
            toCwd: relativeToDst,
            toDst: srcpath
          });
        } else {
          return fs2.lstat(srcpath, (err2) => {
            if (err2) {
              err2.message = err2.message.replace("lstat", "ensureSymlink");
              return callback(err2);
            }
            return callback(null, {
              toCwd: srcpath,
              toDst: path.relative(dstdir, srcpath)
            });
          });
        }
      });
    }
  }
  function symlinkPathsSync(srcpath, dstpath) {
    let exists;
    if (path.isAbsolute(srcpath)) {
      exists = fs2.existsSync(srcpath);
      if (!exists) throw new Error("absolute srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    } else {
      const dstdir = path.dirname(dstpath);
      const relativeToDst = path.join(dstdir, srcpath);
      exists = fs2.existsSync(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      } else {
        exists = fs2.existsSync(srcpath);
        if (!exists) throw new Error("relative srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: path.relative(dstdir, srcpath)
        };
      }
    }
  }
  symlinkPaths_1 = {
    symlinkPaths,
    symlinkPathsSync
  };
  return symlinkPaths_1;
}
var symlinkType_1;
var hasRequiredSymlinkType;
function requireSymlinkType() {
  if (hasRequiredSymlinkType) return symlinkType_1;
  hasRequiredSymlinkType = 1;
  const fs2 = requireGracefulFs();
  function symlinkType(srcpath, type2, callback) {
    callback = typeof type2 === "function" ? type2 : callback;
    type2 = typeof type2 === "function" ? false : type2;
    if (type2) return callback(null, type2);
    fs2.lstat(srcpath, (err, stats) => {
      if (err) return callback(null, "file");
      type2 = stats && stats.isDirectory() ? "dir" : "file";
      callback(null, type2);
    });
  }
  function symlinkTypeSync(srcpath, type2) {
    let stats;
    if (type2) return type2;
    try {
      stats = fs2.lstatSync(srcpath);
    } catch {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  }
  symlinkType_1 = {
    symlinkType,
    symlinkTypeSync
  };
  return symlinkType_1;
}
var symlink;
var hasRequiredSymlink;
function requireSymlink() {
  if (hasRequiredSymlink) return symlink;
  hasRequiredSymlink = 1;
  const u = requireUniversalify().fromCallback;
  const path = require$$1$3;
  const fs2 = /* @__PURE__ */ requireFs();
  const _mkdirs = /* @__PURE__ */ requireMkdirs();
  const mkdirs2 = _mkdirs.mkdirs;
  const mkdirsSync = _mkdirs.mkdirsSync;
  const _symlinkPaths = /* @__PURE__ */ requireSymlinkPaths();
  const symlinkPaths = _symlinkPaths.symlinkPaths;
  const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
  const _symlinkType = /* @__PURE__ */ requireSymlinkType();
  const symlinkType = _symlinkType.symlinkType;
  const symlinkTypeSync = _symlinkType.symlinkTypeSync;
  const pathExists = requirePathExists().pathExists;
  const { areIdentical } = /* @__PURE__ */ requireStat();
  function createSymlink(srcpath, dstpath, type2, callback) {
    callback = typeof type2 === "function" ? type2 : callback;
    type2 = typeof type2 === "function" ? false : type2;
    fs2.lstat(dstpath, (err, stats) => {
      if (!err && stats.isSymbolicLink()) {
        Promise.all([
          fs2.stat(srcpath),
          fs2.stat(dstpath)
        ]).then(([srcStat, dstStat]) => {
          if (areIdentical(srcStat, dstStat)) return callback(null);
          _createSymlink(srcpath, dstpath, type2, callback);
        });
      } else _createSymlink(srcpath, dstpath, type2, callback);
    });
  }
  function _createSymlink(srcpath, dstpath, type2, callback) {
    symlinkPaths(srcpath, dstpath, (err, relative) => {
      if (err) return callback(err);
      srcpath = relative.toDst;
      symlinkType(relative.toCwd, type2, (err2, type3) => {
        if (err2) return callback(err2);
        const dir = path.dirname(dstpath);
        pathExists(dir, (err3, dirExists) => {
          if (err3) return callback(err3);
          if (dirExists) return fs2.symlink(srcpath, dstpath, type3, callback);
          mkdirs2(dir, (err4) => {
            if (err4) return callback(err4);
            fs2.symlink(srcpath, dstpath, type3, callback);
          });
        });
      });
    });
  }
  function createSymlinkSync(srcpath, dstpath, type2) {
    let stats;
    try {
      stats = fs2.lstatSync(dstpath);
    } catch {
    }
    if (stats && stats.isSymbolicLink()) {
      const srcStat = fs2.statSync(srcpath);
      const dstStat = fs2.statSync(dstpath);
      if (areIdentical(srcStat, dstStat)) return;
    }
    const relative = symlinkPathsSync(srcpath, dstpath);
    srcpath = relative.toDst;
    type2 = symlinkTypeSync(relative.toCwd, type2);
    const dir = path.dirname(dstpath);
    const exists = fs2.existsSync(dir);
    if (exists) return fs2.symlinkSync(srcpath, dstpath, type2);
    mkdirsSync(dir);
    return fs2.symlinkSync(srcpath, dstpath, type2);
  }
  symlink = {
    createSymlink: u(createSymlink),
    createSymlinkSync
  };
  return symlink;
}
var ensure;
var hasRequiredEnsure;
function requireEnsure() {
  if (hasRequiredEnsure) return ensure;
  hasRequiredEnsure = 1;
  const { createFile, createFileSync } = /* @__PURE__ */ requireFile();
  const { createLink, createLinkSync } = /* @__PURE__ */ requireLink();
  const { createSymlink, createSymlinkSync } = /* @__PURE__ */ requireSymlink();
  ensure = {
    // file
    createFile,
    createFileSync,
    ensureFile: createFile,
    ensureFileSync: createFileSync,
    // link
    createLink,
    createLinkSync,
    ensureLink: createLink,
    ensureLinkSync: createLinkSync,
    // symlink
    createSymlink,
    createSymlinkSync,
    ensureSymlink: createSymlink,
    ensureSymlinkSync: createSymlinkSync
  };
  return ensure;
}
var utils;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  function stringify(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
    const EOF = finalEOL ? EOL : "";
    const str2 = JSON.stringify(obj, replacer, spaces);
    return str2.replace(/\n/g, EOL) + EOF;
  }
  function stripBom(content) {
    if (Buffer.isBuffer(content)) content = content.toString("utf8");
    return content.replace(/^\uFEFF/, "");
  }
  utils = { stringify, stripBom };
  return utils;
}
var jsonfile$1;
var hasRequiredJsonfile$1;
function requireJsonfile$1() {
  if (hasRequiredJsonfile$1) return jsonfile$1;
  hasRequiredJsonfile$1 = 1;
  let _fs;
  try {
    _fs = requireGracefulFs();
  } catch (_) {
    _fs = require$$1$2;
  }
  const universalify2 = requireUniversalify();
  const { stringify, stripBom } = requireUtils();
  async function _readFile(file2, options = {}) {
    if (typeof options === "string") {
      options = { encoding: options };
    }
    const fs2 = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    let data = await universalify2.fromCallback(fs2.readFile)(file2, options);
    data = stripBom(data);
    let obj;
    try {
      obj = JSON.parse(data, options ? options.reviver : null);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file2}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
    return obj;
  }
  const readFile = universalify2.fromPromise(_readFile);
  function readFileSync(file2, options = {}) {
    if (typeof options === "string") {
      options = { encoding: options };
    }
    const fs2 = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    try {
      let content = fs2.readFileSync(file2, options);
      content = stripBom(content);
      return JSON.parse(content, options.reviver);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file2}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
  }
  async function _writeFile(file2, obj, options = {}) {
    const fs2 = options.fs || _fs;
    const str2 = stringify(obj, options);
    await universalify2.fromCallback(fs2.writeFile)(file2, str2, options);
  }
  const writeFile = universalify2.fromPromise(_writeFile);
  function writeFileSync(file2, obj, options = {}) {
    const fs2 = options.fs || _fs;
    const str2 = stringify(obj, options);
    return fs2.writeFileSync(file2, str2, options);
  }
  jsonfile$1 = {
    readFile,
    readFileSync,
    writeFile,
    writeFileSync
  };
  return jsonfile$1;
}
var jsonfile;
var hasRequiredJsonfile;
function requireJsonfile() {
  if (hasRequiredJsonfile) return jsonfile;
  hasRequiredJsonfile = 1;
  const jsonFile = requireJsonfile$1();
  jsonfile = {
    // jsonfile exports
    readJson: jsonFile.readFile,
    readJsonSync: jsonFile.readFileSync,
    writeJson: jsonFile.writeFile,
    writeJsonSync: jsonFile.writeFileSync
  };
  return jsonfile;
}
var outputFile_1;
var hasRequiredOutputFile;
function requireOutputFile() {
  if (hasRequiredOutputFile) return outputFile_1;
  hasRequiredOutputFile = 1;
  const u = requireUniversalify().fromCallback;
  const fs2 = requireGracefulFs();
  const path = require$$1$3;
  const mkdir = /* @__PURE__ */ requireMkdirs();
  const pathExists = requirePathExists().pathExists;
  function outputFile(file2, data, encoding, callback) {
    if (typeof encoding === "function") {
      callback = encoding;
      encoding = "utf8";
    }
    const dir = path.dirname(file2);
    pathExists(dir, (err, itDoes) => {
      if (err) return callback(err);
      if (itDoes) return fs2.writeFile(file2, data, encoding, callback);
      mkdir.mkdirs(dir, (err2) => {
        if (err2) return callback(err2);
        fs2.writeFile(file2, data, encoding, callback);
      });
    });
  }
  function outputFileSync(file2, ...args) {
    const dir = path.dirname(file2);
    if (fs2.existsSync(dir)) {
      return fs2.writeFileSync(file2, ...args);
    }
    mkdir.mkdirsSync(dir);
    fs2.writeFileSync(file2, ...args);
  }
  outputFile_1 = {
    outputFile: u(outputFile),
    outputFileSync
  };
  return outputFile_1;
}
var outputJson_1;
var hasRequiredOutputJson;
function requireOutputJson() {
  if (hasRequiredOutputJson) return outputJson_1;
  hasRequiredOutputJson = 1;
  const { stringify } = requireUtils();
  const { outputFile } = /* @__PURE__ */ requireOutputFile();
  async function outputJson(file2, data, options = {}) {
    const str2 = stringify(data, options);
    await outputFile(file2, str2, options);
  }
  outputJson_1 = outputJson;
  return outputJson_1;
}
var outputJsonSync_1;
var hasRequiredOutputJsonSync;
function requireOutputJsonSync() {
  if (hasRequiredOutputJsonSync) return outputJsonSync_1;
  hasRequiredOutputJsonSync = 1;
  const { stringify } = requireUtils();
  const { outputFileSync } = /* @__PURE__ */ requireOutputFile();
  function outputJsonSync(file2, data, options) {
    const str2 = stringify(data, options);
    outputFileSync(file2, str2, options);
  }
  outputJsonSync_1 = outputJsonSync;
  return outputJsonSync_1;
}
var json$1;
var hasRequiredJson$1;
function requireJson$1() {
  if (hasRequiredJson$1) return json$1;
  hasRequiredJson$1 = 1;
  const u = requireUniversalify().fromPromise;
  const jsonFile = /* @__PURE__ */ requireJsonfile();
  jsonFile.outputJson = u(/* @__PURE__ */ requireOutputJson());
  jsonFile.outputJsonSync = /* @__PURE__ */ requireOutputJsonSync();
  jsonFile.outputJSON = jsonFile.outputJson;
  jsonFile.outputJSONSync = jsonFile.outputJsonSync;
  jsonFile.writeJSON = jsonFile.writeJson;
  jsonFile.writeJSONSync = jsonFile.writeJsonSync;
  jsonFile.readJSON = jsonFile.readJson;
  jsonFile.readJSONSync = jsonFile.readJsonSync;
  json$1 = jsonFile;
  return json$1;
}
var move_1;
var hasRequiredMove$1;
function requireMove$1() {
  if (hasRequiredMove$1) return move_1;
  hasRequiredMove$1 = 1;
  const fs2 = requireGracefulFs();
  const path = require$$1$3;
  const copy2 = requireCopy().copy;
  const remove = requireRemove().remove;
  const mkdirp = requireMkdirs().mkdirp;
  const pathExists = requirePathExists().pathExists;
  const stat2 = /* @__PURE__ */ requireStat();
  function move2(src2, dest, opts, cb) {
    if (typeof opts === "function") {
      cb = opts;
      opts = {};
    }
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    stat2.checkPaths(src2, dest, "move", opts, (err, stats) => {
      if (err) return cb(err);
      const { srcStat, isChangingCase = false } = stats;
      stat2.checkParentPaths(src2, srcStat, dest, "move", (err2) => {
        if (err2) return cb(err2);
        if (isParentRoot(dest)) return doRename(src2, dest, overwrite, isChangingCase, cb);
        mkdirp(path.dirname(dest), (err3) => {
          if (err3) return cb(err3);
          return doRename(src2, dest, overwrite, isChangingCase, cb);
        });
      });
    });
  }
  function isParentRoot(dest) {
    const parent = path.dirname(dest);
    const parsedPath = path.parse(parent);
    return parsedPath.root === parent;
  }
  function doRename(src2, dest, overwrite, isChangingCase, cb) {
    if (isChangingCase) return rename(src2, dest, overwrite, cb);
    if (overwrite) {
      return remove(dest, (err) => {
        if (err) return cb(err);
        return rename(src2, dest, overwrite, cb);
      });
    }
    pathExists(dest, (err, destExists) => {
      if (err) return cb(err);
      if (destExists) return cb(new Error("dest already exists."));
      return rename(src2, dest, overwrite, cb);
    });
  }
  function rename(src2, dest, overwrite, cb) {
    fs2.rename(src2, dest, (err) => {
      if (!err) return cb();
      if (err.code !== "EXDEV") return cb(err);
      return moveAcrossDevice(src2, dest, overwrite, cb);
    });
  }
  function moveAcrossDevice(src2, dest, overwrite, cb) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copy2(src2, dest, opts, (err) => {
      if (err) return cb(err);
      return remove(src2, cb);
    });
  }
  move_1 = move2;
  return move_1;
}
var moveSync_1;
var hasRequiredMoveSync;
function requireMoveSync() {
  if (hasRequiredMoveSync) return moveSync_1;
  hasRequiredMoveSync = 1;
  const fs2 = requireGracefulFs();
  const path = require$$1$3;
  const copySync = requireCopy().copySync;
  const removeSync = requireRemove().removeSync;
  const mkdirpSync = requireMkdirs().mkdirpSync;
  const stat2 = /* @__PURE__ */ requireStat();
  function moveSync(src2, dest, opts) {
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    const { srcStat, isChangingCase = false } = stat2.checkPathsSync(src2, dest, "move", opts);
    stat2.checkParentPathsSync(src2, srcStat, dest, "move");
    if (!isParentRoot(dest)) mkdirpSync(path.dirname(dest));
    return doRename(src2, dest, overwrite, isChangingCase);
  }
  function isParentRoot(dest) {
    const parent = path.dirname(dest);
    const parsedPath = path.parse(parent);
    return parsedPath.root === parent;
  }
  function doRename(src2, dest, overwrite, isChangingCase) {
    if (isChangingCase) return rename(src2, dest, overwrite);
    if (overwrite) {
      removeSync(dest);
      return rename(src2, dest, overwrite);
    }
    if (fs2.existsSync(dest)) throw new Error("dest already exists.");
    return rename(src2, dest, overwrite);
  }
  function rename(src2, dest, overwrite) {
    try {
      fs2.renameSync(src2, dest);
    } catch (err) {
      if (err.code !== "EXDEV") throw err;
      return moveAcrossDevice(src2, dest, overwrite);
    }
  }
  function moveAcrossDevice(src2, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copySync(src2, dest, opts);
    return removeSync(src2);
  }
  moveSync_1 = moveSync;
  return moveSync_1;
}
var move;
var hasRequiredMove;
function requireMove() {
  if (hasRequiredMove) return move;
  hasRequiredMove = 1;
  const u = requireUniversalify().fromCallback;
  move = {
    move: u(/* @__PURE__ */ requireMove$1()),
    moveSync: /* @__PURE__ */ requireMoveSync()
  };
  return move;
}
var lib$4;
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$4;
  hasRequiredLib$3 = 1;
  lib$4 = {
    // Export promiseified graceful-fs:
    .../* @__PURE__ */ requireFs(),
    // Export extra methods:
    .../* @__PURE__ */ requireCopy(),
    .../* @__PURE__ */ requireEmpty(),
    .../* @__PURE__ */ requireEnsure(),
    .../* @__PURE__ */ requireJson$1(),
    .../* @__PURE__ */ requireMkdirs(),
    .../* @__PURE__ */ requireMove(),
    .../* @__PURE__ */ requireOutputFile(),
    .../* @__PURE__ */ requirePathExists(),
    .../* @__PURE__ */ requireRemove()
  };
  return lib$4;
}
var BaseUpdater = {};
var AppUpdater = {};
var out = {};
var CancellationToken = {};
var hasRequiredCancellationToken;
function requireCancellationToken() {
  if (hasRequiredCancellationToken) return CancellationToken;
  hasRequiredCancellationToken = 1;
  Object.defineProperty(CancellationToken, "__esModule", { value: true });
  CancellationToken.CancellationError = CancellationToken.CancellationToken = void 0;
  const events_1 = require$$0$3;
  let CancellationToken$1 = class CancellationToken extends events_1.EventEmitter {
    get cancelled() {
      return this._cancelled || this._parent != null && this._parent.cancelled;
    }
    set parent(value) {
      this.removeParentCancelHandler();
      this._parent = value;
      this.parentCancelHandler = () => this.cancel();
      this._parent.onCancel(this.parentCancelHandler);
    }
    // babel cannot compile ... correctly for super calls
    constructor(parent) {
      super();
      this.parentCancelHandler = null;
      this._parent = null;
      this._cancelled = false;
      if (parent != null) {
        this.parent = parent;
      }
    }
    cancel() {
      this._cancelled = true;
      this.emit("cancel");
    }
    onCancel(handler) {
      if (this.cancelled) {
        handler();
      } else {
        this.once("cancel", handler);
      }
    }
    createPromise(callback) {
      if (this.cancelled) {
        return Promise.reject(new CancellationError());
      }
      const finallyHandler = () => {
        if (cancelHandler != null) {
          try {
            this.removeListener("cancel", cancelHandler);
            cancelHandler = null;
          } catch (_ignore) {
          }
        }
      };
      let cancelHandler = null;
      return new Promise((resolve, reject) => {
        let addedCancelHandler = null;
        cancelHandler = () => {
          try {
            if (addedCancelHandler != null) {
              addedCancelHandler();
              addedCancelHandler = null;
            }
          } finally {
            reject(new CancellationError());
          }
        };
        if (this.cancelled) {
          cancelHandler();
          return;
        }
        this.onCancel(cancelHandler);
        callback(resolve, reject, (callback2) => {
          addedCancelHandler = callback2;
        });
      }).then((it) => {
        finallyHandler();
        return it;
      }).catch((e) => {
        finallyHandler();
        throw e;
      });
    }
    removeParentCancelHandler() {
      const parent = this._parent;
      if (parent != null && this.parentCancelHandler != null) {
        parent.removeListener("cancel", this.parentCancelHandler);
        this.parentCancelHandler = null;
      }
    }
    dispose() {
      try {
        this.removeParentCancelHandler();
      } finally {
        this.removeAllListeners();
        this._parent = null;
      }
    }
  };
  CancellationToken.CancellationToken = CancellationToken$1;
  class CancellationError extends Error {
    constructor() {
      super("cancelled");
    }
  }
  CancellationToken.CancellationError = CancellationError;
  return CancellationToken;
}
var error = {};
var hasRequiredError;
function requireError() {
  if (hasRequiredError) return error;
  hasRequiredError = 1;
  Object.defineProperty(error, "__esModule", { value: true });
  error.newError = newError;
  function newError(message, code) {
    const error2 = new Error(message);
    error2.code = code;
    return error2;
  }
  return error;
}
var httpExecutor = {};
var src = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common$1;
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$1 = setup;
  return common$1;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports$1) {
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load;
    exports$1.useColors = useColors;
    exports$1.storage = localstorage();
    exports$1.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports$1.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports$1.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports$1.storage.setItem("debug", namespaces);
        } else {
          exports$1.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports$1.storage.getItem("debug") || exports$1.storage.getItem("DEBUG");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = requireCommon$1()(exports$1);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os = require$$2$1;
  const tty = require$$1$4;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
  return supportsColor_1;
}
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node.exports;
  hasRequiredNode = 1;
  (function(module, exports$1) {
    const tty = require$$1$4;
    const util2 = require$$1$1;
    exports$1.init = init;
    exports$1.log = log;
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load;
    exports$1.useColors = useColors;
    exports$1.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports$1.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports$1.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports$1.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports$1.inspectOpts ? Boolean(exports$1.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports$1.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.formatWithOptions(exports$1.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports$1.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports$1.inspectOpts[keys[i]];
      }
    }
    module.exports = requireCommon$1()(exports$1);
    const { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str2) => str2.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src.exports;
  hasRequiredSrc = 1;
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    src.exports = requireBrowser();
  } else {
    src.exports = requireNode();
  }
  return src.exports;
}
var ProgressCallbackTransform = {};
var hasRequiredProgressCallbackTransform;
function requireProgressCallbackTransform() {
  if (hasRequiredProgressCallbackTransform) return ProgressCallbackTransform;
  hasRequiredProgressCallbackTransform = 1;
  Object.defineProperty(ProgressCallbackTransform, "__esModule", { value: true });
  ProgressCallbackTransform.ProgressCallbackTransform = void 0;
  const stream_1 = require$$0$2;
  let ProgressCallbackTransform$1 = class ProgressCallbackTransform extends stream_1.Transform {
    constructor(total, cancellationToken, onProgress) {
      super();
      this.total = total;
      this.cancellationToken = cancellationToken;
      this.onProgress = onProgress;
      this.start = Date.now();
      this.transferred = 0;
      this.delta = 0;
      this.nextUpdate = this.start + 1e3;
    }
    _transform(chunk, encoding, callback) {
      if (this.cancellationToken.cancelled) {
        callback(new Error("cancelled"), null);
        return;
      }
      this.transferred += chunk.length;
      this.delta += chunk.length;
      const now = Date.now();
      if (now >= this.nextUpdate && this.transferred !== this.total) {
        this.nextUpdate = now + 1e3;
        this.onProgress({
          total: this.total,
          delta: this.delta,
          transferred: this.transferred,
          percent: this.transferred / this.total * 100,
          bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1e3))
        });
        this.delta = 0;
      }
      callback(null, chunk);
    }
    _flush(callback) {
      if (this.cancellationToken.cancelled) {
        callback(new Error("cancelled"));
        return;
      }
      this.onProgress({
        total: this.total,
        delta: this.delta,
        transferred: this.total,
        percent: 100,
        bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
      });
      this.delta = 0;
      callback(null);
    }
  };
  ProgressCallbackTransform.ProgressCallbackTransform = ProgressCallbackTransform$1;
  return ProgressCallbackTransform;
}
var hasRequiredHttpExecutor;
function requireHttpExecutor() {
  if (hasRequiredHttpExecutor) return httpExecutor;
  hasRequiredHttpExecutor = 1;
  Object.defineProperty(httpExecutor, "__esModule", { value: true });
  httpExecutor.DigestTransform = httpExecutor.HttpExecutor = httpExecutor.HttpError = void 0;
  httpExecutor.createHttpError = createHttpError;
  httpExecutor.parseJson = parseJson;
  httpExecutor.configureRequestOptionsFromUrl = configureRequestOptionsFromUrl;
  httpExecutor.configureRequestUrl = configureRequestUrl;
  httpExecutor.safeGetHeader = safeGetHeader;
  httpExecutor.configureRequestOptions = configureRequestOptions;
  httpExecutor.safeStringifyJson = safeStringifyJson;
  const crypto_1 = require$$0$4;
  const debug_12 = requireSrc();
  const fs_1 = require$$1$2;
  const stream_1 = require$$0$2;
  const url_1 = require$$2$2;
  const CancellationToken_1 = requireCancellationToken();
  const error_1 = requireError();
  const ProgressCallbackTransform_1 = requireProgressCallbackTransform();
  const debug = (0, debug_12.default)("electron-builder");
  function createHttpError(response, description = null) {
    return new HttpError(response.statusCode || -1, `${response.statusCode} ${response.statusMessage}` + (description == null ? "" : "\n" + JSON.stringify(description, null, "  ")) + "\nHeaders: " + safeStringifyJson(response.headers), description);
  }
  const HTTP_STATUS_CODES = /* @__PURE__ */ new Map([
    [429, "Too many requests"],
    [400, "Bad request"],
    [403, "Forbidden"],
    [404, "Not found"],
    [405, "Method not allowed"],
    [406, "Not acceptable"],
    [408, "Request timeout"],
    [413, "Request entity too large"],
    [500, "Internal server error"],
    [502, "Bad gateway"],
    [503, "Service unavailable"],
    [504, "Gateway timeout"],
    [505, "HTTP version not supported"]
  ]);
  class HttpError extends Error {
    constructor(statusCode, message = `HTTP error: ${HTTP_STATUS_CODES.get(statusCode) || statusCode}`, description = null) {
      super(message);
      this.statusCode = statusCode;
      this.description = description;
      this.name = "HttpError";
      this.code = `HTTP_ERROR_${statusCode}`;
    }
    isServerError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
  }
  httpExecutor.HttpError = HttpError;
  function parseJson(result) {
    return result.then((it) => it == null || it.length === 0 ? null : JSON.parse(it));
  }
  class HttpExecutor {
    constructor() {
      this.maxRedirects = 10;
    }
    request(options, cancellationToken = new CancellationToken_1.CancellationToken(), data) {
      configureRequestOptions(options);
      const json2 = data == null ? void 0 : JSON.stringify(data);
      const encodedData = json2 ? Buffer.from(json2) : void 0;
      if (encodedData != null) {
        debug(json2);
        const { headers, ...opts } = options;
        options = {
          method: "post",
          headers: {
            "Content-Type": "application/json",
            "Content-Length": encodedData.length,
            ...headers
          },
          ...opts
        };
      }
      return this.doApiRequest(options, cancellationToken, (it) => it.end(encodedData));
    }
    doApiRequest(options, cancellationToken, requestProcessor, redirectCount = 0) {
      if (debug.enabled) {
        debug(`Request: ${safeStringifyJson(options)}`);
      }
      return cancellationToken.createPromise((resolve, reject, onCancel) => {
        const request = this.createRequest(options, (response) => {
          try {
            this.handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor);
          } catch (e) {
            reject(e);
          }
        });
        this.addErrorAndTimeoutHandlers(request, reject, options.timeout);
        this.addRedirectHandlers(request, options, reject, redirectCount, (options2) => {
          this.doApiRequest(options2, cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);
        });
        requestProcessor(request, reject);
        onCancel(() => request.abort());
      });
    }
    // noinspection JSUnusedLocalSymbols
    // eslint-disable-next-line
    addRedirectHandlers(request, options, reject, redirectCount, handler) {
    }
    addErrorAndTimeoutHandlers(request, reject, timeout = 60 * 1e3) {
      this.addTimeOutHandler(request, reject, timeout);
      request.on("error", reject);
      request.on("aborted", () => {
        reject(new Error("Request has been aborted by the server"));
      });
    }
    handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor) {
      var _a;
      if (debug.enabled) {
        debug(`Response: ${response.statusCode} ${response.statusMessage}, request options: ${safeStringifyJson(options)}`);
      }
      if (response.statusCode === 404) {
        reject(createHttpError(response, `method: ${options.method || "GET"} url: ${options.protocol || "https:"}//${options.hostname}${options.port ? `:${options.port}` : ""}${options.path}

Please double check that your authentication token is correct. Due to security reasons, actual status maybe not reported, but 404.
`));
        return;
      } else if (response.statusCode === 204) {
        resolve();
        return;
      }
      const code = (_a = response.statusCode) !== null && _a !== void 0 ? _a : 0;
      const shouldRedirect = code >= 300 && code < 400;
      const redirectUrl = safeGetHeader(response, "location");
      if (shouldRedirect && redirectUrl != null) {
        if (redirectCount > this.maxRedirects) {
          reject(this.createMaxRedirectError());
          return;
        }
        this.doApiRequest(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options), cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);
        return;
      }
      response.setEncoding("utf8");
      let data = "";
      response.on("error", reject);
      response.on("data", (chunk) => data += chunk);
      response.on("end", () => {
        try {
          if (response.statusCode != null && response.statusCode >= 400) {
            const contentType = safeGetHeader(response, "content-type");
            const isJson = contentType != null && (Array.isArray(contentType) ? contentType.find((it) => it.includes("json")) != null : contentType.includes("json"));
            reject(createHttpError(response, `method: ${options.method || "GET"} url: ${options.protocol || "https:"}//${options.hostname}${options.port ? `:${options.port}` : ""}${options.path}

          Data:
          ${isJson ? JSON.stringify(JSON.parse(data)) : data}
          `));
          } else {
            resolve(data.length === 0 ? null : data);
          }
        } catch (e) {
          reject(e);
        }
      });
    }
    async downloadToBuffer(url, options) {
      return await options.cancellationToken.createPromise((resolve, reject, onCancel) => {
        const responseChunks = [];
        const requestOptions = {
          headers: options.headers || void 0,
          // because PrivateGitHubProvider requires HttpExecutor.prepareRedirectUrlOptions logic, so, we need to redirect manually
          redirect: "manual"
        };
        configureRequestUrl(url, requestOptions);
        configureRequestOptions(requestOptions);
        this.doDownload(requestOptions, {
          destination: null,
          options,
          onCancel,
          callback: (error2) => {
            if (error2 == null) {
              resolve(Buffer.concat(responseChunks));
            } else {
              reject(error2);
            }
          },
          responseHandler: (response, callback) => {
            let receivedLength = 0;
            response.on("data", (chunk) => {
              receivedLength += chunk.length;
              if (receivedLength > 524288e3) {
                callback(new Error("Maximum allowed size is 500 MB"));
                return;
              }
              responseChunks.push(chunk);
            });
            response.on("end", () => {
              callback(null);
            });
          }
        }, 0);
      });
    }
    doDownload(requestOptions, options, redirectCount) {
      const request = this.createRequest(requestOptions, (response) => {
        if (response.statusCode >= 400) {
          options.callback(new Error(`Cannot download "${requestOptions.protocol || "https:"}//${requestOptions.hostname}${requestOptions.path}", status ${response.statusCode}: ${response.statusMessage}`));
          return;
        }
        response.on("error", options.callback);
        const redirectUrl = safeGetHeader(response, "location");
        if (redirectUrl != null) {
          if (redirectCount < this.maxRedirects) {
            this.doDownload(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, requestOptions), options, redirectCount++);
          } else {
            options.callback(this.createMaxRedirectError());
          }
          return;
        }
        if (options.responseHandler == null) {
          configurePipes(options, response);
        } else {
          options.responseHandler(response, options.callback);
        }
      });
      this.addErrorAndTimeoutHandlers(request, options.callback, requestOptions.timeout);
      this.addRedirectHandlers(request, requestOptions, options.callback, redirectCount, (requestOptions2) => {
        this.doDownload(requestOptions2, options, redirectCount++);
      });
      request.end();
    }
    createMaxRedirectError() {
      return new Error(`Too many redirects (> ${this.maxRedirects})`);
    }
    addTimeOutHandler(request, callback, timeout) {
      request.on("socket", (socket) => {
        socket.setTimeout(timeout, () => {
          request.abort();
          callback(new Error("Request timed out"));
        });
      });
    }
    static prepareRedirectUrlOptions(redirectUrl, options) {
      const newOptions = configureRequestOptionsFromUrl(redirectUrl, { ...options });
      const headers = newOptions.headers;
      if (headers === null || headers === void 0 ? void 0 : headers.authorization) {
        const originalUrl = HttpExecutor.reconstructOriginalUrl(options);
        const parsedRedirectUrl = parseUrl(redirectUrl, options);
        if (HttpExecutor.isCrossOriginRedirect(originalUrl, parsedRedirectUrl)) {
          if (debug.enabled) {
            debug(`Given the cross-origin redirect (from ${originalUrl.host} to ${parsedRedirectUrl.host}), the Authorization header will be stripped out.`);
          }
          delete headers.authorization;
        }
      }
      return newOptions;
    }
    static reconstructOriginalUrl(options) {
      const protocol = options.protocol || "https:";
      if (!options.hostname) {
        throw new Error("Missing hostname in request options");
      }
      const hostname = options.hostname;
      const port = options.port ? `:${options.port}` : "";
      const path = options.path || "/";
      return new url_1.URL(`${protocol}//${hostname}${port}${path}`);
    }
    static isCrossOriginRedirect(originalUrl, redirectUrl) {
      if (originalUrl.hostname.toLowerCase() !== redirectUrl.hostname.toLowerCase()) {
        return true;
      }
      if (originalUrl.protocol === "http:" && // This can be replaced with `!originalUrl.port`, but for the sake of clarity.
      ["80", ""].includes(originalUrl.port) && redirectUrl.protocol === "https:" && // This can be replaced with `!redirectUrl.port`, but for the sake of clarity.
      ["443", ""].includes(redirectUrl.port)) {
        return false;
      }
      if (originalUrl.protocol !== redirectUrl.protocol) {
        return true;
      }
      const originalPort = originalUrl.port;
      const redirectPort = redirectUrl.port;
      return originalPort !== redirectPort;
    }
    static retryOnServerError(task, maxRetries = 3) {
      for (let attemptNumber = 0; ; attemptNumber++) {
        try {
          return task();
        } catch (e) {
          if (attemptNumber < maxRetries && (e instanceof HttpError && e.isServerError() || e.code === "EPIPE")) {
            continue;
          }
          throw e;
        }
      }
    }
  }
  httpExecutor.HttpExecutor = HttpExecutor;
  function parseUrl(url, options) {
    try {
      return new url_1.URL(url);
    } catch {
      const hostname = options.hostname;
      const protocol = options.protocol || "https:";
      const port = options.port ? `:${options.port}` : "";
      const baseUrl = `${protocol}//${hostname}${port}`;
      return new url_1.URL(url, baseUrl);
    }
  }
  function configureRequestOptionsFromUrl(url, options) {
    const result = configureRequestOptions(options);
    const parsedUrl = parseUrl(url, options);
    configureRequestUrl(parsedUrl, result);
    return result;
  }
  function configureRequestUrl(url, options) {
    options.protocol = url.protocol;
    options.hostname = url.hostname;
    if (url.port) {
      options.port = url.port;
    } else if (options.port) {
      delete options.port;
    }
    options.path = url.pathname + url.search;
  }
  class DigestTransform extends stream_1.Transform {
    // noinspection JSUnusedGlobalSymbols
    get actual() {
      return this._actual;
    }
    constructor(expected, algorithm = "sha512", encoding = "base64") {
      super();
      this.expected = expected;
      this.algorithm = algorithm;
      this.encoding = encoding;
      this._actual = null;
      this.isValidateOnEnd = true;
      this.digester = (0, crypto_1.createHash)(algorithm);
    }
    // noinspection JSUnusedGlobalSymbols
    _transform(chunk, encoding, callback) {
      this.digester.update(chunk);
      callback(null, chunk);
    }
    // noinspection JSUnusedGlobalSymbols
    _flush(callback) {
      this._actual = this.digester.digest(this.encoding);
      if (this.isValidateOnEnd) {
        try {
          this.validate();
        } catch (e) {
          callback(e);
          return;
        }
      }
      callback(null);
    }
    validate() {
      if (this._actual == null) {
        throw (0, error_1.newError)("Not finished yet", "ERR_STREAM_NOT_FINISHED");
      }
      if (this._actual !== this.expected) {
        throw (0, error_1.newError)(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, "ERR_CHECKSUM_MISMATCH");
      }
      return null;
    }
  }
  httpExecutor.DigestTransform = DigestTransform;
  function checkSha2(sha2Header, sha2, callback) {
    if (sha2Header != null && sha2 != null && sha2Header !== sha2) {
      callback(new Error(`checksum mismatch: expected ${sha2} but got ${sha2Header} (X-Checksum-Sha2 header)`));
      return false;
    }
    return true;
  }
  function safeGetHeader(response, headerKey) {
    const value = response.headers[headerKey];
    if (value == null) {
      return null;
    } else if (Array.isArray(value)) {
      return value.length === 0 ? null : value[value.length - 1];
    } else {
      return value;
    }
  }
  function configurePipes(options, response) {
    if (!checkSha2(safeGetHeader(response, "X-Checksum-Sha2"), options.options.sha2, options.callback)) {
      return;
    }
    const streams2 = [];
    if (options.options.onProgress != null) {
      const contentLength = safeGetHeader(response, "content-length");
      if (contentLength != null) {
        streams2.push(new ProgressCallbackTransform_1.ProgressCallbackTransform(parseInt(contentLength, 10), options.options.cancellationToken, options.options.onProgress));
      }
    }
    const sha512 = options.options.sha512;
    if (sha512 != null) {
      streams2.push(new DigestTransform(sha512, "sha512", sha512.length === 128 && !sha512.includes("+") && !sha512.includes("Z") && !sha512.includes("=") ? "hex" : "base64"));
    } else if (options.options.sha2 != null) {
      streams2.push(new DigestTransform(options.options.sha2, "sha256", "hex"));
    }
    const fileOut = (0, fs_1.createWriteStream)(options.destination);
    streams2.push(fileOut);
    let lastStream = response;
    for (const stream of streams2) {
      stream.on("error", (error2) => {
        fileOut.close();
        if (!options.options.cancellationToken.cancelled) {
          options.callback(error2);
        }
      });
      lastStream = lastStream.pipe(stream);
    }
    fileOut.on("finish", () => {
      fileOut.close(options.callback);
    });
  }
  function configureRequestOptions(options, token, method) {
    if (method != null) {
      options.method = method;
    }
    options.headers = { ...options.headers };
    const headers = options.headers;
    if (token != null) {
      headers.authorization = token.startsWith("Basic") || token.startsWith("Bearer") ? token : `token ${token}`;
    }
    if (headers["User-Agent"] == null) {
      headers["User-Agent"] = "electron-builder";
    }
    if (method == null || method === "GET" || headers["Cache-Control"] == null) {
      headers["Cache-Control"] = "no-cache";
    }
    if (options.protocol == null && process.versions.electron != null) {
      options.protocol = "https:";
    }
    return options;
  }
  function safeStringifyJson(data, skippedNames) {
    return JSON.stringify(data, (name, value) => {
      if (name.endsWith("Authorization") || name.endsWith("authorization") || name.endsWith("Password") || name.endsWith("PASSWORD") || name.endsWith("Token") || name.includes("password") || name.includes("token") || skippedNames != null && skippedNames.has(name)) {
        return "<stripped sensitive data>";
      }
      return value;
    }, 2);
  }
  return httpExecutor;
}
var MemoLazy = {};
var hasRequiredMemoLazy;
function requireMemoLazy() {
  if (hasRequiredMemoLazy) return MemoLazy;
  hasRequiredMemoLazy = 1;
  Object.defineProperty(MemoLazy, "__esModule", { value: true });
  MemoLazy.MemoLazy = void 0;
  let MemoLazy$1 = class MemoLazy {
    constructor(selector, creator) {
      this.selector = selector;
      this.creator = creator;
      this.selected = void 0;
      this._value = void 0;
    }
    get hasValue() {
      return this._value !== void 0;
    }
    get value() {
      const selected = this.selector();
      if (this._value !== void 0 && equals(this.selected, selected)) {
        return this._value;
      }
      this.selected = selected;
      const result = this.creator(selected);
      this.value = result;
      return result;
    }
    set value(value) {
      this._value = value;
    }
  };
  MemoLazy.MemoLazy = MemoLazy$1;
  function equals(firstValue, secondValue) {
    const isFirstObject = typeof firstValue === "object" && firstValue !== null;
    const isSecondObject = typeof secondValue === "object" && secondValue !== null;
    if (isFirstObject && isSecondObject) {
      const keys1 = Object.keys(firstValue);
      const keys2 = Object.keys(secondValue);
      return keys1.length === keys2.length && keys1.every((key) => equals(firstValue[key], secondValue[key]));
    }
    return firstValue === secondValue;
  }
  return MemoLazy;
}
var publishOptions = {};
var hasRequiredPublishOptions;
function requirePublishOptions() {
  if (hasRequiredPublishOptions) return publishOptions;
  hasRequiredPublishOptions = 1;
  Object.defineProperty(publishOptions, "__esModule", { value: true });
  publishOptions.githubUrl = githubUrl;
  publishOptions.githubTagPrefix = githubTagPrefix;
  publishOptions.getS3LikeProviderBaseUrl = getS3LikeProviderBaseUrl;
  function githubUrl(options, defaultHost = "github.com") {
    return `${options.protocol || "https"}://${options.host || defaultHost}`;
  }
  function githubTagPrefix(options) {
    var _a;
    if (options.tagNamePrefix) {
      return options.tagNamePrefix;
    }
    if ((_a = options.vPrefixedTagName) !== null && _a !== void 0 ? _a : true) {
      return "v";
    }
    return "";
  }
  function getS3LikeProviderBaseUrl(configuration) {
    const provider = configuration.provider;
    if (provider === "s3") {
      return s3Url(configuration);
    }
    if (provider === "spaces") {
      return spacesUrl(configuration);
    }
    throw new Error(`Not supported provider: ${provider}`);
  }
  function s3Url(options) {
    let url;
    if (options.accelerate == true) {
      url = `https://${options.bucket}.s3-accelerate.amazonaws.com`;
    } else if (options.endpoint != null) {
      url = `${options.endpoint}/${options.bucket}`;
    } else if (options.bucket.includes(".")) {
      if (options.region == null) {
        throw new Error(`Bucket name "${options.bucket}" includes a dot, but S3 region is missing`);
      }
      if (options.region === "us-east-1") {
        url = `https://s3.amazonaws.com/${options.bucket}`;
      } else {
        url = `https://s3-${options.region}.amazonaws.com/${options.bucket}`;
      }
    } else if (options.region === "cn-north-1") {
      url = `https://${options.bucket}.s3.${options.region}.amazonaws.com.cn`;
    } else {
      url = `https://${options.bucket}.s3.amazonaws.com`;
    }
    return appendPath(url, options.path);
  }
  function appendPath(url, p) {
    if (p != null && p.length > 0) {
      if (!p.startsWith("/")) {
        url += "/";
      }
      url += p;
    }
    return url;
  }
  function spacesUrl(options) {
    if (options.name == null) {
      throw new Error(`name is missing`);
    }
    if (options.region == null) {
      throw new Error(`region is missing`);
    }
    return appendPath(`https://${options.name}.${options.region}.digitaloceanspaces.com`, options.path);
  }
  return publishOptions;
}
var retry = {};
var hasRequiredRetry;
function requireRetry() {
  if (hasRequiredRetry) return retry;
  hasRequiredRetry = 1;
  Object.defineProperty(retry, "__esModule", { value: true });
  retry.retry = retry$1;
  const CancellationToken_1 = requireCancellationToken();
  async function retry$1(task, options) {
    var _a;
    const { retries: retryCount, interval, backoff = 0, attempt = 0, shouldRetry, cancellationToken = new CancellationToken_1.CancellationToken() } = options;
    try {
      return await task();
    } catch (error2) {
      if (await Promise.resolve((_a = shouldRetry === null || shouldRetry === void 0 ? void 0 : shouldRetry(error2)) !== null && _a !== void 0 ? _a : true) && retryCount > 0 && !cancellationToken.cancelled) {
        await new Promise((resolve) => setTimeout(resolve, interval + backoff * attempt));
        return await retry$1(task, { ...options, retries: retryCount - 1, attempt: attempt + 1 });
      } else {
        throw error2;
      }
    }
  }
  return retry;
}
var rfc2253Parser = {};
var hasRequiredRfc2253Parser;
function requireRfc2253Parser() {
  if (hasRequiredRfc2253Parser) return rfc2253Parser;
  hasRequiredRfc2253Parser = 1;
  Object.defineProperty(rfc2253Parser, "__esModule", { value: true });
  rfc2253Parser.parseDn = parseDn;
  function parseDn(seq2) {
    let quoted = false;
    let key = null;
    let token = "";
    let nextNonSpace = 0;
    seq2 = seq2.trim();
    const result = /* @__PURE__ */ new Map();
    for (let i = 0; i <= seq2.length; i++) {
      if (i === seq2.length) {
        if (key !== null) {
          result.set(key, token);
        }
        break;
      }
      const ch = seq2[i];
      if (quoted) {
        if (ch === '"') {
          quoted = false;
          continue;
        }
      } else {
        if (ch === '"') {
          quoted = true;
          continue;
        }
        if (ch === "\\") {
          i++;
          const ord = parseInt(seq2.slice(i, i + 2), 16);
          if (Number.isNaN(ord)) {
            token += seq2[i];
          } else {
            i++;
            token += String.fromCharCode(ord);
          }
          continue;
        }
        if (key === null && ch === "=") {
          key = token;
          token = "";
          continue;
        }
        if (ch === "," || ch === ";" || ch === "+") {
          if (key !== null) {
            result.set(key, token);
          }
          key = null;
          token = "";
          continue;
        }
      }
      if (ch === " " && !quoted) {
        if (token.length === 0) {
          continue;
        }
        if (i > nextNonSpace) {
          let j = i;
          while (seq2[j] === " ") {
            j++;
          }
          nextNonSpace = j;
        }
        if (nextNonSpace >= seq2.length || seq2[nextNonSpace] === "," || seq2[nextNonSpace] === ";" || key === null && seq2[nextNonSpace] === "=" || key !== null && seq2[nextNonSpace] === "+") {
          i = nextNonSpace - 1;
          continue;
        }
      }
      token += ch;
    }
    return result;
  }
  return rfc2253Parser;
}
var uuid = {};
var hasRequiredUuid;
function requireUuid() {
  if (hasRequiredUuid) return uuid;
  hasRequiredUuid = 1;
  Object.defineProperty(uuid, "__esModule", { value: true });
  uuid.nil = uuid.UUID = void 0;
  const crypto_1 = require$$0$4;
  const error_1 = requireError();
  const invalidName = "options.name must be either a string or a Buffer";
  const randomHost = (0, crypto_1.randomBytes)(16);
  randomHost[0] = randomHost[0] | 1;
  const hex2byte = {};
  const byte2hex = [];
  for (let i = 0; i < 256; i++) {
    const hex = (i + 256).toString(16).substr(1);
    hex2byte[hex] = i;
    byte2hex[i] = hex;
  }
  class UUID {
    constructor(uuid2) {
      this.ascii = null;
      this.binary = null;
      const check = UUID.check(uuid2);
      if (!check) {
        throw new Error("not a UUID");
      }
      this.version = check.version;
      if (check.format === "ascii") {
        this.ascii = uuid2;
      } else {
        this.binary = uuid2;
      }
    }
    static v5(name, namespace) {
      return uuidNamed(name, "sha1", 80, namespace);
    }
    toString() {
      if (this.ascii == null) {
        this.ascii = stringify(this.binary);
      }
      return this.ascii;
    }
    inspect() {
      return `UUID v${this.version} ${this.toString()}`;
    }
    static check(uuid2, offset = 0) {
      if (typeof uuid2 === "string") {
        uuid2 = uuid2.toLowerCase();
        if (!/^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(uuid2)) {
          return false;
        }
        if (uuid2 === "00000000-0000-0000-0000-000000000000") {
          return { version: void 0, variant: "nil", format: "ascii" };
        }
        return {
          version: (hex2byte[uuid2[14] + uuid2[15]] & 240) >> 4,
          variant: getVariant((hex2byte[uuid2[19] + uuid2[20]] & 224) >> 5),
          format: "ascii"
        };
      }
      if (Buffer.isBuffer(uuid2)) {
        if (uuid2.length < offset + 16) {
          return false;
        }
        let i = 0;
        for (; i < 16; i++) {
          if (uuid2[offset + i] !== 0) {
            break;
          }
        }
        if (i === 16) {
          return { version: void 0, variant: "nil", format: "binary" };
        }
        return {
          version: (uuid2[offset + 6] & 240) >> 4,
          variant: getVariant((uuid2[offset + 8] & 224) >> 5),
          format: "binary"
        };
      }
      throw (0, error_1.newError)("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
    }
    // read stringified uuid into a Buffer
    static parse(input) {
      const buffer = Buffer.allocUnsafe(16);
      let j = 0;
      for (let i = 0; i < 16; i++) {
        buffer[i] = hex2byte[input[j++] + input[j++]];
        if (i === 3 || i === 5 || i === 7 || i === 9) {
          j += 1;
        }
      }
      return buffer;
    }
  }
  uuid.UUID = UUID;
  UUID.OID = UUID.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
  function getVariant(bits) {
    switch (bits) {
      case 0:
      case 1:
      case 3:
        return "ncs";
      case 4:
      case 5:
        return "rfc4122";
      case 6:
        return "microsoft";
      default:
        return "future";
    }
  }
  var UuidEncoding;
  (function(UuidEncoding2) {
    UuidEncoding2[UuidEncoding2["ASCII"] = 0] = "ASCII";
    UuidEncoding2[UuidEncoding2["BINARY"] = 1] = "BINARY";
    UuidEncoding2[UuidEncoding2["OBJECT"] = 2] = "OBJECT";
  })(UuidEncoding || (UuidEncoding = {}));
  function uuidNamed(name, hashMethod, version2, namespace, encoding = UuidEncoding.ASCII) {
    const hash = (0, crypto_1.createHash)(hashMethod);
    const nameIsNotAString = typeof name !== "string";
    if (nameIsNotAString && !Buffer.isBuffer(name)) {
      throw (0, error_1.newError)(invalidName, "ERR_INVALID_UUID_NAME");
    }
    hash.update(namespace);
    hash.update(name);
    const buffer = hash.digest();
    let result;
    switch (encoding) {
      case UuidEncoding.BINARY:
        buffer[6] = buffer[6] & 15 | version2;
        buffer[8] = buffer[8] & 63 | 128;
        result = buffer;
        break;
      case UuidEncoding.OBJECT:
        buffer[6] = buffer[6] & 15 | version2;
        buffer[8] = buffer[8] & 63 | 128;
        result = new UUID(buffer);
        break;
      default:
        result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6] & 15 | version2] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8] & 63 | 128] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
        break;
    }
    return result;
  }
  function stringify(buffer) {
    return byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6]] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8]] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
  }
  uuid.nil = new UUID("00000000-0000-0000-0000-000000000000");
  return uuid;
}
var xml = {};
var sax = {};
var hasRequiredSax;
function requireSax() {
  if (hasRequiredSax) return sax;
  hasRequiredSax = 1;
  (function(exports$1) {
    (function(sax2) {
      sax2.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax2.SAXParser = SAXParser;
      sax2.SAXStream = SAXStream;
      sax2.createStream = createStream;
      sax2.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax2.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        if (parser.opt.unquotedAttributeValues === void 0) {
          parser.opt.unquotedAttributeValues = !strict;
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error2(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax2.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = require("stream").Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      if (!Stream) Stream = function() {
      };
      var streamWraps = sax2.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            this._decoder = new TextDecoder("utf8");
          }
          data = this._decoder.decode(data, { stream: true });
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        if (this._decoder) {
          var remaining = this._decoder.decode();
          if (remaining) {
            this._parser.write(remaining);
            this.emit("data", remaining);
          }
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax2.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax2.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      };
      sax2.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      };
      Object.keys(sax2.ENTITIES).forEach(function(key) {
        var e = sax2.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax2.ENTITIES[key] = s2;
      });
      for (var s in sax2.STATE) {
        sax2.STATE[sax2.STATE[s]] = s;
      }
      S = sax2.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
      }
      function error2(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error2(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error2(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(
              parser,
              "Unbound namespace prefix: " + JSON.stringify(parser.tagName)
            );
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(
                parser,
                "Unbound namespace prefix: " + JSON.stringify(prefix)
              );
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity || num < 0 || num > 1114111) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error2(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) ;
              else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
                continue;
              }
              if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                parser.state = S.DOCTYPE_DTD;
                parser.doctype += "<!" + parser.sgmlDecl + c;
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              if (c === "]") {
                parser.doctype += c;
                parser.state = S.DOCTYPE;
              } else if (c === "<") {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else if (isQuote(c)) {
                parser.doctype += c;
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              } else {
                parser.doctype += c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else if (parser.doctype && parser.doctype !== true) {
                parser.state = S.DOCTYPE_DTD;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              var starti = i - 1;
              while (c && c !== "]") {
                c = charAt(chunk, i++);
                if (c && parser.trackPosition) {
                  parser.position++;
                  if (c === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.cdata += chunk.substring(starti, i - 1);
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(
                  parser,
                  "Forward-slash in opening tag not followed by >"
                );
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                if (!parser.opt.unquotedAttributeValues) {
                  error2(parser, "Unquoted attribute value");
                }
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName + c;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                var parsedEntity = parseEntity(parser);
                if (parser.opt.unparsedEntities && !Object.values(sax2.XML_ENTITIES).includes(parsedEntity)) {
                  parser.entity = "";
                  parser.state = returnState;
                  parser.write(parsedEntity);
                } else {
                  parser[buffer] += parsedEntity;
                  parser.entity = "";
                  parser.state = returnState;
                }
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default: {
              throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(exports$1);
  })(sax);
  return sax;
}
var hasRequiredXml;
function requireXml() {
  if (hasRequiredXml) return xml;
  hasRequiredXml = 1;
  Object.defineProperty(xml, "__esModule", { value: true });
  xml.XElement = void 0;
  xml.parseXml = parseXml;
  const sax2 = requireSax();
  const error_1 = requireError();
  class XElement {
    constructor(name) {
      this.name = name;
      this.value = "";
      this.attributes = null;
      this.isCData = false;
      this.elements = null;
      if (!name) {
        throw (0, error_1.newError)("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
      }
      if (!isValidName(name)) {
        throw (0, error_1.newError)(`Invalid element name: ${name}`, "ERR_XML_ELEMENT_INVALID_NAME");
      }
    }
    attribute(name) {
      const result = this.attributes === null ? null : this.attributes[name];
      if (result == null) {
        throw (0, error_1.newError)(`No attribute "${name}"`, "ERR_XML_MISSED_ATTRIBUTE");
      }
      return result;
    }
    removeAttribute(name) {
      if (this.attributes !== null) {
        delete this.attributes[name];
      }
    }
    element(name, ignoreCase = false, errorIfMissed = null) {
      const result = this.elementOrNull(name, ignoreCase);
      if (result === null) {
        throw (0, error_1.newError)(errorIfMissed || `No element "${name}"`, "ERR_XML_MISSED_ELEMENT");
      }
      return result;
    }
    elementOrNull(name, ignoreCase = false) {
      if (this.elements === null) {
        return null;
      }
      for (const element of this.elements) {
        if (isNameEquals(element, name, ignoreCase)) {
          return element;
        }
      }
      return null;
    }
    getElements(name, ignoreCase = false) {
      if (this.elements === null) {
        return [];
      }
      return this.elements.filter((it) => isNameEquals(it, name, ignoreCase));
    }
    elementValueOrEmpty(name, ignoreCase = false) {
      const element = this.elementOrNull(name, ignoreCase);
      return element === null ? "" : element.value;
    }
  }
  xml.XElement = XElement;
  const NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
  function isValidName(name) {
    return NAME_REG_EXP.test(name);
  }
  function isNameEquals(element, name, ignoreCase) {
    const elementName = element.name;
    return elementName === name || ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase();
  }
  function parseXml(data) {
    let rootElement = null;
    const parser = sax2.parser(true, {});
    const elements = [];
    parser.onopentag = (saxElement) => {
      const element = new XElement(saxElement.name);
      element.attributes = saxElement.attributes;
      if (rootElement === null) {
        rootElement = element;
      } else {
        const parent = elements[elements.length - 1];
        if (parent.elements == null) {
          parent.elements = [];
        }
        parent.elements.push(element);
      }
      elements.push(element);
    };
    parser.onclosetag = () => {
      elements.pop();
    };
    parser.ontext = (text) => {
      if (elements.length > 0) {
        elements[elements.length - 1].value = text;
      }
    };
    parser.oncdata = (cdata) => {
      const element = elements[elements.length - 1];
      element.value = cdata;
      element.isCData = true;
    };
    parser.onerror = (err) => {
      throw err;
    };
    parser.write(data);
    return rootElement;
  }
  return xml;
}
var hasRequiredOut;
function requireOut() {
  if (hasRequiredOut) return out;
  hasRequiredOut = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.CURRENT_APP_PACKAGE_FILE_NAME = exports$1.CURRENT_APP_INSTALLER_FILE_NAME = exports$1.XElement = exports$1.parseXml = exports$1.UUID = exports$1.parseDn = exports$1.retry = exports$1.githubTagPrefix = exports$1.githubUrl = exports$1.getS3LikeProviderBaseUrl = exports$1.ProgressCallbackTransform = exports$1.MemoLazy = exports$1.safeStringifyJson = exports$1.safeGetHeader = exports$1.parseJson = exports$1.HttpExecutor = exports$1.HttpError = exports$1.DigestTransform = exports$1.createHttpError = exports$1.configureRequestUrl = exports$1.configureRequestOptionsFromUrl = exports$1.configureRequestOptions = exports$1.newError = exports$1.CancellationToken = exports$1.CancellationError = void 0;
    exports$1.asArray = asArray;
    var CancellationToken_1 = requireCancellationToken();
    Object.defineProperty(exports$1, "CancellationError", { enumerable: true, get: function() {
      return CancellationToken_1.CancellationError;
    } });
    Object.defineProperty(exports$1, "CancellationToken", { enumerable: true, get: function() {
      return CancellationToken_1.CancellationToken;
    } });
    var error_1 = requireError();
    Object.defineProperty(exports$1, "newError", { enumerable: true, get: function() {
      return error_1.newError;
    } });
    var httpExecutor_1 = requireHttpExecutor();
    Object.defineProperty(exports$1, "configureRequestOptions", { enumerable: true, get: function() {
      return httpExecutor_1.configureRequestOptions;
    } });
    Object.defineProperty(exports$1, "configureRequestOptionsFromUrl", { enumerable: true, get: function() {
      return httpExecutor_1.configureRequestOptionsFromUrl;
    } });
    Object.defineProperty(exports$1, "configureRequestUrl", { enumerable: true, get: function() {
      return httpExecutor_1.configureRequestUrl;
    } });
    Object.defineProperty(exports$1, "createHttpError", { enumerable: true, get: function() {
      return httpExecutor_1.createHttpError;
    } });
    Object.defineProperty(exports$1, "DigestTransform", { enumerable: true, get: function() {
      return httpExecutor_1.DigestTransform;
    } });
    Object.defineProperty(exports$1, "HttpError", { enumerable: true, get: function() {
      return httpExecutor_1.HttpError;
    } });
    Object.defineProperty(exports$1, "HttpExecutor", { enumerable: true, get: function() {
      return httpExecutor_1.HttpExecutor;
    } });
    Object.defineProperty(exports$1, "parseJson", { enumerable: true, get: function() {
      return httpExecutor_1.parseJson;
    } });
    Object.defineProperty(exports$1, "safeGetHeader", { enumerable: true, get: function() {
      return httpExecutor_1.safeGetHeader;
    } });
    Object.defineProperty(exports$1, "safeStringifyJson", { enumerable: true, get: function() {
      return httpExecutor_1.safeStringifyJson;
    } });
    var MemoLazy_1 = requireMemoLazy();
    Object.defineProperty(exports$1, "MemoLazy", { enumerable: true, get: function() {
      return MemoLazy_1.MemoLazy;
    } });
    var ProgressCallbackTransform_1 = requireProgressCallbackTransform();
    Object.defineProperty(exports$1, "ProgressCallbackTransform", { enumerable: true, get: function() {
      return ProgressCallbackTransform_1.ProgressCallbackTransform;
    } });
    var publishOptions_1 = requirePublishOptions();
    Object.defineProperty(exports$1, "getS3LikeProviderBaseUrl", { enumerable: true, get: function() {
      return publishOptions_1.getS3LikeProviderBaseUrl;
    } });
    Object.defineProperty(exports$1, "githubUrl", { enumerable: true, get: function() {
      return publishOptions_1.githubUrl;
    } });
    Object.defineProperty(exports$1, "githubTagPrefix", { enumerable: true, get: function() {
      return publishOptions_1.githubTagPrefix;
    } });
    var retry_1 = requireRetry();
    Object.defineProperty(exports$1, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var rfc2253Parser_1 = requireRfc2253Parser();
    Object.defineProperty(exports$1, "parseDn", { enumerable: true, get: function() {
      return rfc2253Parser_1.parseDn;
    } });
    var uuid_1 = requireUuid();
    Object.defineProperty(exports$1, "UUID", { enumerable: true, get: function() {
      return uuid_1.UUID;
    } });
    var xml_1 = requireXml();
    Object.defineProperty(exports$1, "parseXml", { enumerable: true, get: function() {
      return xml_1.parseXml;
    } });
    Object.defineProperty(exports$1, "XElement", { enumerable: true, get: function() {
      return xml_1.XElement;
    } });
    exports$1.CURRENT_APP_INSTALLER_FILE_NAME = "installer.exe";
    exports$1.CURRENT_APP_PACKAGE_FILE_NAME = "package.7z";
    function asArray(v) {
      if (v == null) {
        return [];
      } else if (Array.isArray(v)) {
        return v;
      } else {
        return [v];
      }
    }
  })(out);
  return out;
}
var jsYaml = {};
var loader = {};
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
  }
  function isObject(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];
    return [sequence];
  }
  function extend(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }
    return target;
  }
  function repeat(string2, count) {
    var result = "", cycle;
    for (cycle = 0; cycle < count; cycle += 1) {
      result += string2;
    }
    return result;
  }
  function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
  }
  common.isNothing = isNothing;
  common.isObject = isObject;
  common.toArray = toArray;
  common.repeat = repeat;
  common.isNegativeZero = isNegativeZero;
  common.extend = extend;
  return common;
}
var exception;
var hasRequiredException;
function requireException() {
  if (hasRequiredException) return exception;
  hasRequiredException = 1;
  function formatError(exception2, compact) {
    var where = "", message = exception2.reason || "(unknown reason)";
    if (!exception2.mark) return message;
    if (exception2.mark.name) {
      where += 'in "' + exception2.mark.name + '" ';
    }
    where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
    if (!compact && exception2.mark.snippet) {
      where += "\n\n" + exception2.mark.snippet;
    }
    return message + " " + where;
  }
  function YAMLException(reason, mark) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  }
  YAMLException.prototype = Object.create(Error.prototype);
  YAMLException.prototype.constructor = YAMLException;
  YAMLException.prototype.toString = function toString(compact) {
    return this.name + ": " + formatError(this, compact);
  };
  exception = YAMLException;
  return exception;
}
var snippet;
var hasRequiredSnippet;
function requireSnippet() {
  if (hasRequiredSnippet) return snippet;
  hasRequiredSnippet = 1;
  var common2 = requireCommon();
  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = "";
    var tail = "";
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
    if (position - lineStart > maxHalfLength) {
      head = " ... ";
      lineStart = position - maxHalfLength + head.length;
    }
    if (lineEnd - position > maxHalfLength) {
      tail = " ...";
      lineEnd = position + maxHalfLength - tail.length;
    }
    return {
      str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "") + tail,
      pos: position - lineStart + head.length
      // relative position
    };
  }
  function padStart(string2, max) {
    return common2.repeat(" ", max - string2.length) + string2;
  }
  function makeSnippet(mark, options) {
    options = Object.create(options || null);
    if (!mark.buffer) return null;
    if (!options.maxLength) options.maxLength = 79;
    if (typeof options.indent !== "number") options.indent = 1;
    if (typeof options.linesBefore !== "number") options.linesBefore = 3;
    if (typeof options.linesAfter !== "number") options.linesAfter = 2;
    var re2 = /\r?\n|\r|\0/g;
    var lineStarts = [0];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;
    while (match = re2.exec(mark.buffer)) {
      lineEnds.push(match.index);
      lineStarts.push(match.index + match[0].length);
      if (mark.position <= match.index && foundLineNo < 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }
    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
    var result = "", i, line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
    for (i = 1; i <= options.linesBefore; i++) {
      if (foundLineNo - i < 0) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo - i],
        lineEnds[foundLineNo - i],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
        maxLineLength
      );
      result = common2.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
    }
    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common2.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    result += common2.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
    for (i = 1; i <= options.linesAfter; i++) {
      if (foundLineNo + i >= lineEnds.length) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo + i],
        lineEnds[foundLineNo + i],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
        maxLineLength
      );
      result += common2.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    }
    return result.replace(/\n$/, "");
  }
  snippet = makeSnippet;
  return snippet;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  var YAMLException = requireException();
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map2) {
    var result = {};
    if (map2 !== null) {
      Object.keys(map2).forEach(function(style) {
        map2[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  }
  function Type(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.options = options;
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
      return true;
    };
    this.construct = options["construct"] || function(data) {
      return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.representName = options["representName"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.multi = options["multi"] || false;
    this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }
  type = Type;
  return type;
}
var schema;
var hasRequiredSchema;
function requireSchema() {
  if (hasRequiredSchema) return schema;
  hasRequiredSchema = 1;
  var YAMLException = requireException();
  var Type = requireType();
  function compileList(schema2, name) {
    var result = [];
    schema2[name].forEach(function(currentType) {
      var newIndex = result.length;
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
          newIndex = previousIndex;
        }
      });
      result[newIndex] = currentType;
    });
    return result;
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, index, length;
    function collectType(type2) {
      if (type2.multi) {
        result.multi[type2.kind].push(type2);
        result.multi["fallback"].push(type2);
      } else {
        result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
      }
    }
    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }
  function Schema(definition) {
    return this.extend(definition);
  }
  Schema.prototype.extend = function extend(definition) {
    var implicit = [];
    var explicit = [];
    if (definition instanceof Type) {
      explicit.push(definition);
    } else if (Array.isArray(definition)) {
      explicit = explicit.concat(definition);
    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      if (definition.implicit) implicit = implicit.concat(definition.implicit);
      if (definition.explicit) explicit = explicit.concat(definition.explicit);
    } else {
      throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    }
    implicit.forEach(function(type2) {
      if (!(type2 instanceof Type)) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      if (type2.loadKind && type2.loadKind !== "scalar") {
        throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
      if (type2.multi) {
        throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
      }
    });
    explicit.forEach(function(type2) {
      if (!(type2 instanceof Type)) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
    });
    var result = Object.create(Schema.prototype);
    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);
    result.compiledImplicit = compileList(result, "implicit");
    result.compiledExplicit = compileList(result, "explicit");
    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
    return result;
  };
  schema = Schema;
  return schema;
}
var str;
var hasRequiredStr;
function requireStr() {
  if (hasRequiredStr) return str;
  hasRequiredStr = 1;
  var Type = requireType();
  str = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  });
  return str;
}
var seq;
var hasRequiredSeq;
function requireSeq() {
  if (hasRequiredSeq) return seq;
  hasRequiredSeq = 1;
  var Type = requireType();
  seq = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
  return seq;
}
var map;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map;
  hasRequiredMap = 1;
  var Type = requireType();
  map = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
  return map;
}
var failsafe;
var hasRequiredFailsafe;
function requireFailsafe() {
  if (hasRequiredFailsafe) return failsafe;
  hasRequiredFailsafe = 1;
  var Schema = requireSchema();
  failsafe = new Schema({
    explicit: [
      requireStr(),
      requireSeq(),
      requireMap()
    ]
  });
  return failsafe;
}
var _null;
var hasRequired_null;
function require_null() {
  if (hasRequired_null) return _null;
  hasRequired_null = 1;
  var Type = requireType();
  function resolveYamlNull(data) {
    if (data === null) return true;
    var max = data.length;
    return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  _null = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  });
  return _null;
}
var bool;
var hasRequiredBool;
function requireBool() {
  if (hasRequiredBool) return bool;
  hasRequiredBool = 1;
  var Type = requireType();
  function resolveYamlBoolean(data) {
    if (data === null) return false;
    var max = data.length;
    return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  bool = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
  return bool;
}
var int;
var hasRequiredInt;
function requireInt() {
  if (hasRequiredInt) return int;
  hasRequiredInt = 1;
  var common2 = requireCommon();
  var Type = requireType();
  function isHexCode(c) {
    return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
  }
  function isOctCode(c) {
    return 48 <= c && c <= 55;
  }
  function isDecCode(c) {
    return 48 <= c && c <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null) return false;
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max) return false;
    ch = data[index];
    if (ch === "-" || ch === "+") {
      ch = data[++index];
    }
    if (ch === "0") {
      if (index + 1 === max) return true;
      ch = data[++index];
      if (ch === "b") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (ch !== "0" && ch !== "1") return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (!isHexCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "o") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (!isOctCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
    }
    if (ch === "_") return false;
    for (; index < max; index++) {
      ch = data[index];
      if (ch === "_") continue;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch === "_") return false;
    return true;
  }
  function constructYamlInteger(data) {
    var value = data, sign = 1, ch;
    if (value.indexOf("_") !== -1) {
      value = value.replace(/_/g, "");
    }
    ch = value[0];
    if (ch === "-" || ch === "+") {
      if (ch === "-") sign = -1;
      value = value.slice(1);
      ch = value[0];
    }
    if (value === "0") return 0;
    if (ch === "0") {
      if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
      if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
      if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
    }
    return sign * parseInt(value, 10);
  }
  function isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common2.isNegativeZero(object));
  }
  int = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
  return int;
}
var float;
var hasRequiredFloat;
function requireFloat() {
  if (hasRequiredFloat) return float;
  hasRequiredFloat = 1;
  var common2 = requireCommon();
  var Type = requireType();
  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data) {
    if (data === null) return false;
    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_") {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data) {
    var value, sign;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    if ("+-".indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }
    if (value === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
      return NaN;
    }
    return sign * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common2.isNegativeZero(object)) {
      return "-0.0";
    }
    res = object.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common2.isNegativeZero(object));
  }
  float = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
  return float;
}
var json;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json;
  hasRequiredJson = 1;
  json = requireFailsafe().extend({
    implicit: [
      require_null(),
      requireBool(),
      requireInt(),
      requireFloat()
    ]
  });
  return json;
}
var core;
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core;
  hasRequiredCore = 1;
  core = requireJson();
  return core;
}
var timestamp;
var hasRequiredTimestamp;
function requireTimestamp() {
  if (hasRequiredTimestamp) return timestamp;
  hasRequiredTimestamp = 1;
  var Type = requireType();
  var YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  );
  var YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
  }
  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null) throw new Error("Date resolve error");
    year = +match[1];
    month = +match[2] - 1;
    day = +match[3];
    if (!match[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 6e4;
      if (match[9] === "-") delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) date.setTime(date.getTime() - delta);
    return date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  timestamp = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
  return timestamp;
}
var merge;
var hasRequiredMerge;
function requireMerge() {
  if (hasRequiredMerge) return merge;
  hasRequiredMerge = 1;
  var Type = requireType();
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  merge = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
  return merge;
}
var binary;
var hasRequiredBinary;
function requireBinary() {
  if (hasRequiredBinary) return binary;
  hasRequiredBinary = 1;
  var Type = requireType();
  var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
  function resolveYamlBinary(data) {
    if (data === null) return false;
    var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      code = map2.indexOf(data.charAt(idx));
      if (code > 64) continue;
      if (code < 0) return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      }
      bits = bits << 6 | map2.indexOf(input.charAt(idx));
    }
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 255);
      result.push(bits >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 255);
    }
    return new Uint8Array(result);
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map2[bits >> 18 & 63];
        result += map2[bits >> 12 & 63];
        result += map2[bits >> 6 & 63];
        result += map2[bits & 63];
      }
      bits = (bits << 8) + object[idx];
    }
    tail = max % 3;
    if (tail === 0) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    } else if (tail === 2) {
      result += map2[bits >> 10 & 63];
      result += map2[bits >> 4 & 63];
      result += map2[bits << 2 & 63];
      result += map2[64];
    } else if (tail === 1) {
      result += map2[bits >> 2 & 63];
      result += map2[bits << 4 & 63];
      result += map2[64];
      result += map2[64];
    }
    return result;
  }
  function isBinary(obj) {
    return Object.prototype.toString.call(obj) === "[object Uint8Array]";
  }
  binary = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
  return binary;
}
var omap;
var hasRequiredOmap;
function requireOmap() {
  if (hasRequiredOmap) return omap;
  hasRequiredOmap = 1;
  var Type = requireType();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var _toString = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null) return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;
      if (_toString.call(pair) !== "[object Object]") return false;
      for (pairKey in pair) {
        if (_hasOwnProperty.call(pair, pairKey)) {
          if (!pairHasKey) pairHasKey = true;
          else return false;
        }
      }
      if (!pairHasKey) return false;
      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return false;
    }
    return true;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  omap = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
  return omap;
}
var pairs;
var hasRequiredPairs;
function requirePairs() {
  if (hasRequiredPairs) return pairs;
  hasRequiredPairs = 1;
  var Type = requireType();
  var _toString = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null) return true;
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      if (_toString.call(pair) !== "[object Object]") return false;
      keys = Object.keys(pair);
      if (keys.length !== 1) return false;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return true;
  }
  function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      keys = Object.keys(pair);
      result[index] = [keys[0], pair[keys[0]]];
    }
    return result;
  }
  pairs = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
  return pairs;
}
var set;
var hasRequiredSet;
function requireSet() {
  if (hasRequiredSet) return set;
  hasRequiredSet = 1;
  var Type = requireType();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null) return true;
    var key, object = data;
    for (key in object) {
      if (_hasOwnProperty.call(object, key)) {
        if (object[key] !== null) return false;
      }
    }
    return true;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  set = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
  return set;
}
var _default;
var hasRequired_default;
function require_default() {
  if (hasRequired_default) return _default;
  hasRequired_default = 1;
  _default = requireCore().extend({
    implicit: [
      requireTimestamp(),
      requireMerge()
    ],
    explicit: [
      requireBinary(),
      requireOmap(),
      requirePairs(),
      requireSet()
    ]
  });
  return _default;
}
var hasRequiredLoader;
function requireLoader() {
  if (hasRequiredLoader) return loader;
  hasRequiredLoader = 1;
  var common2 = requireCommon();
  var YAMLException = requireException();
  var makeSnippet = requireSnippet();
  var DEFAULT_SCHEMA = require_default();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c) {
    return c === 10 || c === 13;
  }
  function is_WHITE_SPACE(c) {
    return c === 9 || c === 32;
  }
  function is_WS_OR_EOL(c) {
    return c === 9 || c === 32 || c === 10 || c === 13;
  }
  function is_FLOW_INDICATOR(c) {
    return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
  }
  function fromHexCode(c) {
    var lc;
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    lc = c | 32;
    if (97 <= lc && lc <= 102) {
      return lc - 97 + 10;
    }
    return -1;
  }
  function escapedHexLen(c) {
    if (c === 120) {
      return 2;
    }
    if (c === 117) {
      return 4;
    }
    if (c === 85) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c) {
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    return -1;
  }
  function simpleEscapeSequence(c) {
    return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? "" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c) {
    if (c <= 65535) {
      return String.fromCharCode(c);
    }
    return String.fromCharCode(
      (c - 65536 >> 10) + 55296,
      (c - 65536 & 1023) + 56320
    );
  }
  function setProperty(object, key, value) {
    if (key === "__proto__") {
      Object.defineProperty(object, key, {
        configurable: true,
        enumerable: true,
        writable: true,
        value
      });
    } else {
      object[key] = value;
    }
  }
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (var i = 0; i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }
  function State(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || DEFAULT_SCHEMA;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.firstTabInLine = -1;
    this.documents = [];
  }
  function generateError(state, message) {
    var mark = {
      name: state.filename,
      buffer: state.input.slice(0, -1),
      // omit trailing \0
      position: state.position,
      line: state.line,
      column: state.position - state.lineStart
    };
    mark.snippet = makeSnippet(mark);
    return new YAMLException(message, mark);
  }
  function throwError(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }
  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
      var match, major, minor;
      if (state.version !== null) {
        throwError(state, "duplication of %YAML directive");
      }
      if (args.length !== 1) {
        throwError(state, "YAML directive accepts exactly one argument");
      }
      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match === null) {
        throwError(state, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);
      if (major !== 1) {
        throwError(state, "unacceptable YAML version of the document");
      }
      state.version = args[0];
      state.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state, name, args) {
      var handle, prefix;
      if (args.length !== 2) {
        throwError(state, "TAG directive accepts exactly two arguments");
      }
      handle = args[0];
      prefix = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      try {
        prefix = decodeURIComponent(prefix);
      } catch (err) {
        throwError(state, "tag prefix is malformed: " + prefix);
      }
      state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      _result = state.input.slice(start, end);
      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError(state, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, "the stream contains non-printable characters");
      }
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common2.isObject(source)) {
      throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];
      if (!_hasOwnProperty.call(destination, key)) {
        setProperty(destination, key, source[key]);
        overridableKeys[key] = true;
      }
    }
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
          keyNode[index] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.lineStart = startLineStart || state.lineStart;
        state.position = startPos || state.position;
        throwError(state, "duplicated mapping key");
      }
      setProperty(_result, keyNode, valueNode);
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 10) {
      state.position++;
    } else if (ch === 13) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 10) {
        state.position++;
      }
    } else {
      throwError(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        if (ch === 9 && state.firstTabInLine === -1) {
          state.firstTabInLine = state.position;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      if (allowComments && ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 10 && ch !== 13 && ch !== 0);
      }
      if (is_EOL(ch)) {
        readLineBreak(state);
        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;
        while (ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state.input.charCodeAt(_position);
      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += " ";
    } else if (count > 1) {
      state.result += common2.repeat("\n", count - 1);
    }
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
      return false;
    }
    if (ch === 63 || ch === 45) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (ch !== 0) {
      if (ch === 58) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 35) {
        preceding = state.input.charCodeAt(state.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);
        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
      return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 39) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 39) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (ch === 39) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a single quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 34) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 34) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 92) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);
            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, "expected hexadecimal character");
            }
          }
          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, "unknown escape sequence");
        }
        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a double quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? "mapping" : "sequence";
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, "missed comma between flow collection entries");
      } else if (ch === 44) {
        throwError(state, "expected the node content, but found ','");
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch === 63) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }
      _line = state.line;
      _lineStart = state.lineStart;
      _pos = state.position;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if ((isExplicitPair || state.line === _line) && ch === 58) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }
      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === 44) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }
    throwError(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 124) {
      folding = false;
    } else if (ch === 62) {
      folding = true;
    } else {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
      if (ch === 43 || ch === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch));
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
    }
    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch = state.input.charCodeAt(state.position);
      while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }
      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state.result += "\n";
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          state.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common2.repeat("\n", emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state.result += " ";
          }
        } else {
          state.result += common2.repeat("\n", emptyLines);
        }
      } else {
        state.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;
      while (!is_EOL(ch) && ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, state.position, false);
    }
    return true;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      if (ch !== 45) {
        break;
      }
      following = state.input.charCodeAt(state.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state.position++;
      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a sequence entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "sequence";
      state.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (!atExplicitKey && state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line;
      if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
        if (ch === 63) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state.position += 1;
        ch = following;
      } else {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          break;
        }
        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 58) {
            ch = state.input.charCodeAt(++state.position);
            if (!is_WS_OR_EOL(ch)) {
              throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
            throwError(state, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      }
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
        }
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a mapping entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "mapping";
      state.result = _result;
    }
    return detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 33) return false;
    if (state.tag !== null) {
      throwError(state, "duplication of a tag property");
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 60) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch = state.input.charCodeAt(++state.position);
    } else {
      tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0 && ch !== 62);
      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 33) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, "tag suffix cannot contain exclamation marks");
          }
        }
        ch = state.input.charCodeAt(++state.position);
      }
      tagName = state.input.slice(_position, state.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, "tag name cannot contain such characters: " + tagName);
    }
    try {
      tagName = decodeURIComponent(tagName);
    } catch (err) {
      throwError(state, "tag name is malformed: " + tagName);
    }
    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 38) return false;
    if (state.anchor !== null) {
      throwError(state, "duplication of an anchor property");
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
  }
  function readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 42) return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
    if (state.listener !== null) {
      state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state.position - state.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;
            if (state.tag !== null || state.anchor !== null) {
              throwError(state, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state.tag === null) {
              state.tag = "?";
            }
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }
    if (state.tag === null) {
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    } else if (state.tag === "?") {
      if (state.result !== null && state.kind !== "scalar") {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type2 = state.implicitTypes[typeIndex];
        if (type2.resolve(state.result)) {
          state.result = type2.construct(state.result);
          state.tag = type2.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (state.tag !== "!") {
      if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
        type2 = state.typeMap[state.kind || "fallback"][state.tag];
      } else {
        type2 = null;
        typeList = state.typeMap.multi[state.kind || "fallback"];
        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type2 = typeList[typeIndex];
            break;
          }
        }
      }
      if (!type2) {
        throwError(state, "unknown tag !<" + state.tag + ">");
      }
      if (state.result !== null && type2.kind !== state.kind) {
        throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
      }
      if (!type2.resolve(state.result, state.tag)) {
        throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
      } else {
        state.result = type2.construct(state.result, state.tag);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    }
    if (state.listener !== null) {
      state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = /* @__PURE__ */ Object.create(null);
    state.anchorMap = /* @__PURE__ */ Object.create(null);
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if (state.lineIndent > 0 || ch !== 37) {
        break;
      }
      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError(state, "directive name must not be less than one character in length");
      }
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch)) break;
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      if (ch !== 0) readLineBreak(state);
      if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
      throwError(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 46) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }
    if (state.position < state.length - 1) {
      throwError(state, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  }
  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += "\n";
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state = new State(input, options);
    var nullpos = input.indexOf("\0");
    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, "null byte is not allowed in input");
    }
    state.input += "\0";
    while (state.input.charCodeAt(state.position) === 32) {
      state.lineIndent += 1;
      state.position += 1;
    }
    while (state.position < state.length - 1) {
      readDocument(state);
    }
    return state.documents;
  }
  function loadAll(input, iterator, options) {
    if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
      options = iterator;
      iterator = null;
    }
    var documents = loadDocuments(input, options);
    if (typeof iterator !== "function") {
      return documents;
    }
    for (var index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }
  function load(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
      return void 0;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new YAMLException("expected a single document in the stream, but found more");
  }
  loader.loadAll = loadAll;
  loader.load = load;
  return loader;
}
var dumper = {};
var hasRequiredDumper;
function requireDumper() {
  if (hasRequiredDumper) return dumper;
  hasRequiredDumper = 1;
  var common2 = requireCommon();
  var YAMLException = requireException();
  var DEFAULT_SCHEMA = require_default();
  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_BOM = 65279;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_CARRIAGE_RETURN = 13;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_EQUALS = 61;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = '\\"';
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function compileStyleMap(schema2, map2) {
    var result, keys, index, length, tag, style, type2;
    if (map2 === null) return {};
    result = {};
    keys = Object.keys(map2);
    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style = String(map2[tag]);
      if (tag.slice(0, 2) === "!!") {
        tag = "tag:yaml.org,2002:" + tag.slice(2);
      }
      type2 = schema2.compiledTypeMap["fallback"][tag];
      if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
        style = type2.styleAliases[style];
      }
      result[tag] = style;
    }
    return result;
  }
  function encodeHex(character) {
    var string2, handle, length;
    string2 = character.toString(16).toUpperCase();
    if (character <= 255) {
      handle = "x";
      length = 2;
    } else if (character <= 65535) {
      handle = "u";
      length = 4;
    } else if (character <= 4294967295) {
      handle = "U";
      length = 8;
    } else {
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common2.repeat("0", length - string2.length) + string2;
  }
  var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
  function State(options) {
    this.schema = options["schema"] || DEFAULT_SCHEMA;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = common2.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes = options["forceQuotes"] || false;
    this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString(string2, spaces) {
    var ind = common2.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string2.length;
    while (position < length) {
      next = string2.indexOf("\n", position);
      if (next === -1) {
        line = string2.slice(position);
        position = length;
      } else {
        line = string2.slice(position, next + 1);
        position = next + 1;
      }
      if (line.length && line !== "\n") result += ind;
      result += line;
    }
    return result;
  }
  function generateNextLine(state, level) {
    return "\n" + common2.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index, length, type2;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type2 = state.implicitTypes[index];
      if (type2.resolve(str2)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }
  function isPrintable(c) {
    return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
  }
  function isNsCharOrWhitespace(c) {
    return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
    return (
      // ns-plain-safe
      (inblock ? (
        // c = flow-in
        cIsNsCharOrWhitespace
      ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
    );
  }
  function isPlainSafeFirst(c) {
    return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
  }
  function isPlainSafeLast(c) {
    return !isWhitespace(c) && c !== CHAR_COLON;
  }
  function codePointAt(string2, pos) {
    var first = string2.charCodeAt(pos), second;
    if (first >= 55296 && first <= 56319 && pos + 1 < string2.length) {
      second = string2.charCodeAt(pos + 1);
      if (second >= 56320 && second <= 57343) {
        return (first - 55296) * 1024 + second - 56320 + 65536;
      }
    }
    return first;
  }
  function needIndentIndicator(string2) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string2);
  }
  var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
  function chooseScalarStyle(string2, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(codePointAt(string2, 0)) && isPlainSafeLast(codePointAt(string2, string2.length - 1));
    if (singleLineOnly || forceQuotes) {
      for (i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt(string2, i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
    } else {
      for (i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt(string2, i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
            i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ";
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      if (plain && !forceQuotes && !testAmbiguousType(string2)) {
        return STYLE_PLAIN;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string2)) {
      return STYLE_DOUBLE;
    }
    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  function writeScalar(state, string2, level, iskey, inblock) {
    state.dump = (function() {
      if (string2.length === 0) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      }
      if (!state.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string2) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string2)) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string2 + '"' : "'" + string2 + "'";
        }
      }
      var indent = state.indent * Math.max(1, level);
      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
      var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string3) {
        return testImplicitResolving(state, string3);
      }
      switch (chooseScalarStyle(
        string2,
        singleLineOnly,
        state.indent,
        lineWidth,
        testAmbiguity,
        state.quotingType,
        state.forceQuotes && !iskey,
        inblock
      )) {
        case STYLE_PLAIN:
          return string2;
        case STYLE_SINGLE:
          return "'" + string2.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(string2, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(foldString(string2, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string2) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    })();
  }
  function blockHeader(string2, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string2) ? String(indentPerLevel) : "";
    var clip = string2[string2.length - 1] === "\n";
    var keep = clip && (string2[string2.length - 2] === "\n" || string2 === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
  }
  function dropEndingNewline(string2) {
    return string2[string2.length - 1] === "\n" ? string2.slice(0, -1) : string2;
  }
  function foldString(string2, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = (function() {
      var nextLF = string2.indexOf("\n");
      nextLF = nextLF !== -1 ? nextLF : string2.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string2.slice(0, nextLF), width);
    })();
    var prevMoreIndented = string2[0] === "\n" || string2[0] === " ";
    var moreIndented;
    var match;
    while (match = lineRe.exec(string2)) {
      var prefix = match[1], line = match[2];
      moreIndented = line[0] === " ";
      result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line, width) {
    if (line === "" || line[0] === " ") return line;
    var breakRe = / [^ ]/g;
    var match;
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    while (match = breakRe.exec(line)) {
      next = match.index;
      if (next - start > width) {
        end = curr > start ? curr : next;
        result += "\n" + line.slice(start, end);
        start = end + 1;
      }
      curr = next;
    }
    result += "\n";
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }
    return result.slice(1);
  }
  function escapeString(string2) {
    var result = "";
    var char = 0;
    var escapeSeq;
    for (var i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string2, i);
      escapeSeq = ESCAPE_SEQUENCES[char];
      if (!escapeSeq && isPrintable(char)) {
        result += string2[i];
        if (char >= 65536) result += string2[i + 1];
      } else {
        result += escapeSeq || encodeHex(char);
      }
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];
      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }
      if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
        if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];
      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }
      if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
        if (!compact || _result !== "") {
          _result += generateNextLine(state, level);
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = "";
      if (_result !== "") pairBuffer += ", ";
      if (state.condenseFlow) pairBuffer += '"';
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level, objectKey, false, false)) {
        continue;
      }
      if (state.dump.length > 1024) pairBuffer += "? ";
      pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
      if (!writeNode(state, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      throw new YAMLException("sortKeys must be a boolean or a function");
    }
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = "";
      if (!compact || _result !== "") {
        pairBuffer += generateNextLine(state, level);
      }
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }
      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type2, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index = 0, length = typeList.length; index < length; index += 1) {
      type2 = typeList[index];
      if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
        if (explicit) {
          if (type2.multi && type2.representName) {
            state.tag = type2.representName(object);
          } else {
            state.tag = type2.tag;
          }
        } else {
          state.tag = "?";
        }
        if (type2.represent) {
          style = state.styleMap[type2.tag] || type2.defaultStyle;
          if (_toString.call(type2.represent) === "[object Function]") {
            _result = type2.represent(object, style);
          } else if (_hasOwnProperty.call(type2.represent, style)) {
            _result = type2.represent[style](object, style);
          } else {
            throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }
    var type2 = _toString.call(state.dump);
    var inblock = block;
    var tagStr;
    if (block) {
      block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type2 === "[object Object]") {
        if (block && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object Array]") {
        if (block && state.dump.length !== 0) {
          if (state.noArrayIndent && !isblockseq && level > 0) {
            writeBlockSequence(state, level - 1, state.dump, compact);
          } else {
            writeBlockSequence(state, level, state.dump, compact);
          }
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object String]") {
        if (state.tag !== "?") {
          writeScalar(state, state.dump, level, iskey, inblock);
        }
      } else if (type2 === "[object Undefined]") {
        return false;
      } else {
        if (state.skipInvalid) return false;
        throw new YAMLException("unacceptable kind of an object to dump " + type2);
      }
      if (state.tag !== null && state.tag !== "?") {
        tagStr = encodeURI(
          state.tag[0] === "!" ? state.tag.slice(1) : state.tag
        ).replace(/!/g, "%21");
        if (state.tag[0] === "!") {
          tagStr = "!" + tagStr;
        } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
          tagStr = "!!" + tagStr.slice(18);
        } else {
          tagStr = "!<" + tagStr + ">";
        }
        state.dump = tagStr + " " + state.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object, objects, duplicatesIndexes);
    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object === "object") {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);
        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs) getDuplicateReferences(input, state);
    var value = input;
    if (state.replacer) {
      value = state.replacer.call({ "": value }, "", value);
    }
    if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
    return "";
  }
  dumper.dump = dump;
  return dumper;
}
var hasRequiredJsYaml;
function requireJsYaml() {
  if (hasRequiredJsYaml) return jsYaml;
  hasRequiredJsYaml = 1;
  var loader2 = requireLoader();
  var dumper2 = requireDumper();
  function renamed(from, to) {
    return function() {
      throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
    };
  }
  jsYaml.Type = requireType();
  jsYaml.Schema = requireSchema();
  jsYaml.FAILSAFE_SCHEMA = requireFailsafe();
  jsYaml.JSON_SCHEMA = requireJson();
  jsYaml.CORE_SCHEMA = requireCore();
  jsYaml.DEFAULT_SCHEMA = require_default();
  jsYaml.load = loader2.load;
  jsYaml.loadAll = loader2.loadAll;
  jsYaml.dump = dumper2.dump;
  jsYaml.YAMLException = requireException();
  jsYaml.types = {
    binary: requireBinary(),
    float: requireFloat(),
    map: requireMap(),
    null: require_null(),
    pairs: requirePairs(),
    set: requireSet(),
    timestamp: requireTimestamp(),
    bool: requireBool(),
    int: requireInt(),
    merge: requireMerge(),
    omap: requireOmap(),
    seq: requireSeq(),
    str: requireStr()
  };
  jsYaml.safeLoad = renamed("safeLoad", "load");
  jsYaml.safeLoadAll = renamed("safeLoadAll", "loadAll");
  jsYaml.safeDump = renamed("safeDump", "dump");
  return jsYaml;
}
var main = {};
var hasRequiredMain$1;
function requireMain$1() {
  if (hasRequiredMain$1) return main;
  hasRequiredMain$1 = 1;
  Object.defineProperty(main, "__esModule", { value: true });
  main.Lazy = void 0;
  class Lazy {
    constructor(creator) {
      this._value = null;
      this.creator = creator;
    }
    get hasValue() {
      return this.creator == null;
    }
    get value() {
      if (this.creator == null) {
        return this._value;
      }
      const result = this.creator();
      this.value = result;
      return result;
    }
    set value(value) {
      this._value = value;
      this.creator = null;
    }
  }
  main.Lazy = Lazy;
  return main;
}
var re = { exports: {} };
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  const SEMVER_SPEC_VERSION = "2.0.0";
  const MAX_LENGTH = 256;
  const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991;
  const MAX_SAFE_COMPONENT_LENGTH = 16;
  const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  const RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  constants = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
  return constants;
}
var debug_1;
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug_1;
  hasRequiredDebug = 1;
  const debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  debug_1 = debug;
  return debug_1;
}
var hasRequiredRe;
function requireRe() {
  if (hasRequiredRe) return re.exports;
  hasRequiredRe = 1;
  (function(module, exports$1) {
    const {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = requireConstants();
    const debug = requireDebug();
    exports$1 = module.exports = {};
    const re2 = exports$1.re = [];
    const safeRe = exports$1.safeRe = [];
    const src2 = exports$1.src = [];
    const safeSrc = exports$1.safeSrc = [];
    const t = exports$1.t = {};
    let R = 0;
    const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    const safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    const makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    const createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src2[index] = value;
      safeSrc[index] = safe;
      re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src2[t.NUMERICIDENTIFIER]})\\.(${src2[t.NUMERICIDENTIFIER]})\\.(${src2[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src2[t.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src2[t.NONNUMERICIDENTIFIER]}|${src2[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src2[t.NONNUMERICIDENTIFIER]}|${src2[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src2[t.PRERELEASEIDENTIFIER]}(?:\\.${src2[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src2[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src2[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src2[t.BUILDIDENTIFIER]}(?:\\.${src2[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src2[t.MAINVERSION]}${src2[t.PRERELEASE]}?${src2[t.BUILD]}?`);
    createToken("FULL", `^${src2[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src2[t.MAINVERSIONLOOSE]}${src2[t.PRERELEASELOOSE]}?${src2[t.BUILD]}?`);
    createToken("LOOSE", `^${src2[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src2[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src2[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src2[t.XRANGEIDENTIFIER]})(?:\\.(${src2[t.XRANGEIDENTIFIER]})(?:\\.(${src2[t.XRANGEIDENTIFIER]})(?:${src2[t.PRERELEASE]})?${src2[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src2[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t.XRANGEIDENTIFIERLOOSE]})(?:${src2[t.PRERELEASELOOSE]})?${src2[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src2[t.GTLT]}\\s*${src2[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src2[t.GTLT]}\\s*${src2[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src2[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src2[t.COERCEPLAIN] + `(?:${src2[t.PRERELEASE]})?(?:${src2[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src2[t.COERCE], true);
    createToken("COERCERTLFULL", src2[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src2[t.LONETILDE]}\\s+`, true);
    exports$1.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src2[t.LONETILDE]}${src2[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src2[t.LONETILDE]}${src2[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src2[t.LONECARET]}\\s+`, true);
    exports$1.caretTrimReplace = "$1^";
    createToken("CARET", `^${src2[t.LONECARET]}${src2[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src2[t.LONECARET]}${src2[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src2[t.GTLT]}\\s*(${src2[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src2[t.GTLT]}\\s*(${src2[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src2[t.GTLT]}\\s*(${src2[t.LOOSEPLAIN]}|${src2[t.XRANGEPLAIN]})`, true);
    exports$1.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src2[t.XRANGEPLAIN]})\\s+-\\s+(${src2[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src2[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src2[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(re, re.exports);
  return re.exports;
}
var parseOptions_1;
var hasRequiredParseOptions;
function requireParseOptions() {
  if (hasRequiredParseOptions) return parseOptions_1;
  hasRequiredParseOptions = 1;
  const looseOption = Object.freeze({ loose: true });
  const emptyOpts = Object.freeze({});
  const parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  parseOptions_1 = parseOptions;
  return parseOptions_1;
}
var identifiers;
var hasRequiredIdentifiers;
function requireIdentifiers() {
  if (hasRequiredIdentifiers) return identifiers;
  hasRequiredIdentifiers = 1;
  const numeric = /^[0-9]+$/;
  const compareIdentifiers = (a, b) => {
    if (typeof a === "number" && typeof b === "number") {
      return a === b ? 0 : a < b ? -1 : 1;
    }
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  identifiers = {
    compareIdentifiers,
    rcompareIdentifiers
  };
  return identifiers;
}
var semver$1;
var hasRequiredSemver$1;
function requireSemver$1() {
  if (hasRequiredSemver$1) return semver$1;
  hasRequiredSemver$1 = 1;
  const debug = requireDebug();
  const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants();
  const { safeRe: re2, t } = requireRe();
  const parseOptions = requireParseOptions();
  const { compareIdentifiers } = requireIdentifiers();
  class SemVer {
    constructor(version2, options) {
      options = parseOptions(options);
      if (version2 instanceof SemVer) {
        if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError(
          `version is longer than ${MAX_LENGTH} characters`
        );
      }
      debug("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version2.trim().match(options.loose ? re2[t.LOOSE] : re2[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version2}`);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.major < other.major) {
        return -1;
      }
      if (this.major > other.major) {
        return 1;
      }
      if (this.minor < other.minor) {
        return -1;
      }
      if (this.minor > other.minor) {
        return 1;
      }
      if (this.patch < other.patch) {
        return -1;
      }
      if (this.patch > other.patch) {
        return 1;
      }
      return 0;
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("build compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const match = `-${identifier}`.match(this.options.loose ? re2[t.PRERELEASELOOSE] : re2[t.PRERELEASE]);
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  semver$1 = SemVer;
  return semver$1;
}
var parse_1;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse_1;
  hasRequiredParse = 1;
  const SemVer = requireSemver$1();
  const parse = (version2, options, throwErrors = false) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  parse_1 = parse;
  return parse_1;
}
var valid_1;
var hasRequiredValid$1;
function requireValid$1() {
  if (hasRequiredValid$1) return valid_1;
  hasRequiredValid$1 = 1;
  const parse = requireParse();
  const valid2 = (version2, options) => {
    const v = parse(version2, options);
    return v ? v.version : null;
  };
  valid_1 = valid2;
  return valid_1;
}
var clean_1;
var hasRequiredClean;
function requireClean() {
  if (hasRequiredClean) return clean_1;
  hasRequiredClean = 1;
  const parse = requireParse();
  const clean = (version2, options) => {
    const s = parse(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  clean_1 = clean;
  return clean_1;
}
var inc_1;
var hasRequiredInc;
function requireInc() {
  if (hasRequiredInc) return inc_1;
  hasRequiredInc = 1;
  const SemVer = requireSemver$1();
  const inc = (version2, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = void 0;
    }
    try {
      return new SemVer(
        version2 instanceof SemVer ? version2.version : version2,
        options
      ).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  inc_1 = inc;
  return inc_1;
}
var diff_1;
var hasRequiredDiff;
function requireDiff() {
  if (hasRequiredDiff) return diff_1;
  hasRequiredDiff = 1;
  const parse = requireParse();
  const diff = (version1, version2) => {
    const v1 = parse(version1, null, true);
    const v2 = parse(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (lowVersion.compareMain(highVersion) === 0) {
        if (lowVersion.minor && !lowVersion.patch) {
          return "minor";
        }
        return "patch";
      }
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  diff_1 = diff;
  return diff_1;
}
var major_1;
var hasRequiredMajor;
function requireMajor() {
  if (hasRequiredMajor) return major_1;
  hasRequiredMajor = 1;
  const SemVer = requireSemver$1();
  const major = (a, loose) => new SemVer(a, loose).major;
  major_1 = major;
  return major_1;
}
var minor_1;
var hasRequiredMinor;
function requireMinor() {
  if (hasRequiredMinor) return minor_1;
  hasRequiredMinor = 1;
  const SemVer = requireSemver$1();
  const minor = (a, loose) => new SemVer(a, loose).minor;
  minor_1 = minor;
  return minor_1;
}
var patch_1;
var hasRequiredPatch;
function requirePatch() {
  if (hasRequiredPatch) return patch_1;
  hasRequiredPatch = 1;
  const SemVer = requireSemver$1();
  const patch = (a, loose) => new SemVer(a, loose).patch;
  patch_1 = patch;
  return patch_1;
}
var prerelease_1;
var hasRequiredPrerelease;
function requirePrerelease() {
  if (hasRequiredPrerelease) return prerelease_1;
  hasRequiredPrerelease = 1;
  const parse = requireParse();
  const prerelease = (version2, options) => {
    const parsed = parse(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  prerelease_1 = prerelease;
  return prerelease_1;
}
var compare_1;
var hasRequiredCompare;
function requireCompare() {
  if (hasRequiredCompare) return compare_1;
  hasRequiredCompare = 1;
  const SemVer = requireSemver$1();
  const compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  compare_1 = compare;
  return compare_1;
}
var rcompare_1;
var hasRequiredRcompare;
function requireRcompare() {
  if (hasRequiredRcompare) return rcompare_1;
  hasRequiredRcompare = 1;
  const compare = requireCompare();
  const rcompare = (a, b, loose) => compare(b, a, loose);
  rcompare_1 = rcompare;
  return rcompare_1;
}
var compareLoose_1;
var hasRequiredCompareLoose;
function requireCompareLoose() {
  if (hasRequiredCompareLoose) return compareLoose_1;
  hasRequiredCompareLoose = 1;
  const compare = requireCompare();
  const compareLoose = (a, b) => compare(a, b, true);
  compareLoose_1 = compareLoose;
  return compareLoose_1;
}
var compareBuild_1;
var hasRequiredCompareBuild;
function requireCompareBuild() {
  if (hasRequiredCompareBuild) return compareBuild_1;
  hasRequiredCompareBuild = 1;
  const SemVer = requireSemver$1();
  const compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  compareBuild_1 = compareBuild;
  return compareBuild_1;
}
var sort_1;
var hasRequiredSort;
function requireSort() {
  if (hasRequiredSort) return sort_1;
  hasRequiredSort = 1;
  const compareBuild = requireCompareBuild();
  const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  sort_1 = sort;
  return sort_1;
}
var rsort_1;
var hasRequiredRsort;
function requireRsort() {
  if (hasRequiredRsort) return rsort_1;
  hasRequiredRsort = 1;
  const compareBuild = requireCompareBuild();
  const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  rsort_1 = rsort;
  return rsort_1;
}
var gt_1;
var hasRequiredGt;
function requireGt() {
  if (hasRequiredGt) return gt_1;
  hasRequiredGt = 1;
  const compare = requireCompare();
  const gt = (a, b, loose) => compare(a, b, loose) > 0;
  gt_1 = gt;
  return gt_1;
}
var lt_1;
var hasRequiredLt;
function requireLt() {
  if (hasRequiredLt) return lt_1;
  hasRequiredLt = 1;
  const compare = requireCompare();
  const lt = (a, b, loose) => compare(a, b, loose) < 0;
  lt_1 = lt;
  return lt_1;
}
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq_1;
  hasRequiredEq = 1;
  const compare = requireCompare();
  const eq = (a, b, loose) => compare(a, b, loose) === 0;
  eq_1 = eq;
  return eq_1;
}
var neq_1;
var hasRequiredNeq;
function requireNeq() {
  if (hasRequiredNeq) return neq_1;
  hasRequiredNeq = 1;
  const compare = requireCompare();
  const neq = (a, b, loose) => compare(a, b, loose) !== 0;
  neq_1 = neq;
  return neq_1;
}
var gte_1;
var hasRequiredGte;
function requireGte() {
  if (hasRequiredGte) return gte_1;
  hasRequiredGte = 1;
  const compare = requireCompare();
  const gte = (a, b, loose) => compare(a, b, loose) >= 0;
  gte_1 = gte;
  return gte_1;
}
var lte_1;
var hasRequiredLte;
function requireLte() {
  if (hasRequiredLte) return lte_1;
  hasRequiredLte = 1;
  const compare = requireCompare();
  const lte = (a, b, loose) => compare(a, b, loose) <= 0;
  lte_1 = lte;
  return lte_1;
}
var cmp_1;
var hasRequiredCmp;
function requireCmp() {
  if (hasRequiredCmp) return cmp_1;
  hasRequiredCmp = 1;
  const eq = requireEq();
  const neq = requireNeq();
  const gt = requireGt();
  const gte = requireGte();
  const lt = requireLt();
  const lte = requireLte();
  const cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  cmp_1 = cmp;
  return cmp_1;
}
var coerce_1;
var hasRequiredCoerce;
function requireCoerce() {
  if (hasRequiredCoerce) return coerce_1;
  hasRequiredCoerce = 1;
  const SemVer = requireSemver$1();
  const parse = requireParse();
  const { safeRe: re2, t } = requireRe();
  const coerce = (version2, options) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 === "number") {
      version2 = String(version2);
    }
    if (typeof version2 !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version2.match(options.includePrerelease ? re2[t.COERCEFULL] : re2[t.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re2[t.COERCERTLFULL] : re2[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  coerce_1 = coerce;
  return coerce_1;
}
var lrucache;
var hasRequiredLrucache;
function requireLrucache() {
  if (hasRequiredLrucache) return lrucache;
  hasRequiredLrucache = 1;
  class LRUCache {
    constructor() {
      this.max = 1e3;
      this.map = /* @__PURE__ */ new Map();
    }
    get(key) {
      const value = this.map.get(key);
      if (value === void 0) {
        return void 0;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== void 0) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  lrucache = LRUCache;
  return lrucache;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range {
    constructor(range2, options) {
      options = parseOptions(options);
      if (range2 instanceof Range) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t.HYPHENRANGELOOSE] : re2[t.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range2);
      range2 = range2.replace(re2[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range2);
      range2 = range2.replace(re2[t.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range2);
      range2 = range2.replace(re2[t.CARETTRIM], caretTrimReplace);
      debug("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range;
  const LRU = requireLrucache();
  const cache = new LRU();
  const parseOptions = requireParseOptions();
  const Comparator = requireComparator();
  const debug = requireDebug();
  const SemVer = requireSemver$1();
  const {
    safeRe: re2,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = requireRe();
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants();
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    comp = comp.replace(re2[t.BUILD], "");
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  const isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t.TILDELOOSE] : re2[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re2[t.CARETLOOSE] : re2[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t.XRANGELOOSE] : re2[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re2[t.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set2, version2, options) => {
    for (let i = 0; i < set2.length; i++) {
      if (!set2[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set2.length; i++) {
        debug(set2[i].semver);
        if (set2[i].semver === Comparator.ANY) {
          continue;
        }
        if (set2[i].semver.prerelease.length > 0) {
          const allowed = set2[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY = /* @__PURE__ */ Symbol("SemVer ANY");
  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator;
  const parseOptions = requireParseOptions();
  const { safeRe: re2, t } = requireRe();
  const cmp = requireCmp();
  const debug = requireDebug();
  const SemVer = requireSemver$1();
  const Range = requireRange();
  return comparator;
}
var satisfies_1;
var hasRequiredSatisfies;
function requireSatisfies() {
  if (hasRequiredSatisfies) return satisfies_1;
  hasRequiredSatisfies = 1;
  const Range = requireRange();
  const satisfies = (version2, range2, options) => {
    try {
      range2 = new Range(range2, options);
    } catch (er) {
      return false;
    }
    return range2.test(version2);
  };
  satisfies_1 = satisfies;
  return satisfies_1;
}
var toComparators_1;
var hasRequiredToComparators;
function requireToComparators() {
  if (hasRequiredToComparators) return toComparators_1;
  hasRequiredToComparators = 1;
  const Range = requireRange();
  const toComparators = (range2, options) => new Range(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  toComparators_1 = toComparators;
  return toComparators_1;
}
var maxSatisfying_1;
var hasRequiredMaxSatisfying;
function requireMaxSatisfying() {
  if (hasRequiredMaxSatisfying) return maxSatisfying_1;
  hasRequiredMaxSatisfying = 1;
  const SemVer = requireSemver$1();
  const Range = requireRange();
  const maxSatisfying = (versions, range2, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  maxSatisfying_1 = maxSatisfying;
  return maxSatisfying_1;
}
var minSatisfying_1;
var hasRequiredMinSatisfying;
function requireMinSatisfying() {
  if (hasRequiredMinSatisfying) return minSatisfying_1;
  hasRequiredMinSatisfying = 1;
  const SemVer = requireSemver$1();
  const Range = requireRange();
  const minSatisfying = (versions, range2, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  minSatisfying_1 = minSatisfying;
  return minSatisfying_1;
}
var minVersion_1;
var hasRequiredMinVersion;
function requireMinVersion() {
  if (hasRequiredMinVersion) return minVersion_1;
  hasRequiredMinVersion = 1;
  const SemVer = requireSemver$1();
  const Range = requireRange();
  const gt = requireGt();
  const minVersion = (range2, loose) => {
    range2 = new Range(range2, loose);
    let minver = new SemVer("0.0.0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0; i < range2.set.length; ++i) {
      const comparators = range2.set[i];
      let setMin = null;
      comparators.forEach((comparator2) => {
        const compver = new SemVer(comparator2.semver.version);
        switch (comparator2.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          /* fallthrough */
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${comparator2.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range2.test(minver)) {
      return minver;
    }
    return null;
  };
  minVersion_1 = minVersion;
  return minVersion_1;
}
var valid;
var hasRequiredValid;
function requireValid() {
  if (hasRequiredValid) return valid;
  hasRequiredValid = 1;
  const Range = requireRange();
  const validRange = (range2, options) => {
    try {
      return new Range(range2, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  valid = validRange;
  return valid;
}
var outside_1;
var hasRequiredOutside;
function requireOutside() {
  if (hasRequiredOutside) return outside_1;
  hasRequiredOutside = 1;
  const SemVer = requireSemver$1();
  const Comparator = requireComparator();
  const { ANY } = Comparator;
  const Range = requireRange();
  const satisfies = requireSatisfies();
  const gt = requireGt();
  const lt = requireLt();
  const lte = requireLte();
  const gte = requireGte();
  const outside = (version2, range2, hilo, options) => {
    version2 = new SemVer(version2, options);
    range2 = new Range(range2, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range2, options)) {
      return false;
    }
    for (let i = 0; i < range2.set.length; ++i) {
      const comparators = range2.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator2) => {
        if (comparator2.semver === ANY) {
          comparator2 = new Comparator(">=0.0.0");
        }
        high = high || comparator2;
        low = low || comparator2;
        if (gtfn(comparator2.semver, high.semver, options)) {
          high = comparator2;
        } else if (ltfn(comparator2.semver, low.semver, options)) {
          low = comparator2;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  };
  outside_1 = outside;
  return outside_1;
}
var gtr_1;
var hasRequiredGtr;
function requireGtr() {
  if (hasRequiredGtr) return gtr_1;
  hasRequiredGtr = 1;
  const outside = requireOutside();
  const gtr = (version2, range2, options) => outside(version2, range2, ">", options);
  gtr_1 = gtr;
  return gtr_1;
}
var ltr_1;
var hasRequiredLtr;
function requireLtr() {
  if (hasRequiredLtr) return ltr_1;
  hasRequiredLtr = 1;
  const outside = requireOutside();
  const ltr = (version2, range2, options) => outside(version2, range2, "<", options);
  ltr_1 = ltr;
  return ltr_1;
}
var intersects_1;
var hasRequiredIntersects;
function requireIntersects() {
  if (hasRequiredIntersects) return intersects_1;
  hasRequiredIntersects = 1;
  const Range = requireRange();
  const intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  intersects_1 = intersects;
  return intersects_1;
}
var simplify;
var hasRequiredSimplify;
function requireSimplify() {
  if (hasRequiredSimplify) return simplify;
  hasRequiredSimplify = 1;
  const satisfies = requireSatisfies();
  const compare = requireCompare();
  simplify = (versions, range2, options) => {
    const set2 = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version2 of v) {
      const included = satisfies(version2, range2, options);
      if (included) {
        prev = version2;
        if (!first) {
          first = version2;
        }
      } else {
        if (prev) {
          set2.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set2.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set2) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range2.raw === "string" ? range2.raw : String(range2);
    return simplified.length < original.length ? simplified : range2;
  };
  return simplify;
}
var subset_1;
var hasRequiredSubset;
function requireSubset() {
  if (hasRequiredSubset) return subset_1;
  hasRequiredSubset = 1;
  const Range = requireRange();
  const Comparator = requireComparator();
  const { ANY } = Comparator;
  const satisfies = requireSatisfies();
  const compare = requireCompare();
  const subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER: for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) {
          continue OUTER;
        }
      }
      if (sawNonNull) {
        return false;
      }
    }
    return true;
  };
  const minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  const minimumVersion = [new Comparator(">=0.0.0")];
  const simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = /* @__PURE__ */ new Set();
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  const higherGT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  const lowerLT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  subset_1 = subset;
  return subset_1;
}
var semver;
var hasRequiredSemver;
function requireSemver() {
  if (hasRequiredSemver) return semver;
  hasRequiredSemver = 1;
  const internalRe = requireRe();
  const constants2 = requireConstants();
  const SemVer = requireSemver$1();
  const identifiers2 = requireIdentifiers();
  const parse = requireParse();
  const valid2 = requireValid$1();
  const clean = requireClean();
  const inc = requireInc();
  const diff = requireDiff();
  const major = requireMajor();
  const minor = requireMinor();
  const patch = requirePatch();
  const prerelease = requirePrerelease();
  const compare = requireCompare();
  const rcompare = requireRcompare();
  const compareLoose = requireCompareLoose();
  const compareBuild = requireCompareBuild();
  const sort = requireSort();
  const rsort = requireRsort();
  const gt = requireGt();
  const lt = requireLt();
  const eq = requireEq();
  const neq = requireNeq();
  const gte = requireGte();
  const lte = requireLte();
  const cmp = requireCmp();
  const coerce = requireCoerce();
  const Comparator = requireComparator();
  const Range = requireRange();
  const satisfies = requireSatisfies();
  const toComparators = requireToComparators();
  const maxSatisfying = requireMaxSatisfying();
  const minSatisfying = requireMinSatisfying();
  const minVersion = requireMinVersion();
  const validRange = requireValid();
  const outside = requireOutside();
  const gtr = requireGtr();
  const ltr = requireLtr();
  const intersects = requireIntersects();
  const simplifyRange = requireSimplify();
  const subset = requireSubset();
  semver = {
    parse,
    valid: valid2,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants2.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants2.RELEASE_TYPES,
    compareIdentifiers: identifiers2.compareIdentifiers,
    rcompareIdentifiers: identifiers2.rcompareIdentifiers
  };
  return semver;
}
var DownloadedUpdateHelper = {};
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
var hasRequiredLodash_isequal;
function requireLodash_isequal() {
  if (hasRequiredLodash_isequal) return lodash_isequal.exports;
  hasRequiredLodash_isequal = 1;
  (function(module, exports$1) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports$1 && !exports$1.nodeType && exports$1;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = (function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    })();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    })();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs2 = data.__data__;
        if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
          pairs2.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs2);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if (hasOwnProperty.call(value, key) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
      return arguments;
    })()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  })(lodash_isequal, lodash_isequal.exports);
  return lodash_isequal.exports;
}
var hasRequiredDownloadedUpdateHelper;
function requireDownloadedUpdateHelper() {
  if (hasRequiredDownloadedUpdateHelper) return DownloadedUpdateHelper;
  hasRequiredDownloadedUpdateHelper = 1;
  Object.defineProperty(DownloadedUpdateHelper, "__esModule", { value: true });
  DownloadedUpdateHelper.DownloadedUpdateHelper = void 0;
  DownloadedUpdateHelper.createTempUpdateFile = createTempUpdateFile;
  const crypto_1 = require$$0$4;
  const fs_1 = require$$1$2;
  const isEqual = requireLodash_isequal();
  const fs_extra_1 = /* @__PURE__ */ requireLib$3();
  const path = require$$1$3;
  let DownloadedUpdateHelper$1 = class DownloadedUpdateHelper {
    constructor(cacheDir) {
      this.cacheDir = cacheDir;
      this._file = null;
      this._packageFile = null;
      this.versionInfo = null;
      this.fileInfo = null;
      this._downloadedFileInfo = null;
    }
    get downloadedFileInfo() {
      return this._downloadedFileInfo;
    }
    get file() {
      return this._file;
    }
    get packageFile() {
      return this._packageFile;
    }
    get cacheDirForPendingUpdate() {
      return path.join(this.cacheDir, "pending");
    }
    async validateDownloadedPath(updateFile, updateInfo, fileInfo, logger) {
      if (this.versionInfo != null && this.file === updateFile && this.fileInfo != null) {
        if (isEqual(this.versionInfo, updateInfo) && isEqual(this.fileInfo.info, fileInfo.info) && await (0, fs_extra_1.pathExists)(updateFile)) {
          return updateFile;
        } else {
          return null;
        }
      }
      const cachedUpdateFile = await this.getValidCachedUpdateFile(fileInfo, logger);
      if (cachedUpdateFile === null) {
        return null;
      }
      logger.info(`Update has already been downloaded to ${updateFile}).`);
      this._file = cachedUpdateFile;
      return cachedUpdateFile;
    }
    async setDownloadedFile(downloadedFile, packageFile, versionInfo, fileInfo, updateFileName, isSaveCache) {
      this._file = downloadedFile;
      this._packageFile = packageFile;
      this.versionInfo = versionInfo;
      this.fileInfo = fileInfo;
      this._downloadedFileInfo = {
        fileName: updateFileName,
        sha512: fileInfo.info.sha512,
        isAdminRightsRequired: fileInfo.info.isAdminRightsRequired === true
      };
      if (isSaveCache) {
        await (0, fs_extra_1.outputJson)(this.getUpdateInfoFile(), this._downloadedFileInfo);
      }
    }
    async clear() {
      this._file = null;
      this._packageFile = null;
      this.versionInfo = null;
      this.fileInfo = null;
      await this.cleanCacheDirForPendingUpdate();
    }
    async cleanCacheDirForPendingUpdate() {
      try {
        await (0, fs_extra_1.emptyDir)(this.cacheDirForPendingUpdate);
      } catch (_ignore) {
      }
    }
    /**
     * Returns "update-info.json" which is created in the update cache directory's "pending" subfolder after the first update is downloaded.  If the update file does not exist then the cache is cleared and recreated.  If the update file exists then its properties are validated.
     * @param fileInfo
     * @param logger
     */
    async getValidCachedUpdateFile(fileInfo, logger) {
      const updateInfoFilePath = this.getUpdateInfoFile();
      const doesUpdateInfoFileExist = await (0, fs_extra_1.pathExists)(updateInfoFilePath);
      if (!doesUpdateInfoFileExist) {
        return null;
      }
      let cachedInfo;
      try {
        cachedInfo = await (0, fs_extra_1.readJson)(updateInfoFilePath);
      } catch (error2) {
        let message = `No cached update info available`;
        if (error2.code !== "ENOENT") {
          await this.cleanCacheDirForPendingUpdate();
          message += ` (error on read: ${error2.message})`;
        }
        logger.info(message);
        return null;
      }
      const isCachedInfoFileNameValid = (cachedInfo === null || cachedInfo === void 0 ? void 0 : cachedInfo.fileName) !== null;
      if (!isCachedInfoFileNameValid) {
        logger.warn(`Cached update info is corrupted: no fileName, directory for cached update will be cleaned`);
        await this.cleanCacheDirForPendingUpdate();
        return null;
      }
      if (fileInfo.info.sha512 !== cachedInfo.sha512) {
        logger.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${cachedInfo.sha512}, expected: ${fileInfo.info.sha512}. Directory for cached update will be cleaned`);
        await this.cleanCacheDirForPendingUpdate();
        return null;
      }
      const updateFile = path.join(this.cacheDirForPendingUpdate, cachedInfo.fileName);
      if (!await (0, fs_extra_1.pathExists)(updateFile)) {
        logger.info("Cached update file doesn't exist");
        return null;
      }
      const sha512 = await hashFile(updateFile);
      if (fileInfo.info.sha512 !== sha512) {
        logger.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${sha512}, expected: ${fileInfo.info.sha512}`);
        await this.cleanCacheDirForPendingUpdate();
        return null;
      }
      this._downloadedFileInfo = cachedInfo;
      return updateFile;
    }
    getUpdateInfoFile() {
      return path.join(this.cacheDirForPendingUpdate, "update-info.json");
    }
  };
  DownloadedUpdateHelper.DownloadedUpdateHelper = DownloadedUpdateHelper$1;
  function hashFile(file2, algorithm = "sha512", encoding = "base64", options) {
    return new Promise((resolve, reject) => {
      const hash = (0, crypto_1.createHash)(algorithm);
      hash.on("error", reject).setEncoding(encoding);
      (0, fs_1.createReadStream)(file2, {
        ...options,
        highWaterMark: 1024 * 1024
        /* better to use more memory but hash faster */
      }).on("error", reject).on("end", () => {
        hash.end();
        resolve(hash.read());
      }).pipe(hash, { end: false });
    });
  }
  async function createTempUpdateFile(name, cacheDir, log) {
    let nameCounter = 0;
    let result = path.join(cacheDir, name);
    for (let i = 0; i < 3; i++) {
      try {
        await (0, fs_extra_1.unlink)(result);
        return result;
      } catch (e) {
        if (e.code === "ENOENT") {
          return result;
        }
        log.warn(`Error on remove temp update file: ${e}`);
        result = path.join(cacheDir, `${nameCounter++}-${name}`);
      }
    }
    return result;
  }
  return DownloadedUpdateHelper;
}
var ElectronAppAdapter = {};
var AppAdapter = {};
var hasRequiredAppAdapter;
function requireAppAdapter() {
  if (hasRequiredAppAdapter) return AppAdapter;
  hasRequiredAppAdapter = 1;
  Object.defineProperty(AppAdapter, "__esModule", { value: true });
  AppAdapter.getAppCacheDir = getAppCacheDir;
  const path = require$$1$3;
  const os_1 = require$$2$1;
  function getAppCacheDir() {
    const homedir = (0, os_1.homedir)();
    let result;
    if (process.platform === "win32") {
      result = process.env["LOCALAPPDATA"] || path.join(homedir, "AppData", "Local");
    } else if (process.platform === "darwin") {
      result = path.join(homedir, "Library", "Caches");
    } else {
      result = process.env["XDG_CACHE_HOME"] || path.join(homedir, ".cache");
    }
    return result;
  }
  return AppAdapter;
}
var hasRequiredElectronAppAdapter;
function requireElectronAppAdapter() {
  if (hasRequiredElectronAppAdapter) return ElectronAppAdapter;
  hasRequiredElectronAppAdapter = 1;
  Object.defineProperty(ElectronAppAdapter, "__esModule", { value: true });
  ElectronAppAdapter.ElectronAppAdapter = void 0;
  const path = require$$1$3;
  const AppAdapter_1 = requireAppAdapter();
  let ElectronAppAdapter$1 = class ElectronAppAdapter {
    constructor(app = require$$1$5.app) {
      this.app = app;
    }
    whenReady() {
      return this.app.whenReady();
    }
    get version() {
      return this.app.getVersion();
    }
    get name() {
      return this.app.getName();
    }
    get isPackaged() {
      return this.app.isPackaged === true;
    }
    get appUpdateConfigPath() {
      return this.isPackaged ? path.join(process.resourcesPath, "app-update.yml") : path.join(this.app.getAppPath(), "dev-app-update.yml");
    }
    get userDataPath() {
      return this.app.getPath("userData");
    }
    get baseCachePath() {
      return (0, AppAdapter_1.getAppCacheDir)();
    }
    quit() {
      this.app.quit();
    }
    relaunch() {
      this.app.relaunch();
    }
    onQuit(handler) {
      this.app.once("quit", (_, exitCode) => handler(exitCode));
    }
  };
  ElectronAppAdapter.ElectronAppAdapter = ElectronAppAdapter$1;
  return ElectronAppAdapter;
}
var electronHttpExecutor = {};
var hasRequiredElectronHttpExecutor;
function requireElectronHttpExecutor() {
  if (hasRequiredElectronHttpExecutor) return electronHttpExecutor;
  hasRequiredElectronHttpExecutor = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ElectronHttpExecutor = exports$1.NET_SESSION_NAME = void 0;
    exports$1.getNetSession = getNetSession;
    const builder_util_runtime_1 = requireOut();
    exports$1.NET_SESSION_NAME = "electron-updater";
    function getNetSession() {
      return require$$1$5.session.fromPartition(exports$1.NET_SESSION_NAME, {
        cache: false
      });
    }
    class ElectronHttpExecutor extends builder_util_runtime_1.HttpExecutor {
      constructor(proxyLoginCallback) {
        super();
        this.proxyLoginCallback = proxyLoginCallback;
        this.cachedSession = null;
      }
      async download(url, destination, options) {
        return await options.cancellationToken.createPromise((resolve, reject, onCancel) => {
          const requestOptions = {
            headers: options.headers || void 0,
            redirect: "manual"
          };
          (0, builder_util_runtime_1.configureRequestUrl)(url, requestOptions);
          (0, builder_util_runtime_1.configureRequestOptions)(requestOptions);
          this.doDownload(requestOptions, {
            destination,
            options,
            onCancel,
            callback: (error2) => {
              if (error2 == null) {
                resolve(destination);
              } else {
                reject(error2);
              }
            },
            responseHandler: null
          }, 0);
        });
      }
      createRequest(options, callback) {
        if (options.headers && options.headers.Host) {
          options.host = options.headers.Host;
          delete options.headers.Host;
        }
        if (this.cachedSession == null) {
          this.cachedSession = getNetSession();
        }
        const request = require$$1$5.net.request({
          ...options,
          session: this.cachedSession
        });
        request.on("response", callback);
        if (this.proxyLoginCallback != null) {
          request.on("login", this.proxyLoginCallback);
        }
        return request;
      }
      addRedirectHandlers(request, options, reject, redirectCount, handler) {
        request.on("redirect", (statusCode, method, redirectUrl) => {
          request.abort();
          if (redirectCount > this.maxRedirects) {
            reject(this.createMaxRedirectError());
          } else {
            handler(builder_util_runtime_1.HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options));
          }
        });
      }
    }
    exports$1.ElectronHttpExecutor = ElectronHttpExecutor;
  })(electronHttpExecutor);
  return electronHttpExecutor;
}
var GenericProvider = {};
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  Object.defineProperty(util, "__esModule", { value: true });
  util.newBaseUrl = newBaseUrl;
  util.newUrlFromBase = newUrlFromBase;
  util.getChannelFilename = getChannelFilename;
  const url_1 = require$$2$2;
  function newBaseUrl(url) {
    const result = new url_1.URL(url);
    if (!result.pathname.endsWith("/")) {
      result.pathname += "/";
    }
    return result;
  }
  function newUrlFromBase(pathname, baseUrl, addRandomQueryToAvoidCaching = false) {
    const result = new url_1.URL(pathname, baseUrl);
    const search = baseUrl.search;
    if (search != null && search.length !== 0) {
      result.search = search;
    } else if (addRandomQueryToAvoidCaching) {
      result.search = `noCache=${Date.now().toString(32)}`;
    }
    return result;
  }
  function getChannelFilename(channel) {
    return `${channel}.yml`;
  }
  return util;
}
var Provider = {};
var lodash_escaperegexp;
var hasRequiredLodash_escaperegexp;
function requireLodash_escaperegexp() {
  if (hasRequiredLodash_escaperegexp) return lodash_escaperegexp;
  hasRequiredLodash_escaperegexp = 1;
  var symbolTag = "[object Symbol]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function escapeRegExp(string2) {
    string2 = toString(string2);
    return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
  }
  lodash_escaperegexp = escapeRegExp;
  return lodash_escaperegexp;
}
var hasRequiredProvider;
function requireProvider() {
  if (hasRequiredProvider) return Provider;
  hasRequiredProvider = 1;
  Object.defineProperty(Provider, "__esModule", { value: true });
  Provider.Provider = void 0;
  Provider.findFile = findFile;
  Provider.parseUpdateInfo = parseUpdateInfo;
  Provider.getFileList = getFileList;
  Provider.resolveFiles = resolveFiles;
  const builder_util_runtime_1 = requireOut();
  const js_yaml_1 = requireJsYaml();
  const url_1 = require$$2$2;
  const util_1 = requireUtil();
  const escapeRegExp = requireLodash_escaperegexp();
  let Provider$1 = class Provider {
    constructor(runtimeOptions) {
      this.runtimeOptions = runtimeOptions;
      this.requestHeaders = null;
      this.executor = runtimeOptions.executor;
    }
    // By default, the blockmap file is in the same directory as the main file
    // But some providers may have a different blockmap file, so we need to override this method
    getBlockMapFiles(baseUrl, oldVersion, newVersion, oldBlockMapFileBaseUrl = null) {
      const newBlockMapUrl = (0, util_1.newUrlFromBase)(`${baseUrl.pathname}.blockmap`, baseUrl);
      const oldBlockMapUrl = (0, util_1.newUrlFromBase)(`${baseUrl.pathname.replace(new RegExp(escapeRegExp(newVersion), "g"), oldVersion)}.blockmap`, oldBlockMapFileBaseUrl ? new url_1.URL(oldBlockMapFileBaseUrl) : baseUrl);
      return [oldBlockMapUrl, newBlockMapUrl];
    }
    get isUseMultipleRangeRequest() {
      return this.runtimeOptions.isUseMultipleRangeRequest !== false;
    }
    getChannelFilePrefix() {
      if (this.runtimeOptions.platform === "linux") {
        const arch = process.env["TEST_UPDATER_ARCH"] || process.arch;
        const archSuffix = arch === "x64" ? "" : `-${arch}`;
        return "-linux" + archSuffix;
      } else {
        return this.runtimeOptions.platform === "darwin" ? "-mac" : "";
      }
    }
    // due to historical reasons for windows we use channel name without platform specifier
    getDefaultChannelName() {
      return this.getCustomChannelName("latest");
    }
    getCustomChannelName(channel) {
      return `${channel}${this.getChannelFilePrefix()}`;
    }
    get fileExtraDownloadHeaders() {
      return null;
    }
    setRequestHeaders(value) {
      this.requestHeaders = value;
    }
    /**
     * Method to perform API request only to resolve update info, but not to download update.
     */
    httpRequest(url, headers, cancellationToken) {
      return this.executor.request(this.createRequestOptions(url, headers), cancellationToken);
    }
    createRequestOptions(url, headers) {
      const result = {};
      if (this.requestHeaders == null) {
        if (headers != null) {
          result.headers = headers;
        }
      } else {
        result.headers = headers == null ? this.requestHeaders : { ...this.requestHeaders, ...headers };
      }
      (0, builder_util_runtime_1.configureRequestUrl)(url, result);
      return result;
    }
  };
  Provider.Provider = Provider$1;
  function findFile(files, extension, not) {
    var _a;
    if (files.length === 0) {
      throw (0, builder_util_runtime_1.newError)("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
    }
    const filteredFiles = files.filter((it) => it.url.pathname.toLowerCase().endsWith(`.${extension.toLowerCase()}`));
    const result = (_a = filteredFiles.find((it) => [it.url.pathname, it.info.url].some((n) => n.includes(process.arch)))) !== null && _a !== void 0 ? _a : filteredFiles.shift();
    if (result) {
      return result;
    } else if (not == null) {
      return files[0];
    } else {
      return files.find((fileInfo) => !not.some((ext) => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext.toLowerCase()}`)));
    }
  }
  function parseUpdateInfo(rawData, channelFile, channelFileUrl) {
    if (rawData == null) {
      throw (0, builder_util_runtime_1.newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
    }
    let result;
    try {
      result = (0, js_yaml_1.load)(rawData);
    } catch (e) {
      throw (0, builder_util_runtime_1.newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
    }
    return result;
  }
  function getFileList(updateInfo) {
    const files = updateInfo.files;
    if (files != null && files.length > 0) {
      return files;
    }
    if (updateInfo.path != null) {
      return [
        {
          url: updateInfo.path,
          sha2: updateInfo.sha2,
          sha512: updateInfo.sha512
        }
      ];
    } else {
      throw (0, builder_util_runtime_1.newError)(`No files provided: ${(0, builder_util_runtime_1.safeStringifyJson)(updateInfo)}`, "ERR_UPDATER_NO_FILES_PROVIDED");
    }
  }
  function resolveFiles(updateInfo, baseUrl, pathTransformer = (p) => p) {
    const files = getFileList(updateInfo);
    const result = files.map((fileInfo) => {
      if (fileInfo.sha2 == null && fileInfo.sha512 == null) {
        throw (0, builder_util_runtime_1.newError)(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, builder_util_runtime_1.safeStringifyJson)(fileInfo)}`, "ERR_UPDATER_NO_CHECKSUM");
      }
      return {
        url: (0, util_1.newUrlFromBase)(pathTransformer(fileInfo.url), baseUrl),
        info: fileInfo
      };
    });
    const packages = updateInfo.packages;
    const packageInfo = packages == null ? null : packages[process.arch] || packages.ia32;
    if (packageInfo != null) {
      result[0].packageInfo = {
        ...packageInfo,
        path: (0, util_1.newUrlFromBase)(pathTransformer(packageInfo.path), baseUrl).href
      };
    }
    return result;
  }
  return Provider;
}
var hasRequiredGenericProvider;
function requireGenericProvider() {
  if (hasRequiredGenericProvider) return GenericProvider;
  hasRequiredGenericProvider = 1;
  Object.defineProperty(GenericProvider, "__esModule", { value: true });
  GenericProvider.GenericProvider = void 0;
  const builder_util_runtime_1 = requireOut();
  const util_1 = requireUtil();
  const Provider_1 = requireProvider();
  let GenericProvider$1 = class GenericProvider extends Provider_1.Provider {
    constructor(configuration, updater, runtimeOptions) {
      super(runtimeOptions);
      this.configuration = configuration;
      this.updater = updater;
      this.baseUrl = (0, util_1.newBaseUrl)(this.configuration.url);
    }
    get channel() {
      const result = this.updater.channel || this.configuration.channel;
      return result == null ? this.getDefaultChannelName() : this.getCustomChannelName(result);
    }
    async getLatestVersion() {
      const channelFile = (0, util_1.getChannelFilename)(this.channel);
      const channelUrl = (0, util_1.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
      for (let attemptNumber = 0; ; attemptNumber++) {
        try {
          return (0, Provider_1.parseUpdateInfo)(await this.httpRequest(channelUrl), channelFile, channelUrl);
        } catch (e) {
          if (e instanceof builder_util_runtime_1.HttpError && e.statusCode === 404) {
            throw (0, builder_util_runtime_1.newError)(`Cannot find channel "${channelFile}" update info: ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
          } else if (e.code === "ECONNREFUSED") {
            if (attemptNumber < 3) {
              await new Promise((resolve, reject) => {
                try {
                  setTimeout(resolve, 1e3 * attemptNumber);
                } catch (e2) {
                  reject(e2);
                }
              });
              continue;
            }
          }
          throw e;
        }
      }
    }
    resolveFiles(updateInfo) {
      return (0, Provider_1.resolveFiles)(updateInfo, this.baseUrl);
    }
  };
  GenericProvider.GenericProvider = GenericProvider$1;
  return GenericProvider;
}
var providerFactory = {};
var BitbucketProvider = {};
var hasRequiredBitbucketProvider;
function requireBitbucketProvider() {
  if (hasRequiredBitbucketProvider) return BitbucketProvider;
  hasRequiredBitbucketProvider = 1;
  Object.defineProperty(BitbucketProvider, "__esModule", { value: true });
  BitbucketProvider.BitbucketProvider = void 0;
  const builder_util_runtime_1 = requireOut();
  const util_1 = requireUtil();
  const Provider_1 = requireProvider();
  let BitbucketProvider$1 = class BitbucketProvider extends Provider_1.Provider {
    constructor(configuration, updater, runtimeOptions) {
      super({
        ...runtimeOptions,
        isUseMultipleRangeRequest: false
      });
      this.configuration = configuration;
      this.updater = updater;
      const { owner, slug } = configuration;
      this.baseUrl = (0, util_1.newBaseUrl)(`https://api.bitbucket.org/2.0/repositories/${owner}/${slug}/downloads`);
    }
    get channel() {
      return this.updater.channel || this.configuration.channel || "latest";
    }
    async getLatestVersion() {
      const cancellationToken = new builder_util_runtime_1.CancellationToken();
      const channelFile = (0, util_1.getChannelFilename)(this.getCustomChannelName(this.channel));
      const channelUrl = (0, util_1.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
      try {
        const updateInfo = await this.httpRequest(channelUrl, void 0, cancellationToken);
        return (0, Provider_1.parseUpdateInfo)(updateInfo, channelFile, channelUrl);
      } catch (e) {
        throw (0, builder_util_runtime_1.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
      }
    }
    resolveFiles(updateInfo) {
      return (0, Provider_1.resolveFiles)(updateInfo, this.baseUrl);
    }
    toString() {
      const { owner, slug } = this.configuration;
      return `Bitbucket (owner: ${owner}, slug: ${slug}, channel: ${this.channel})`;
    }
  };
  BitbucketProvider.BitbucketProvider = BitbucketProvider$1;
  return BitbucketProvider;
}
var GitHubProvider = {};
var hasRequiredGitHubProvider;
function requireGitHubProvider() {
  if (hasRequiredGitHubProvider) return GitHubProvider;
  hasRequiredGitHubProvider = 1;
  Object.defineProperty(GitHubProvider, "__esModule", { value: true });
  GitHubProvider.GitHubProvider = GitHubProvider.BaseGitHubProvider = void 0;
  GitHubProvider.computeReleaseNotes = computeReleaseNotes;
  const builder_util_runtime_1 = requireOut();
  const semver2 = requireSemver();
  const url_1 = require$$2$2;
  const util_1 = requireUtil();
  const Provider_1 = requireProvider();
  const hrefRegExp = /\/tag\/([^/]+)$/;
  class BaseGitHubProvider extends Provider_1.Provider {
    constructor(options, defaultHost, runtimeOptions) {
      super({
        ...runtimeOptions,
        /* because GitHib uses S3 */
        isUseMultipleRangeRequest: false
      });
      this.options = options;
      this.baseUrl = (0, util_1.newBaseUrl)((0, builder_util_runtime_1.githubUrl)(options, defaultHost));
      const apiHost = defaultHost === "github.com" ? "api.github.com" : defaultHost;
      this.baseApiUrl = (0, util_1.newBaseUrl)((0, builder_util_runtime_1.githubUrl)(options, apiHost));
    }
    computeGithubBasePath(result) {
      const host = this.options.host;
      return host && !["github.com", "api.github.com"].includes(host) ? `/api/v3${result}` : result;
    }
  }
  GitHubProvider.BaseGitHubProvider = BaseGitHubProvider;
  let GitHubProvider$1 = class GitHubProvider extends BaseGitHubProvider {
    constructor(options, updater, runtimeOptions) {
      super(options, "github.com", runtimeOptions);
      this.options = options;
      this.updater = updater;
    }
    get channel() {
      const result = this.updater.channel || this.options.channel;
      return result == null ? this.getDefaultChannelName() : this.getCustomChannelName(result);
    }
    async getLatestVersion() {
      var _a, _b, _c, _d, _e;
      const cancellationToken = new builder_util_runtime_1.CancellationToken();
      const feedXml = await this.httpRequest((0, util_1.newUrlFromBase)(`${this.basePath}.atom`, this.baseUrl), {
        accept: "application/xml, application/atom+xml, text/xml, */*"
      }, cancellationToken);
      const feed = (0, builder_util_runtime_1.parseXml)(feedXml);
      let latestRelease = feed.element("entry", false, `No published versions on GitHub`);
      let tag = null;
      try {
        if (this.updater.allowPrerelease) {
          const currentChannel = ((_a = this.updater) === null || _a === void 0 ? void 0 : _a.channel) || ((_b = semver2.prerelease(this.updater.currentVersion)) === null || _b === void 0 ? void 0 : _b[0]) || null;
          if (currentChannel === null) {
            tag = hrefRegExp.exec(latestRelease.element("link").attribute("href"))[1];
          } else {
            for (const element of feed.getElements("entry")) {
              const hrefElement = hrefRegExp.exec(element.element("link").attribute("href"));
              if (hrefElement === null)
                continue;
              const hrefTag = hrefElement[1];
              const hrefChannel = ((_c = semver2.prerelease(hrefTag)) === null || _c === void 0 ? void 0 : _c[0]) || null;
              const shouldFetchVersion = !currentChannel || ["alpha", "beta"].includes(currentChannel);
              const isCustomChannel = hrefChannel !== null && !["alpha", "beta"].includes(String(hrefChannel));
              const channelMismatch = currentChannel === "beta" && hrefChannel === "alpha";
              if (shouldFetchVersion && !isCustomChannel && !channelMismatch) {
                tag = hrefTag;
                break;
              }
              const isNextPreRelease = hrefChannel && hrefChannel === currentChannel;
              if (isNextPreRelease) {
                tag = hrefTag;
                break;
              }
            }
          }
        } else {
          tag = await this.getLatestTagName(cancellationToken);
          for (const element of feed.getElements("entry")) {
            if (hrefRegExp.exec(element.element("link").attribute("href"))[1] === tag) {
              latestRelease = element;
              break;
            }
          }
        }
      } catch (e) {
        throw (0, builder_util_runtime_1.newError)(`Cannot parse releases feed: ${e.stack || e.message},
XML:
${feedXml}`, "ERR_UPDATER_INVALID_RELEASE_FEED");
      }
      if (tag == null) {
        throw (0, builder_util_runtime_1.newError)(`No published versions on GitHub`, "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
      }
      let rawData;
      let channelFile = "";
      let channelFileUrl = "";
      const fetchData = async (channelName) => {
        channelFile = (0, util_1.getChannelFilename)(channelName);
        channelFileUrl = (0, util_1.newUrlFromBase)(this.getBaseDownloadPath(String(tag), channelFile), this.baseUrl);
        const requestOptions = this.createRequestOptions(channelFileUrl);
        try {
          return await this.executor.request(requestOptions, cancellationToken);
        } catch (e) {
          if (e instanceof builder_util_runtime_1.HttpError && e.statusCode === 404) {
            throw (0, builder_util_runtime_1.newError)(`Cannot find ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
          }
          throw e;
        }
      };
      try {
        let channel = this.channel;
        if (this.updater.allowPrerelease && ((_d = semver2.prerelease(tag)) === null || _d === void 0 ? void 0 : _d[0])) {
          channel = this.getCustomChannelName(String((_e = semver2.prerelease(tag)) === null || _e === void 0 ? void 0 : _e[0]));
        }
        rawData = await fetchData(channel);
      } catch (e) {
        if (this.updater.allowPrerelease) {
          rawData = await fetchData(this.getDefaultChannelName());
        } else {
          throw e;
        }
      }
      const result = (0, Provider_1.parseUpdateInfo)(rawData, channelFile, channelFileUrl);
      if (result.releaseName == null) {
        result.releaseName = latestRelease.elementValueOrEmpty("title");
      }
      if (result.releaseNotes == null) {
        result.releaseNotes = computeReleaseNotes(this.updater.currentVersion, this.updater.fullChangelog, feed, latestRelease);
      }
      return {
        tag,
        ...result
      };
    }
    async getLatestTagName(cancellationToken) {
      const options = this.options;
      const url = options.host == null || options.host === "github.com" ? (0, util_1.newUrlFromBase)(`${this.basePath}/latest`, this.baseUrl) : new url_1.URL(`${this.computeGithubBasePath(`/repos/${options.owner}/${options.repo}/releases`)}/latest`, this.baseApiUrl);
      try {
        const rawData = await this.httpRequest(url, { Accept: "application/json" }, cancellationToken);
        if (rawData == null) {
          return null;
        }
        const releaseInfo = JSON.parse(rawData);
        return releaseInfo.tag_name;
      } catch (e) {
        throw (0, builder_util_runtime_1.newError)(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
      }
    }
    get basePath() {
      return `/${this.options.owner}/${this.options.repo}/releases`;
    }
    resolveFiles(updateInfo) {
      return (0, Provider_1.resolveFiles)(updateInfo, this.baseUrl, (p) => this.getBaseDownloadPath(updateInfo.tag, p.replace(/ /g, "-")));
    }
    getBaseDownloadPath(tag, fileName) {
      return `${this.basePath}/download/${tag}/${fileName}`;
    }
  };
  GitHubProvider.GitHubProvider = GitHubProvider$1;
  function getNoteValue(parent) {
    const result = parent.elementValueOrEmpty("content");
    return result === "No content." ? "" : result;
  }
  function computeReleaseNotes(currentVersion, isFullChangelog, feed, latestRelease) {
    if (!isFullChangelog) {
      return getNoteValue(latestRelease);
    }
    const releaseNotes = [];
    for (const release of feed.getElements("entry")) {
      const versionRelease = /\/tag\/v?([^/]+)$/.exec(release.element("link").attribute("href"))[1];
      if (semver2.lt(currentVersion, versionRelease)) {
        releaseNotes.push({
          version: versionRelease,
          note: getNoteValue(release)
        });
      }
    }
    return releaseNotes.sort((a, b) => semver2.rcompare(a.version, b.version));
  }
  return GitHubProvider;
}
var GitLabProvider = {};
var hasRequiredGitLabProvider;
function requireGitLabProvider() {
  if (hasRequiredGitLabProvider) return GitLabProvider;
  hasRequiredGitLabProvider = 1;
  Object.defineProperty(GitLabProvider, "__esModule", { value: true });
  GitLabProvider.GitLabProvider = void 0;
  const builder_util_runtime_1 = requireOut();
  const url_1 = require$$2$2;
  const escapeRegExp = requireLodash_escaperegexp();
  const util_1 = requireUtil();
  const Provider_1 = requireProvider();
  let GitLabProvider$1 = class GitLabProvider extends Provider_1.Provider {
    /**
     * Normalizes filenames by replacing spaces and underscores with dashes.
     *
     * This is a workaround to handle filename formatting differences between tools:
     * - electron-builder formats filenames like "test file.txt" as "test-file.txt"
     * - GitLab may provide asset URLs using underscores, such as "test_file.txt"
     *
     * Because of this mismatch, we can't reliably extract the correct filename from
     * the asset path without normalization. This function ensures consistent matching
     * across different filename formats by converting all spaces and underscores to dashes.
     *
     * @param filename The filename to normalize
     * @returns The normalized filename with spaces and underscores replaced by dashes
     */
    normalizeFilename(filename) {
      return filename.replace(/ |_/g, "-");
    }
    constructor(options, updater, runtimeOptions) {
      super({
        ...runtimeOptions,
        // GitLab might not support multiple range requests efficiently
        isUseMultipleRangeRequest: false
      });
      this.options = options;
      this.updater = updater;
      this.cachedLatestVersion = null;
      const defaultHost = "gitlab.com";
      const host = options.host || defaultHost;
      this.baseApiUrl = (0, util_1.newBaseUrl)(`https://${host}/api/v4`);
    }
    get channel() {
      const result = this.updater.channel || this.options.channel;
      return result == null ? this.getDefaultChannelName() : this.getCustomChannelName(result);
    }
    async getLatestVersion() {
      const cancellationToken = new builder_util_runtime_1.CancellationToken();
      const latestReleaseUrl = (0, util_1.newUrlFromBase)(`projects/${this.options.projectId}/releases/permalink/latest`, this.baseApiUrl);
      let latestRelease;
      try {
        const header = { "Content-Type": "application/json", ...this.setAuthHeaderForToken(this.options.token || null) };
        const releaseResponse = await this.httpRequest(latestReleaseUrl, header, cancellationToken);
        if (!releaseResponse) {
          throw (0, builder_util_runtime_1.newError)("No latest release found", "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
        }
        latestRelease = JSON.parse(releaseResponse);
      } catch (e) {
        throw (0, builder_util_runtime_1.newError)(`Unable to find latest release on GitLab (${latestReleaseUrl}): ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
      }
      const tag = latestRelease.tag_name;
      let rawData = null;
      let channelFile = "";
      let channelFileUrl = null;
      const fetchChannelData = async (channelName) => {
        channelFile = (0, util_1.getChannelFilename)(channelName);
        const channelAsset = latestRelease.assets.links.find((asset) => asset.name === channelFile);
        if (!channelAsset) {
          throw (0, builder_util_runtime_1.newError)(`Cannot find ${channelFile} in the latest release assets`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        }
        channelFileUrl = new url_1.URL(channelAsset.direct_asset_url);
        const headers = this.options.token ? { "PRIVATE-TOKEN": this.options.token } : void 0;
        try {
          const result2 = await this.httpRequest(channelFileUrl, headers, cancellationToken);
          if (!result2) {
            throw (0, builder_util_runtime_1.newError)(`Empty response from ${channelFileUrl}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
          }
          return result2;
        } catch (e) {
          if (e instanceof builder_util_runtime_1.HttpError && e.statusCode === 404) {
            throw (0, builder_util_runtime_1.newError)(`Cannot find ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
          }
          throw e;
        }
      };
      try {
        rawData = await fetchChannelData(this.channel);
      } catch (e) {
        if (this.channel !== this.getDefaultChannelName()) {
          rawData = await fetchChannelData(this.getDefaultChannelName());
        } else {
          throw e;
        }
      }
      if (!rawData) {
        throw (0, builder_util_runtime_1.newError)(`Unable to parse channel data from ${channelFile}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
      }
      const result = (0, Provider_1.parseUpdateInfo)(rawData, channelFile, channelFileUrl);
      if (result.releaseName == null) {
        result.releaseName = latestRelease.name;
      }
      if (result.releaseNotes == null) {
        result.releaseNotes = latestRelease.description || null;
      }
      const assetsMap = /* @__PURE__ */ new Map();
      for (const asset of latestRelease.assets.links) {
        assetsMap.set(this.normalizeFilename(asset.name), asset.direct_asset_url);
      }
      const gitlabUpdateInfo = {
        tag,
        assets: assetsMap,
        ...result
      };
      this.cachedLatestVersion = gitlabUpdateInfo;
      return gitlabUpdateInfo;
    }
    /**
     * Utility function to convert GitlabReleaseAsset to Map<string, string>
     * Maps asset names to their download URLs
     */
    convertAssetsToMap(assets) {
      const assetsMap = /* @__PURE__ */ new Map();
      for (const asset of assets.links) {
        assetsMap.set(this.normalizeFilename(asset.name), asset.direct_asset_url);
      }
      return assetsMap;
    }
    /**
     * Find blockmap file URL in assets map for a specific filename
     */
    findBlockMapInAssets(assets, filename) {
      const possibleBlockMapNames = [`${filename}.blockmap`, `${this.normalizeFilename(filename)}.blockmap`];
      for (const blockMapName of possibleBlockMapNames) {
        const assetUrl = assets.get(blockMapName);
        if (assetUrl) {
          return new url_1.URL(assetUrl);
        }
      }
      return null;
    }
    async fetchReleaseInfoByVersion(version2) {
      const cancellationToken = new builder_util_runtime_1.CancellationToken();
      const possibleReleaseIds = [`v${version2}`, version2];
      for (const releaseId of possibleReleaseIds) {
        const releaseUrl = (0, util_1.newUrlFromBase)(`projects/${this.options.projectId}/releases/${encodeURIComponent(releaseId)}`, this.baseApiUrl);
        try {
          const header = { "Content-Type": "application/json", ...this.setAuthHeaderForToken(this.options.token || null) };
          const releaseResponse = await this.httpRequest(releaseUrl, header, cancellationToken);
          if (releaseResponse) {
            const release = JSON.parse(releaseResponse);
            return release;
          }
        } catch (e) {
          if (e instanceof builder_util_runtime_1.HttpError && e.statusCode === 404) {
            continue;
          }
          throw (0, builder_util_runtime_1.newError)(`Unable to find release ${releaseId} on GitLab (${releaseUrl}): ${e.stack || e.message}`, "ERR_UPDATER_RELEASE_NOT_FOUND");
        }
      }
      throw (0, builder_util_runtime_1.newError)(`Unable to find release with version ${version2} (tried: ${possibleReleaseIds.join(", ")}) on GitLab`, "ERR_UPDATER_RELEASE_NOT_FOUND");
    }
    setAuthHeaderForToken(token) {
      const headers = {};
      if (token != null) {
        if (token.startsWith("Bearer")) {
          headers.authorization = token;
        } else {
          headers["PRIVATE-TOKEN"] = token;
        }
      }
      return headers;
    }
    /**
     * Get version info for blockmap files, using cache when possible
     */
    async getVersionInfoForBlockMap(version2) {
      if (this.cachedLatestVersion && this.cachedLatestVersion.version === version2) {
        return this.cachedLatestVersion.assets;
      }
      const versionInfo = await this.fetchReleaseInfoByVersion(version2);
      if (versionInfo && versionInfo.assets) {
        return this.convertAssetsToMap(versionInfo.assets);
      }
      return null;
    }
    /**
     * Find blockmap URLs from version assets
     */
    async findBlockMapUrlsFromAssets(oldVersion, newVersion, baseFilename) {
      let newBlockMapUrl = null;
      let oldBlockMapUrl = null;
      const newVersionAssets = await this.getVersionInfoForBlockMap(newVersion);
      if (newVersionAssets) {
        newBlockMapUrl = this.findBlockMapInAssets(newVersionAssets, baseFilename);
      }
      const oldVersionAssets = await this.getVersionInfoForBlockMap(oldVersion);
      if (oldVersionAssets) {
        const oldFilename = baseFilename.replace(new RegExp(escapeRegExp(newVersion), "g"), oldVersion);
        oldBlockMapUrl = this.findBlockMapInAssets(oldVersionAssets, oldFilename);
      }
      return [oldBlockMapUrl, newBlockMapUrl];
    }
    async getBlockMapFiles(baseUrl, oldVersion, newVersion, oldBlockMapFileBaseUrl = null) {
      if (this.options.uploadTarget === "project_upload") {
        const baseFilename = baseUrl.pathname.split("/").pop() || "";
        const [oldBlockMapUrl, newBlockMapUrl] = await this.findBlockMapUrlsFromAssets(oldVersion, newVersion, baseFilename);
        if (!newBlockMapUrl) {
          throw (0, builder_util_runtime_1.newError)(`Cannot find blockmap file for ${newVersion} in GitLab assets`, "ERR_UPDATER_BLOCKMAP_FILE_NOT_FOUND");
        }
        if (!oldBlockMapUrl) {
          throw (0, builder_util_runtime_1.newError)(`Cannot find blockmap file for ${oldVersion} in GitLab assets`, "ERR_UPDATER_BLOCKMAP_FILE_NOT_FOUND");
        }
        return [oldBlockMapUrl, newBlockMapUrl];
      } else {
        return super.getBlockMapFiles(baseUrl, oldVersion, newVersion, oldBlockMapFileBaseUrl);
      }
    }
    resolveFiles(updateInfo) {
      return (0, Provider_1.getFileList)(updateInfo).map((fileInfo) => {
        const possibleNames = [
          fileInfo.url,
          // Original filename
          this.normalizeFilename(fileInfo.url)
          // Normalized filename (spaces/underscores  dashes)
        ];
        const matchingAssetName = possibleNames.find((name) => updateInfo.assets.has(name));
        const assetUrl = matchingAssetName ? updateInfo.assets.get(matchingAssetName) : void 0;
        if (!assetUrl) {
          throw (0, builder_util_runtime_1.newError)(`Cannot find asset "${fileInfo.url}" in GitLab release assets. Available assets: ${Array.from(updateInfo.assets.keys()).join(", ")}`, "ERR_UPDATER_ASSET_NOT_FOUND");
        }
        return {
          url: new url_1.URL(assetUrl),
          info: fileInfo
        };
      });
    }
    toString() {
      return `GitLab (projectId: ${this.options.projectId}, channel: ${this.channel})`;
    }
  };
  GitLabProvider.GitLabProvider = GitLabProvider$1;
  return GitLabProvider;
}
var KeygenProvider = {};
var hasRequiredKeygenProvider;
function requireKeygenProvider() {
  if (hasRequiredKeygenProvider) return KeygenProvider;
  hasRequiredKeygenProvider = 1;
  Object.defineProperty(KeygenProvider, "__esModule", { value: true });
  KeygenProvider.KeygenProvider = void 0;
  const builder_util_runtime_1 = requireOut();
  const util_1 = requireUtil();
  const Provider_1 = requireProvider();
  let KeygenProvider$1 = class KeygenProvider extends Provider_1.Provider {
    constructor(configuration, updater, runtimeOptions) {
      super({
        ...runtimeOptions,
        isUseMultipleRangeRequest: false
      });
      this.configuration = configuration;
      this.updater = updater;
      this.defaultHostname = "api.keygen.sh";
      const host = this.configuration.host || this.defaultHostname;
      this.baseUrl = (0, util_1.newBaseUrl)(`https://${host}/v1/accounts/${this.configuration.account}/artifacts?product=${this.configuration.product}`);
    }
    get channel() {
      return this.updater.channel || this.configuration.channel || "stable";
    }
    async getLatestVersion() {
      const cancellationToken = new builder_util_runtime_1.CancellationToken();
      const channelFile = (0, util_1.getChannelFilename)(this.getCustomChannelName(this.channel));
      const channelUrl = (0, util_1.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
      try {
        const updateInfo = await this.httpRequest(channelUrl, {
          Accept: "application/vnd.api+json",
          "Keygen-Version": "1.1"
        }, cancellationToken);
        return (0, Provider_1.parseUpdateInfo)(updateInfo, channelFile, channelUrl);
      } catch (e) {
        throw (0, builder_util_runtime_1.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
      }
    }
    resolveFiles(updateInfo) {
      return (0, Provider_1.resolveFiles)(updateInfo, this.baseUrl);
    }
    toString() {
      const { account, product, platform } = this.configuration;
      return `Keygen (account: ${account}, product: ${product}, platform: ${platform}, channel: ${this.channel})`;
    }
  };
  KeygenProvider.KeygenProvider = KeygenProvider$1;
  return KeygenProvider;
}
var PrivateGitHubProvider = {};
var hasRequiredPrivateGitHubProvider;
function requirePrivateGitHubProvider() {
  if (hasRequiredPrivateGitHubProvider) return PrivateGitHubProvider;
  hasRequiredPrivateGitHubProvider = 1;
  Object.defineProperty(PrivateGitHubProvider, "__esModule", { value: true });
  PrivateGitHubProvider.PrivateGitHubProvider = void 0;
  const builder_util_runtime_1 = requireOut();
  const js_yaml_1 = requireJsYaml();
  const path = require$$1$3;
  const url_1 = require$$2$2;
  const util_1 = requireUtil();
  const GitHubProvider_1 = requireGitHubProvider();
  const Provider_1 = requireProvider();
  let PrivateGitHubProvider$1 = class PrivateGitHubProvider extends GitHubProvider_1.BaseGitHubProvider {
    constructor(options, updater, token, runtimeOptions) {
      super(options, "api.github.com", runtimeOptions);
      this.updater = updater;
      this.token = token;
    }
    createRequestOptions(url, headers) {
      const result = super.createRequestOptions(url, headers);
      result.redirect = "manual";
      return result;
    }
    async getLatestVersion() {
      const cancellationToken = new builder_util_runtime_1.CancellationToken();
      const channelFile = (0, util_1.getChannelFilename)(this.getDefaultChannelName());
      const releaseInfo = await this.getLatestVersionInfo(cancellationToken);
      const asset = releaseInfo.assets.find((it) => it.name === channelFile);
      if (asset == null) {
        throw (0, builder_util_runtime_1.newError)(`Cannot find ${channelFile} in the release ${releaseInfo.html_url || releaseInfo.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
      }
      const url = new url_1.URL(asset.url);
      let result;
      try {
        result = (0, js_yaml_1.load)(await this.httpRequest(url, this.configureHeaders("application/octet-stream"), cancellationToken));
      } catch (e) {
        if (e instanceof builder_util_runtime_1.HttpError && e.statusCode === 404) {
          throw (0, builder_util_runtime_1.newError)(`Cannot find ${channelFile} in the latest release artifacts (${url}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        }
        throw e;
      }
      result.assets = releaseInfo.assets;
      return result;
    }
    get fileExtraDownloadHeaders() {
      return this.configureHeaders("application/octet-stream");
    }
    configureHeaders(accept) {
      return {
        accept,
        authorization: `token ${this.token}`
      };
    }
    async getLatestVersionInfo(cancellationToken) {
      const allowPrerelease = this.updater.allowPrerelease;
      let basePath = this.basePath;
      if (!allowPrerelease) {
        basePath = `${basePath}/latest`;
      }
      const url = (0, util_1.newUrlFromBase)(basePath, this.baseUrl);
      try {
        const version2 = JSON.parse(await this.httpRequest(url, this.configureHeaders("application/vnd.github.v3+json"), cancellationToken));
        if (allowPrerelease) {
          return version2.find((it) => it.prerelease) || version2[0];
        } else {
          return version2;
        }
      } catch (e) {
        throw (0, builder_util_runtime_1.newError)(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
      }
    }
    get basePath() {
      return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);
    }
    resolveFiles(updateInfo) {
      return (0, Provider_1.getFileList)(updateInfo).map((it) => {
        const name = path.posix.basename(it.url).replace(/ /g, "-");
        const asset = updateInfo.assets.find((it2) => it2 != null && it2.name === name);
        if (asset == null) {
          throw (0, builder_util_runtime_1.newError)(`Cannot find asset "${name}" in: ${JSON.stringify(updateInfo.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
        }
        return {
          url: new url_1.URL(asset.url),
          info: it
        };
      });
    }
  };
  PrivateGitHubProvider.PrivateGitHubProvider = PrivateGitHubProvider$1;
  return PrivateGitHubProvider;
}
var hasRequiredProviderFactory;
function requireProviderFactory() {
  if (hasRequiredProviderFactory) return providerFactory;
  hasRequiredProviderFactory = 1;
  Object.defineProperty(providerFactory, "__esModule", { value: true });
  providerFactory.isUrlProbablySupportMultiRangeRequests = isUrlProbablySupportMultiRangeRequests;
  providerFactory.createClient = createClient;
  const builder_util_runtime_1 = requireOut();
  const BitbucketProvider_1 = requireBitbucketProvider();
  const GenericProvider_1 = requireGenericProvider();
  const GitHubProvider_1 = requireGitHubProvider();
  const GitLabProvider_1 = requireGitLabProvider();
  const KeygenProvider_1 = requireKeygenProvider();
  const PrivateGitHubProvider_1 = requirePrivateGitHubProvider();
  function isUrlProbablySupportMultiRangeRequests(url) {
    return !url.includes("s3.amazonaws.com");
  }
  function createClient(data, updater, runtimeOptions) {
    if (typeof data === "string") {
      throw (0, builder_util_runtime_1.newError)("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
    }
    const provider = data.provider;
    switch (provider) {
      case "github": {
        const githubOptions = data;
        const token = (githubOptions.private ? process.env["GH_TOKEN"] || process.env["GITHUB_TOKEN"] : null) || githubOptions.token;
        if (token == null) {
          return new GitHubProvider_1.GitHubProvider(githubOptions, updater, runtimeOptions);
        } else {
          return new PrivateGitHubProvider_1.PrivateGitHubProvider(githubOptions, updater, token, runtimeOptions);
        }
      }
      case "bitbucket":
        return new BitbucketProvider_1.BitbucketProvider(data, updater, runtimeOptions);
      case "gitlab":
        return new GitLabProvider_1.GitLabProvider(data, updater, runtimeOptions);
      case "keygen":
        return new KeygenProvider_1.KeygenProvider(data, updater, runtimeOptions);
      case "s3":
      case "spaces":
        return new GenericProvider_1.GenericProvider({
          provider: "generic",
          url: (0, builder_util_runtime_1.getS3LikeProviderBaseUrl)(data),
          channel: data.channel || null
        }, updater, {
          ...runtimeOptions,
          // https://github.com/minio/minio/issues/5285#issuecomment-350428955
          isUseMultipleRangeRequest: false
        });
      case "generic": {
        const options = data;
        return new GenericProvider_1.GenericProvider(options, updater, {
          ...runtimeOptions,
          isUseMultipleRangeRequest: options.useMultipleRangeRequest !== false && isUrlProbablySupportMultiRangeRequests(options.url)
        });
      }
      case "custom": {
        const options = data;
        const constructor = options.updateProvider;
        if (!constructor) {
          throw (0, builder_util_runtime_1.newError)("Custom provider not specified", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
        }
        return new constructor(options, updater, runtimeOptions);
      }
      default:
        throw (0, builder_util_runtime_1.newError)(`Unsupported provider: ${provider}`, "ERR_UPDATER_UNSUPPORTED_PROVIDER");
    }
  }
  return providerFactory;
}
var GenericDifferentialDownloader = {};
var DifferentialDownloader = {};
var DataSplitter = {};
var downloadPlanBuilder = {};
var hasRequiredDownloadPlanBuilder;
function requireDownloadPlanBuilder() {
  if (hasRequiredDownloadPlanBuilder) return downloadPlanBuilder;
  hasRequiredDownloadPlanBuilder = 1;
  Object.defineProperty(downloadPlanBuilder, "__esModule", { value: true });
  downloadPlanBuilder.OperationKind = void 0;
  downloadPlanBuilder.computeOperations = computeOperations;
  var OperationKind;
  (function(OperationKind2) {
    OperationKind2[OperationKind2["COPY"] = 0] = "COPY";
    OperationKind2[OperationKind2["DOWNLOAD"] = 1] = "DOWNLOAD";
  })(OperationKind || (downloadPlanBuilder.OperationKind = OperationKind = {}));
  function computeOperations(oldBlockMap, newBlockMap, logger) {
    const nameToOldBlocks = buildBlockFileMap(oldBlockMap.files);
    const nameToNewBlocks = buildBlockFileMap(newBlockMap.files);
    let lastOperation = null;
    const blockMapFile = newBlockMap.files[0];
    const operations = [];
    const name = blockMapFile.name;
    const oldEntry = nameToOldBlocks.get(name);
    if (oldEntry == null) {
      throw new Error(`no file ${name} in old blockmap`);
    }
    const newFile = nameToNewBlocks.get(name);
    let changedBlockCount = 0;
    const { checksumToOffset: checksumToOldOffset, checksumToOldSize } = buildChecksumMap(nameToOldBlocks.get(name), oldEntry.offset, logger);
    let newOffset = blockMapFile.offset;
    for (let i = 0; i < newFile.checksums.length; newOffset += newFile.sizes[i], i++) {
      const blockSize = newFile.sizes[i];
      const checksum = newFile.checksums[i];
      let oldOffset = checksumToOldOffset.get(checksum);
      if (oldOffset != null && checksumToOldSize.get(checksum) !== blockSize) {
        logger.warn(`Checksum ("${checksum}") matches, but size differs (old: ${checksumToOldSize.get(checksum)}, new: ${blockSize})`);
        oldOffset = void 0;
      }
      if (oldOffset === void 0) {
        changedBlockCount++;
        if (lastOperation != null && lastOperation.kind === OperationKind.DOWNLOAD && lastOperation.end === newOffset) {
          lastOperation.end += blockSize;
        } else {
          lastOperation = {
            kind: OperationKind.DOWNLOAD,
            start: newOffset,
            end: newOffset + blockSize
            // oldBlocks: null,
          };
          validateAndAdd(lastOperation, operations, checksum, i);
        }
      } else {
        if (lastOperation != null && lastOperation.kind === OperationKind.COPY && lastOperation.end === oldOffset) {
          lastOperation.end += blockSize;
        } else {
          lastOperation = {
            kind: OperationKind.COPY,
            start: oldOffset,
            end: oldOffset + blockSize
            // oldBlocks: [checksum]
          };
          validateAndAdd(lastOperation, operations, checksum, i);
        }
      }
    }
    if (changedBlockCount > 0) {
      logger.info(`File${blockMapFile.name === "file" ? "" : " " + blockMapFile.name} has ${changedBlockCount} changed blocks`);
    }
    return operations;
  }
  const isValidateOperationRange = process.env["DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES"] === "true";
  function validateAndAdd(operation, operations, checksum, index) {
    if (isValidateOperationRange && operations.length !== 0) {
      const lastOperation = operations[operations.length - 1];
      if (lastOperation.kind === operation.kind && operation.start < lastOperation.end && operation.start > lastOperation.start) {
        const min = [lastOperation.start, lastOperation.end, operation.start, operation.end].reduce((p, v) => p < v ? p : v);
        throw new Error(`operation (block index: ${index}, checksum: ${checksum}, kind: ${OperationKind[operation.kind]}) overlaps previous operation (checksum: ${checksum}):
abs: ${lastOperation.start} until ${lastOperation.end} and ${operation.start} until ${operation.end}
rel: ${lastOperation.start - min} until ${lastOperation.end - min} and ${operation.start - min} until ${operation.end - min}`);
      }
    }
    operations.push(operation);
  }
  function buildChecksumMap(file2, fileOffset, logger) {
    const checksumToOffset = /* @__PURE__ */ new Map();
    const checksumToSize = /* @__PURE__ */ new Map();
    let offset = fileOffset;
    for (let i = 0; i < file2.checksums.length; i++) {
      const checksum = file2.checksums[i];
      const size = file2.sizes[i];
      const existing = checksumToSize.get(checksum);
      if (existing === void 0) {
        checksumToOffset.set(checksum, offset);
        checksumToSize.set(checksum, size);
      } else if (logger.debug != null) {
        const sizeExplanation = existing === size ? "(same size)" : `(size: ${existing}, this size: ${size})`;
        logger.debug(`${checksum} duplicated in blockmap ${sizeExplanation}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`);
      }
      offset += size;
    }
    return { checksumToOffset, checksumToOldSize: checksumToSize };
  }
  function buildBlockFileMap(list) {
    const result = /* @__PURE__ */ new Map();
    for (const item of list) {
      result.set(item.name, item);
    }
    return result;
  }
  return downloadPlanBuilder;
}
var hasRequiredDataSplitter;
function requireDataSplitter() {
  if (hasRequiredDataSplitter) return DataSplitter;
  hasRequiredDataSplitter = 1;
  Object.defineProperty(DataSplitter, "__esModule", { value: true });
  DataSplitter.DataSplitter = void 0;
  DataSplitter.copyData = copyData;
  const builder_util_runtime_1 = requireOut();
  const fs_1 = require$$1$2;
  const stream_1 = require$$0$2;
  const downloadPlanBuilder_1 = requireDownloadPlanBuilder();
  const DOUBLE_CRLF = Buffer.from("\r\n\r\n");
  var ReadState;
  (function(ReadState2) {
    ReadState2[ReadState2["INIT"] = 0] = "INIT";
    ReadState2[ReadState2["HEADER"] = 1] = "HEADER";
    ReadState2[ReadState2["BODY"] = 2] = "BODY";
  })(ReadState || (ReadState = {}));
  function copyData(task, out2, oldFileFd, reject, resolve) {
    const readStream = (0, fs_1.createReadStream)("", {
      fd: oldFileFd,
      autoClose: false,
      start: task.start,
      // end is inclusive
      end: task.end - 1
    });
    readStream.on("error", reject);
    readStream.once("end", resolve);
    readStream.pipe(out2, {
      end: false
    });
  }
  let DataSplitter$1 = class DataSplitter extends stream_1.Writable {
    constructor(out2, options, partIndexToTaskIndex, boundary, partIndexToLength, finishHandler) {
      super();
      this.out = out2;
      this.options = options;
      this.partIndexToTaskIndex = partIndexToTaskIndex;
      this.partIndexToLength = partIndexToLength;
      this.finishHandler = finishHandler;
      this.partIndex = -1;
      this.headerListBuffer = null;
      this.readState = ReadState.INIT;
      this.ignoreByteCount = 0;
      this.remainingPartDataCount = 0;
      this.actualPartLength = 0;
      this.boundaryLength = boundary.length + 4;
      this.ignoreByteCount = this.boundaryLength - 2;
    }
    get isFinished() {
      return this.partIndex === this.partIndexToLength.length;
    }
    // noinspection JSUnusedGlobalSymbols
    _write(data, encoding, callback) {
      if (this.isFinished) {
        console.error(`Trailing ignored data: ${data.length} bytes`);
        return;
      }
      this.handleData(data).then(callback).catch(callback);
    }
    async handleData(chunk) {
      let start = 0;
      if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0) {
        throw (0, builder_util_runtime_1.newError)("Internal error", "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH");
      }
      if (this.ignoreByteCount > 0) {
        const toIgnore = Math.min(this.ignoreByteCount, chunk.length);
        this.ignoreByteCount -= toIgnore;
        start = toIgnore;
      } else if (this.remainingPartDataCount > 0) {
        const toRead = Math.min(this.remainingPartDataCount, chunk.length);
        this.remainingPartDataCount -= toRead;
        await this.processPartData(chunk, 0, toRead);
        start = toRead;
      }
      if (start === chunk.length) {
        return;
      }
      if (this.readState === ReadState.HEADER) {
        const headerListEnd = this.searchHeaderListEnd(chunk, start);
        if (headerListEnd === -1) {
          return;
        }
        start = headerListEnd;
        this.readState = ReadState.BODY;
        this.headerListBuffer = null;
      }
      while (true) {
        if (this.readState === ReadState.BODY) {
          this.readState = ReadState.INIT;
        } else {
          this.partIndex++;
          let taskIndex = this.partIndexToTaskIndex.get(this.partIndex);
          if (taskIndex == null) {
            if (this.isFinished) {
              taskIndex = this.options.end;
            } else {
              throw (0, builder_util_runtime_1.newError)("taskIndex is null", "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL");
            }
          }
          const prevTaskIndex = this.partIndex === 0 ? this.options.start : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1;
          if (prevTaskIndex < taskIndex) {
            await this.copyExistingData(prevTaskIndex, taskIndex);
          } else if (prevTaskIndex > taskIndex) {
            throw (0, builder_util_runtime_1.newError)("prevTaskIndex must be < taskIndex", "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED");
          }
          if (this.isFinished) {
            this.onPartEnd();
            this.finishHandler();
            return;
          }
          start = this.searchHeaderListEnd(chunk, start);
          if (start === -1) {
            this.readState = ReadState.HEADER;
            return;
          }
        }
        const partLength = this.partIndexToLength[this.partIndex];
        const end = start + partLength;
        const effectiveEnd = Math.min(end, chunk.length);
        await this.processPartStarted(chunk, start, effectiveEnd);
        this.remainingPartDataCount = partLength - (effectiveEnd - start);
        if (this.remainingPartDataCount > 0) {
          return;
        }
        start = end + this.boundaryLength;
        if (start >= chunk.length) {
          this.ignoreByteCount = this.boundaryLength - (chunk.length - end);
          return;
        }
      }
    }
    copyExistingData(index, end) {
      return new Promise((resolve, reject) => {
        const w = () => {
          if (index === end) {
            resolve();
            return;
          }
          const task = this.options.tasks[index];
          if (task.kind !== downloadPlanBuilder_1.OperationKind.COPY) {
            reject(new Error("Task kind must be COPY"));
            return;
          }
          copyData(task, this.out, this.options.oldFileFd, reject, () => {
            index++;
            w();
          });
        };
        w();
      });
    }
    searchHeaderListEnd(chunk, readOffset) {
      const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset);
      if (headerListEnd !== -1) {
        return headerListEnd + DOUBLE_CRLF.length;
      }
      const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset);
      if (this.headerListBuffer == null) {
        this.headerListBuffer = partialChunk;
      } else {
        this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk]);
      }
      return -1;
    }
    onPartEnd() {
      const expectedLength = this.partIndexToLength[this.partIndex - 1];
      if (this.actualPartLength !== expectedLength) {
        throw (0, builder_util_runtime_1.newError)(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, "ERR_DATA_SPLITTER_LENGTH_MISMATCH");
      }
      this.actualPartLength = 0;
    }
    processPartStarted(data, start, end) {
      if (this.partIndex !== 0) {
        this.onPartEnd();
      }
      return this.processPartData(data, start, end);
    }
    processPartData(data, start, end) {
      this.actualPartLength += end - start;
      const out2 = this.out;
      if (out2.write(start === 0 && data.length === end ? data : data.slice(start, end))) {
        return Promise.resolve();
      } else {
        return new Promise((resolve, reject) => {
          out2.on("error", reject);
          out2.once("drain", () => {
            out2.removeListener("error", reject);
            resolve();
          });
        });
      }
    }
  };
  DataSplitter.DataSplitter = DataSplitter$1;
  return DataSplitter;
}
var multipleRangeDownloader = {};
var hasRequiredMultipleRangeDownloader;
function requireMultipleRangeDownloader() {
  if (hasRequiredMultipleRangeDownloader) return multipleRangeDownloader;
  hasRequiredMultipleRangeDownloader = 1;
  Object.defineProperty(multipleRangeDownloader, "__esModule", { value: true });
  multipleRangeDownloader.executeTasksUsingMultipleRangeRequests = executeTasksUsingMultipleRangeRequests;
  multipleRangeDownloader.checkIsRangesSupported = checkIsRangesSupported;
  const builder_util_runtime_1 = requireOut();
  const DataSplitter_1 = requireDataSplitter();
  const downloadPlanBuilder_1 = requireDownloadPlanBuilder();
  function executeTasksUsingMultipleRangeRequests(differentialDownloader, tasks, out2, oldFileFd, reject) {
    const w = (taskOffset) => {
      if (taskOffset >= tasks.length) {
        if (differentialDownloader.fileMetadataBuffer != null) {
          out2.write(differentialDownloader.fileMetadataBuffer);
        }
        out2.end();
        return;
      }
      const nextOffset = taskOffset + 1e3;
      doExecuteTasks(differentialDownloader, {
        tasks,
        start: taskOffset,
        end: Math.min(tasks.length, nextOffset),
        oldFileFd
      }, out2, () => w(nextOffset), reject);
    };
    return w;
  }
  function doExecuteTasks(differentialDownloader, options, out2, resolve, reject) {
    let ranges = "bytes=";
    let partCount = 0;
    const partIndexToTaskIndex = /* @__PURE__ */ new Map();
    const partIndexToLength = [];
    for (let i = options.start; i < options.end; i++) {
      const task = options.tasks[i];
      if (task.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
        ranges += `${task.start}-${task.end - 1}, `;
        partIndexToTaskIndex.set(partCount, i);
        partCount++;
        partIndexToLength.push(task.end - task.start);
      }
    }
    if (partCount <= 1) {
      const w = (index) => {
        if (index >= options.end) {
          resolve();
          return;
        }
        const task = options.tasks[index++];
        if (task.kind === downloadPlanBuilder_1.OperationKind.COPY) {
          (0, DataSplitter_1.copyData)(task, out2, options.oldFileFd, reject, () => w(index));
        } else {
          const requestOptions2 = differentialDownloader.createRequestOptions();
          requestOptions2.headers.Range = `bytes=${task.start}-${task.end - 1}`;
          const request2 = differentialDownloader.httpExecutor.createRequest(requestOptions2, (response) => {
            response.on("error", reject);
            if (!checkIsRangesSupported(response, reject)) {
              return;
            }
            response.pipe(out2, {
              end: false
            });
            response.once("end", () => w(index));
          });
          differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request2, reject);
          request2.end();
        }
      };
      w(options.start);
      return;
    }
    const requestOptions = differentialDownloader.createRequestOptions();
    requestOptions.headers.Range = ranges.substring(0, ranges.length - 2);
    const request = differentialDownloader.httpExecutor.createRequest(requestOptions, (response) => {
      if (!checkIsRangesSupported(response, reject)) {
        return;
      }
      const contentType = (0, builder_util_runtime_1.safeGetHeader)(response, "content-type");
      const m = /^multipart\/.+?\s*;\s*boundary=(?:"([^"]+)"|([^\s";]+))\s*$/i.exec(contentType);
      if (m == null) {
        reject(new Error(`Content-Type "multipart/byteranges" is expected, but got "${contentType}"`));
        return;
      }
      const dicer = new DataSplitter_1.DataSplitter(out2, options, partIndexToTaskIndex, m[1] || m[2], partIndexToLength, resolve);
      dicer.on("error", reject);
      response.pipe(dicer);
      response.on("end", () => {
        setTimeout(() => {
          request.abort();
          reject(new Error("Response ends without calling any handlers"));
        }, 1e4);
      });
    });
    differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
    request.end();
  }
  function checkIsRangesSupported(response, reject) {
    if (response.statusCode >= 400) {
      reject((0, builder_util_runtime_1.createHttpError)(response));
      return false;
    }
    if (response.statusCode !== 206) {
      const acceptRanges = (0, builder_util_runtime_1.safeGetHeader)(response, "accept-ranges");
      if (acceptRanges == null || acceptRanges === "none") {
        reject(new Error(`Server doesn't support Accept-Ranges (response code ${response.statusCode})`));
        return false;
      }
    }
    return true;
  }
  return multipleRangeDownloader;
}
var ProgressDifferentialDownloadCallbackTransform = {};
var hasRequiredProgressDifferentialDownloadCallbackTransform;
function requireProgressDifferentialDownloadCallbackTransform() {
  if (hasRequiredProgressDifferentialDownloadCallbackTransform) return ProgressDifferentialDownloadCallbackTransform;
  hasRequiredProgressDifferentialDownloadCallbackTransform = 1;
  Object.defineProperty(ProgressDifferentialDownloadCallbackTransform, "__esModule", { value: true });
  ProgressDifferentialDownloadCallbackTransform.ProgressDifferentialDownloadCallbackTransform = void 0;
  const stream_1 = require$$0$2;
  var OperationKind;
  (function(OperationKind2) {
    OperationKind2[OperationKind2["COPY"] = 0] = "COPY";
    OperationKind2[OperationKind2["DOWNLOAD"] = 1] = "DOWNLOAD";
  })(OperationKind || (OperationKind = {}));
  let ProgressDifferentialDownloadCallbackTransform$1 = class ProgressDifferentialDownloadCallbackTransform extends stream_1.Transform {
    constructor(progressDifferentialDownloadInfo, cancellationToken, onProgress) {
      super();
      this.progressDifferentialDownloadInfo = progressDifferentialDownloadInfo;
      this.cancellationToken = cancellationToken;
      this.onProgress = onProgress;
      this.start = Date.now();
      this.transferred = 0;
      this.delta = 0;
      this.expectedBytes = 0;
      this.index = 0;
      this.operationType = OperationKind.COPY;
      this.nextUpdate = this.start + 1e3;
    }
    _transform(chunk, encoding, callback) {
      if (this.cancellationToken.cancelled) {
        callback(new Error("cancelled"), null);
        return;
      }
      if (this.operationType == OperationKind.COPY) {
        callback(null, chunk);
        return;
      }
      this.transferred += chunk.length;
      this.delta += chunk.length;
      const now = Date.now();
      if (now >= this.nextUpdate && this.transferred !== this.expectedBytes && this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {
        this.nextUpdate = now + 1e3;
        this.onProgress({
          total: this.progressDifferentialDownloadInfo.grandTotal,
          delta: this.delta,
          transferred: this.transferred,
          percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
          bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1e3))
        });
        this.delta = 0;
      }
      callback(null, chunk);
    }
    beginFileCopy() {
      this.operationType = OperationKind.COPY;
    }
    beginRangeDownload() {
      this.operationType = OperationKind.DOWNLOAD;
      this.expectedBytes += this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++];
    }
    endRangeDownload() {
      if (this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {
        this.onProgress({
          total: this.progressDifferentialDownloadInfo.grandTotal,
          delta: this.delta,
          transferred: this.transferred,
          percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
          bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
        });
      }
    }
    // Called when we are 100% done with the connection/download
    _flush(callback) {
      if (this.cancellationToken.cancelled) {
        callback(new Error("cancelled"));
        return;
      }
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent: 100,
        bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
      });
      this.delta = 0;
      this.transferred = 0;
      callback(null);
    }
  };
  ProgressDifferentialDownloadCallbackTransform.ProgressDifferentialDownloadCallbackTransform = ProgressDifferentialDownloadCallbackTransform$1;
  return ProgressDifferentialDownloadCallbackTransform;
}
var hasRequiredDifferentialDownloader;
function requireDifferentialDownloader() {
  if (hasRequiredDifferentialDownloader) return DifferentialDownloader;
  hasRequiredDifferentialDownloader = 1;
  Object.defineProperty(DifferentialDownloader, "__esModule", { value: true });
  DifferentialDownloader.DifferentialDownloader = void 0;
  const builder_util_runtime_1 = requireOut();
  const fs_extra_1 = /* @__PURE__ */ requireLib$3();
  const fs_1 = require$$1$2;
  const DataSplitter_1 = requireDataSplitter();
  const url_1 = require$$2$2;
  const downloadPlanBuilder_1 = requireDownloadPlanBuilder();
  const multipleRangeDownloader_1 = requireMultipleRangeDownloader();
  const ProgressDifferentialDownloadCallbackTransform_1 = requireProgressDifferentialDownloadCallbackTransform();
  let DifferentialDownloader$1 = class DifferentialDownloader {
    // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected
    constructor(blockAwareFileInfo, httpExecutor2, options) {
      this.blockAwareFileInfo = blockAwareFileInfo;
      this.httpExecutor = httpExecutor2;
      this.options = options;
      this.fileMetadataBuffer = null;
      this.logger = options.logger;
    }
    createRequestOptions() {
      const result = {
        headers: {
          ...this.options.requestHeaders,
          accept: "*/*"
        }
      };
      (0, builder_util_runtime_1.configureRequestUrl)(this.options.newUrl, result);
      (0, builder_util_runtime_1.configureRequestOptions)(result);
      return result;
    }
    doDownload(oldBlockMap, newBlockMap) {
      if (oldBlockMap.version !== newBlockMap.version) {
        throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`);
      }
      const logger = this.logger;
      const operations = (0, downloadPlanBuilder_1.computeOperations)(oldBlockMap, newBlockMap, logger);
      if (logger.debug != null) {
        logger.debug(JSON.stringify(operations, null, 2));
      }
      let downloadSize = 0;
      let copySize = 0;
      for (const operation of operations) {
        const length = operation.end - operation.start;
        if (operation.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
          downloadSize += length;
        } else {
          copySize += length;
        }
      }
      const newSize = this.blockAwareFileInfo.size;
      if (downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) !== newSize) {
        throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newSize: ${newSize}`);
      }
      logger.info(`Full: ${formatBytes(newSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newSize / 100))}%)`);
      return this.downloadFile(operations);
    }
    downloadFile(tasks) {
      const fdList = [];
      const closeFiles = () => {
        return Promise.all(fdList.map((openedFile) => {
          return (0, fs_extra_1.close)(openedFile.descriptor).catch((e) => {
            this.logger.error(`cannot close file "${openedFile.path}": ${e}`);
          });
        }));
      };
      return this.doDownloadFile(tasks, fdList).then(closeFiles).catch((e) => {
        return closeFiles().catch((closeFilesError) => {
          try {
            this.logger.error(`cannot close files: ${closeFilesError}`);
          } catch (errorOnLog) {
            try {
              console.error(errorOnLog);
            } catch (_ignored) {
            }
          }
          throw e;
        }).then(() => {
          throw e;
        });
      });
    }
    async doDownloadFile(tasks, fdList) {
      const oldFileFd = await (0, fs_extra_1.open)(this.options.oldFile, "r");
      fdList.push({ descriptor: oldFileFd, path: this.options.oldFile });
      const newFileFd = await (0, fs_extra_1.open)(this.options.newFile, "w");
      fdList.push({ descriptor: newFileFd, path: this.options.newFile });
      const fileOut = (0, fs_1.createWriteStream)(this.options.newFile, { fd: newFileFd });
      await new Promise((resolve, reject) => {
        const streams2 = [];
        let downloadInfoTransform = void 0;
        if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {
          const expectedByteCounts = [];
          let grandTotalBytes = 0;
          for (const task of tasks) {
            if (task.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
              expectedByteCounts.push(task.end - task.start);
              grandTotalBytes += task.end - task.start;
            }
          }
          const progressDifferentialDownloadInfo = {
            expectedByteCounts,
            grandTotal: grandTotalBytes
          };
          downloadInfoTransform = new ProgressDifferentialDownloadCallbackTransform_1.ProgressDifferentialDownloadCallbackTransform(progressDifferentialDownloadInfo, this.options.cancellationToken, this.options.onProgress);
          streams2.push(downloadInfoTransform);
        }
        const digestTransform = new builder_util_runtime_1.DigestTransform(this.blockAwareFileInfo.sha512);
        digestTransform.isValidateOnEnd = false;
        streams2.push(digestTransform);
        fileOut.on("finish", () => {
          fileOut.close(() => {
            fdList.splice(1, 1);
            try {
              digestTransform.validate();
            } catch (e) {
              reject(e);
              return;
            }
            resolve(void 0);
          });
        });
        streams2.push(fileOut);
        let lastStream = null;
        for (const stream of streams2) {
          stream.on("error", reject);
          if (lastStream == null) {
            lastStream = stream;
          } else {
            lastStream = lastStream.pipe(stream);
          }
        }
        const firstStream = streams2[0];
        let w;
        if (this.options.isUseMultipleRangeRequest) {
          w = (0, multipleRangeDownloader_1.executeTasksUsingMultipleRangeRequests)(this, tasks, firstStream, oldFileFd, reject);
          w(0);
          return;
        }
        let downloadOperationCount = 0;
        let actualUrl = null;
        this.logger.info(`Differential download: ${this.options.newUrl}`);
        const requestOptions = this.createRequestOptions();
        requestOptions.redirect = "manual";
        w = (index) => {
          var _a, _b;
          if (index >= tasks.length) {
            if (this.fileMetadataBuffer != null) {
              firstStream.write(this.fileMetadataBuffer);
            }
            firstStream.end();
            return;
          }
          const operation = tasks[index++];
          if (operation.kind === downloadPlanBuilder_1.OperationKind.COPY) {
            if (downloadInfoTransform) {
              downloadInfoTransform.beginFileCopy();
            }
            (0, DataSplitter_1.copyData)(operation, firstStream, oldFileFd, reject, () => w(index));
            return;
          }
          const range2 = `bytes=${operation.start}-${operation.end - 1}`;
          requestOptions.headers.range = range2;
          (_b = (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, `download range: ${range2}`);
          if (downloadInfoTransform) {
            downloadInfoTransform.beginRangeDownload();
          }
          const request = this.httpExecutor.createRequest(requestOptions, (response) => {
            response.on("error", reject);
            response.on("aborted", () => {
              reject(new Error("response has been aborted by the server"));
            });
            if (response.statusCode >= 400) {
              reject((0, builder_util_runtime_1.createHttpError)(response));
            }
            response.pipe(firstStream, {
              end: false
            });
            response.once("end", () => {
              if (downloadInfoTransform) {
                downloadInfoTransform.endRangeDownload();
              }
              if (++downloadOperationCount === 100) {
                downloadOperationCount = 0;
                setTimeout(() => w(index), 1e3);
              } else {
                w(index);
              }
            });
          });
          request.on("redirect", (statusCode, method, redirectUrl) => {
            this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`);
            actualUrl = redirectUrl;
            (0, builder_util_runtime_1.configureRequestUrl)(new url_1.URL(actualUrl), requestOptions);
            request.followRedirect();
          });
          this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
          request.end();
        };
        w(0);
      });
    }
    async readRemoteBytes(start, endInclusive) {
      const buffer = Buffer.allocUnsafe(endInclusive + 1 - start);
      const requestOptions = this.createRequestOptions();
      requestOptions.headers.range = `bytes=${start}-${endInclusive}`;
      let position = 0;
      await this.request(requestOptions, (chunk) => {
        chunk.copy(buffer, position);
        position += chunk.length;
      });
      if (position !== buffer.length) {
        throw new Error(`Received data length ${position} is not equal to expected ${buffer.length}`);
      }
      return buffer;
    }
    request(requestOptions, dataHandler) {
      return new Promise((resolve, reject) => {
        const request = this.httpExecutor.createRequest(requestOptions, (response) => {
          if (!(0, multipleRangeDownloader_1.checkIsRangesSupported)(response, reject)) {
            return;
          }
          response.on("error", reject);
          response.on("aborted", () => {
            reject(new Error("response has been aborted by the server"));
          });
          response.on("data", dataHandler);
          response.on("end", () => resolve());
        });
        this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
        request.end();
      });
    }
  };
  DifferentialDownloader.DifferentialDownloader = DifferentialDownloader$1;
  function formatBytes(value, symbol = " KB") {
    return new Intl.NumberFormat("en").format((value / 1024).toFixed(2)) + symbol;
  }
  function removeQuery(url) {
    const index = url.indexOf("?");
    return index < 0 ? url : url.substring(0, index);
  }
  return DifferentialDownloader;
}
var hasRequiredGenericDifferentialDownloader;
function requireGenericDifferentialDownloader() {
  if (hasRequiredGenericDifferentialDownloader) return GenericDifferentialDownloader;
  hasRequiredGenericDifferentialDownloader = 1;
  Object.defineProperty(GenericDifferentialDownloader, "__esModule", { value: true });
  GenericDifferentialDownloader.GenericDifferentialDownloader = void 0;
  const DifferentialDownloader_1 = requireDifferentialDownloader();
  let GenericDifferentialDownloader$1 = class GenericDifferentialDownloader extends DifferentialDownloader_1.DifferentialDownloader {
    download(oldBlockMap, newBlockMap) {
      return this.doDownload(oldBlockMap, newBlockMap);
    }
  };
  GenericDifferentialDownloader.GenericDifferentialDownloader = GenericDifferentialDownloader$1;
  return GenericDifferentialDownloader;
}
var types$1 = {};
var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1) return types$1;
  hasRequiredTypes$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.UpdaterSignal = exports$1.UPDATE_DOWNLOADED = exports$1.DOWNLOAD_PROGRESS = exports$1.CancellationToken = void 0;
    exports$1.addHandler = addHandler;
    const builder_util_runtime_1 = requireOut();
    Object.defineProperty(exports$1, "CancellationToken", { enumerable: true, get: function() {
      return builder_util_runtime_1.CancellationToken;
    } });
    exports$1.DOWNLOAD_PROGRESS = "download-progress";
    exports$1.UPDATE_DOWNLOADED = "update-downloaded";
    class UpdaterSignal {
      constructor(emitter) {
        this.emitter = emitter;
      }
      /**
       * Emitted when an authenticating proxy is [asking for user credentials](https://github.com/electron/electron/blob/master/docs/api/client-request.md#event-login).
       */
      login(handler) {
        addHandler(this.emitter, "login", handler);
      }
      progress(handler) {
        addHandler(this.emitter, exports$1.DOWNLOAD_PROGRESS, handler);
      }
      updateDownloaded(handler) {
        addHandler(this.emitter, exports$1.UPDATE_DOWNLOADED, handler);
      }
      updateCancelled(handler) {
        addHandler(this.emitter, "update-cancelled", handler);
      }
    }
    exports$1.UpdaterSignal = UpdaterSignal;
    function addHandler(emitter, event, handler) {
      {
        emitter.on(event, handler);
      }
    }
  })(types$1);
  return types$1;
}
var hasRequiredAppUpdater;
function requireAppUpdater() {
  if (hasRequiredAppUpdater) return AppUpdater;
  hasRequiredAppUpdater = 1;
  Object.defineProperty(AppUpdater, "__esModule", { value: true });
  AppUpdater.NoOpLogger = AppUpdater.AppUpdater = void 0;
  const builder_util_runtime_1 = requireOut();
  const crypto_1 = require$$0$4;
  const os_1 = require$$2$1;
  const events_1 = require$$0$3;
  const fs_extra_1 = /* @__PURE__ */ requireLib$3();
  const js_yaml_1 = requireJsYaml();
  const lazy_val_1 = requireMain$1();
  const path = require$$1$3;
  const semver_1 = requireSemver();
  const DownloadedUpdateHelper_1 = requireDownloadedUpdateHelper();
  const ElectronAppAdapter_1 = requireElectronAppAdapter();
  const electronHttpExecutor_1 = requireElectronHttpExecutor();
  const GenericProvider_1 = requireGenericProvider();
  const providerFactory_1 = requireProviderFactory();
  const zlib_1 = require$$14;
  const GenericDifferentialDownloader_1 = requireGenericDifferentialDownloader();
  const types_1 = requireTypes$1();
  let AppUpdater$1 = class AppUpdater2 extends events_1.EventEmitter {
    /**
     * Get the update channel. Doesn't return `channel` from the update configuration, only if was previously set.
     */
    get channel() {
      return this._channel;
    }
    /**
     * Set the update channel. Overrides `channel` in the update configuration.
     *
     * `allowDowngrade` will be automatically set to `true`. If this behavior is not suitable for you, simple set `allowDowngrade` explicitly after.
     */
    set channel(value) {
      if (this._channel != null) {
        if (typeof value !== "string") {
          throw (0, builder_util_runtime_1.newError)(`Channel must be a string, but got: ${value}`, "ERR_UPDATER_INVALID_CHANNEL");
        } else if (value.length === 0) {
          throw (0, builder_util_runtime_1.newError)(`Channel must be not an empty string`, "ERR_UPDATER_INVALID_CHANNEL");
        }
      }
      this._channel = value;
      this.allowDowngrade = true;
    }
    /**
     *  Shortcut for explicitly adding auth tokens to request headers
     */
    addAuthHeader(token) {
      this.requestHeaders = Object.assign({}, this.requestHeaders, {
        authorization: token
      });
    }
    // noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
    get netSession() {
      return (0, electronHttpExecutor_1.getNetSession)();
    }
    /**
     * The logger. You can pass [electron-log](https://github.com/megahertz/electron-log), [winston](https://github.com/winstonjs/winston) or another logger with the following interface: `{ info(), warn(), error() }`.
     * Set it to `null` if you would like to disable a logging feature.
     */
    get logger() {
      return this._logger;
    }
    set logger(value) {
      this._logger = value == null ? new NoOpLogger() : value;
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * test only
     * @private
     */
    set updateConfigPath(value) {
      this.clientPromise = null;
      this._appUpdateConfigPath = value;
      this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());
    }
    /**
     * Allows developer to override default logic for determining if an update is supported.
     * The default logic compares the `UpdateInfo` minimum system version against the `os.release()` with `semver` package
     */
    get isUpdateSupported() {
      return this._isUpdateSupported;
    }
    set isUpdateSupported(value) {
      if (value) {
        this._isUpdateSupported = value;
      }
    }
    /**
     * Allows developer to override default logic for determining if the user is below the rollout threshold.
     * The default logic compares the staging percentage with numerical representation of user ID.
     * An override can define custom logic, or bypass it if needed.
     */
    get isUserWithinRollout() {
      return this._isUserWithinRollout;
    }
    set isUserWithinRollout(value) {
      if (value) {
        this._isUserWithinRollout = value;
      }
    }
    constructor(options, app) {
      super();
      this.autoDownload = true;
      this.autoInstallOnAppQuit = true;
      this.autoRunAppAfterInstall = true;
      this.allowPrerelease = false;
      this.fullChangelog = false;
      this.allowDowngrade = false;
      this.disableWebInstaller = false;
      this.disableDifferentialDownload = false;
      this.forceDevUpdateConfig = false;
      this.previousBlockmapBaseUrlOverride = null;
      this._channel = null;
      this.downloadedUpdateHelper = null;
      this.requestHeaders = null;
      this._logger = console;
      this.signals = new types_1.UpdaterSignal(this);
      this._appUpdateConfigPath = null;
      this._isUpdateSupported = (updateInfo) => this.checkIfUpdateSupported(updateInfo);
      this._isUserWithinRollout = (updateInfo) => this.isStagingMatch(updateInfo);
      this.clientPromise = null;
      this.stagingUserIdPromise = new lazy_val_1.Lazy(() => this.getOrCreateStagingUserId());
      this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());
      this.checkForUpdatesPromise = null;
      this.downloadPromise = null;
      this.updateInfoAndProvider = null;
      this._testOnlyOptions = null;
      this.on("error", (error2) => {
        this._logger.error(`Error: ${error2.stack || error2.message}`);
      });
      if (app == null) {
        this.app = new ElectronAppAdapter_1.ElectronAppAdapter();
        this.httpExecutor = new electronHttpExecutor_1.ElectronHttpExecutor((authInfo, callback) => this.emit("login", authInfo, callback));
      } else {
        this.app = app;
        this.httpExecutor = null;
      }
      const currentVersionString = this.app.version;
      const currentVersion = (0, semver_1.parse)(currentVersionString);
      if (currentVersion == null) {
        throw (0, builder_util_runtime_1.newError)(`App version is not a valid semver version: "${currentVersionString}"`, "ERR_UPDATER_INVALID_VERSION");
      }
      this.currentVersion = currentVersion;
      this.allowPrerelease = hasPrereleaseComponents(currentVersion);
      if (options != null) {
        this.setFeedURL(options);
        if (typeof options !== "string" && options.requestHeaders) {
          this.requestHeaders = options.requestHeaders;
        }
      }
    }
    //noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
    getFeedURL() {
      return "Deprecated. Do not use it.";
    }
    /**
     * Configure update provider. If value is `string`, [GenericServerOptions](./publish.md#genericserveroptions) will be set with value as `url`.
     * @param options If you want to override configuration in the `app-update.yml`.
     */
    setFeedURL(options) {
      const runtimeOptions = this.createProviderRuntimeOptions();
      let provider;
      if (typeof options === "string") {
        provider = new GenericProvider_1.GenericProvider({ provider: "generic", url: options }, this, {
          ...runtimeOptions,
          isUseMultipleRangeRequest: (0, providerFactory_1.isUrlProbablySupportMultiRangeRequests)(options)
        });
      } else {
        provider = (0, providerFactory_1.createClient)(options, this, runtimeOptions);
      }
      this.clientPromise = Promise.resolve(provider);
    }
    /**
     * Asks the server whether there is an update.
     * @returns null if the updater is disabled, otherwise info about the latest version
     */
    checkForUpdates() {
      if (!this.isUpdaterActive()) {
        return Promise.resolve(null);
      }
      let checkForUpdatesPromise = this.checkForUpdatesPromise;
      if (checkForUpdatesPromise != null) {
        this._logger.info("Checking for update (already in progress)");
        return checkForUpdatesPromise;
      }
      const nullizePromise = () => this.checkForUpdatesPromise = null;
      this._logger.info("Checking for update");
      checkForUpdatesPromise = this.doCheckForUpdates().then((it) => {
        nullizePromise();
        return it;
      }).catch((e) => {
        nullizePromise();
        this.emit("error", e, `Cannot check for updates: ${(e.stack || e).toString()}`);
        throw e;
      });
      this.checkForUpdatesPromise = checkForUpdatesPromise;
      return checkForUpdatesPromise;
    }
    isUpdaterActive() {
      const isEnabled = this.app.isPackaged || this.forceDevUpdateConfig;
      if (!isEnabled) {
        this._logger.info("Skip checkForUpdates because application is not packed and dev update config is not forced");
        return false;
      }
      return true;
    }
    // noinspection JSUnusedGlobalSymbols
    checkForUpdatesAndNotify(downloadNotification) {
      return this.checkForUpdates().then((it) => {
        if (!(it === null || it === void 0 ? void 0 : it.downloadPromise)) {
          if (this._logger.debug != null) {
            this._logger.debug("checkForUpdatesAndNotify called, downloadPromise is null");
          }
          return it;
        }
        void it.downloadPromise.then(() => {
          const notificationContent = AppUpdater2.formatDownloadNotification(it.updateInfo.version, this.app.name, downloadNotification);
          new require$$1$5.Notification(notificationContent).show();
        });
        return it;
      });
    }
    static formatDownloadNotification(version2, appName, downloadNotification) {
      if (downloadNotification == null) {
        downloadNotification = {
          title: "A new update is ready to install",
          body: `{appName} version {version} has been downloaded and will be automatically installed on exit`
        };
      }
      downloadNotification = {
        title: downloadNotification.title.replace("{appName}", appName).replace("{version}", version2),
        body: downloadNotification.body.replace("{appName}", appName).replace("{version}", version2)
      };
      return downloadNotification;
    }
    async isStagingMatch(updateInfo) {
      const rawStagingPercentage = updateInfo.stagingPercentage;
      let stagingPercentage = rawStagingPercentage;
      if (stagingPercentage == null) {
        return true;
      }
      stagingPercentage = parseInt(stagingPercentage, 10);
      if (isNaN(stagingPercentage)) {
        this._logger.warn(`Staging percentage is NaN: ${rawStagingPercentage}`);
        return true;
      }
      stagingPercentage = stagingPercentage / 100;
      const stagingUserId = await this.stagingUserIdPromise.value;
      const val = builder_util_runtime_1.UUID.parse(stagingUserId).readUInt32BE(12);
      const percentage = val / 4294967295;
      this._logger.info(`Staging percentage: ${stagingPercentage}, percentage: ${percentage}, user id: ${stagingUserId}`);
      return percentage < stagingPercentage;
    }
    computeFinalHeaders(headers) {
      if (this.requestHeaders != null) {
        Object.assign(headers, this.requestHeaders);
      }
      return headers;
    }
    async isUpdateAvailable(updateInfo) {
      const latestVersion = (0, semver_1.parse)(updateInfo.version);
      if (latestVersion == null) {
        throw (0, builder_util_runtime_1.newError)(`This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: "${updateInfo.version}"`, "ERR_UPDATER_INVALID_VERSION");
      }
      const currentVersion = this.currentVersion;
      if ((0, semver_1.eq)(latestVersion, currentVersion)) {
        return false;
      }
      if (!await Promise.resolve(this.isUpdateSupported(updateInfo))) {
        return false;
      }
      const isUserWithinRollout = await Promise.resolve(this.isUserWithinRollout(updateInfo));
      if (!isUserWithinRollout) {
        return false;
      }
      const isLatestVersionNewer = (0, semver_1.gt)(latestVersion, currentVersion);
      const isLatestVersionOlder = (0, semver_1.lt)(latestVersion, currentVersion);
      if (isLatestVersionNewer) {
        return true;
      }
      return this.allowDowngrade && isLatestVersionOlder;
    }
    checkIfUpdateSupported(updateInfo) {
      const minimumSystemVersion = updateInfo === null || updateInfo === void 0 ? void 0 : updateInfo.minimumSystemVersion;
      const currentOSVersion = (0, os_1.release)();
      if (minimumSystemVersion) {
        try {
          if ((0, semver_1.lt)(currentOSVersion, minimumSystemVersion)) {
            this._logger.info(`Current OS version ${currentOSVersion} is less than the minimum OS version required ${minimumSystemVersion} for version ${currentOSVersion}`);
            return false;
          }
        } catch (e) {
          this._logger.warn(`Failed to compare current OS version(${currentOSVersion}) with minimum OS version(${minimumSystemVersion}): ${(e.message || e).toString()}`);
        }
      }
      return true;
    }
    async getUpdateInfoAndProvider() {
      await this.app.whenReady();
      if (this.clientPromise == null) {
        this.clientPromise = this.configOnDisk.value.then((it) => (0, providerFactory_1.createClient)(it, this, this.createProviderRuntimeOptions()));
      }
      const client2 = await this.clientPromise;
      const stagingUserId = await this.stagingUserIdPromise.value;
      client2.setRequestHeaders(this.computeFinalHeaders({ "x-user-staging-id": stagingUserId }));
      return {
        info: await client2.getLatestVersion(),
        provider: client2
      };
    }
    createProviderRuntimeOptions() {
      return {
        isUseMultipleRangeRequest: true,
        platform: this._testOnlyOptions == null ? process.platform : this._testOnlyOptions.platform,
        executor: this.httpExecutor
      };
    }
    async doCheckForUpdates() {
      this.emit("checking-for-update");
      const result = await this.getUpdateInfoAndProvider();
      const updateInfo = result.info;
      if (!await this.isUpdateAvailable(updateInfo)) {
        this._logger.info(`Update for version ${this.currentVersion.format()} is not available (latest version: ${updateInfo.version}, downgrade is ${this.allowDowngrade ? "allowed" : "disallowed"}).`);
        this.emit("update-not-available", updateInfo);
        return {
          isUpdateAvailable: false,
          versionInfo: updateInfo,
          updateInfo
        };
      }
      this.updateInfoAndProvider = result;
      this.onUpdateAvailable(updateInfo);
      const cancellationToken = new builder_util_runtime_1.CancellationToken();
      return {
        isUpdateAvailable: true,
        versionInfo: updateInfo,
        updateInfo,
        cancellationToken,
        downloadPromise: this.autoDownload ? this.downloadUpdate(cancellationToken) : null
      };
    }
    onUpdateAvailable(updateInfo) {
      this._logger.info(`Found version ${updateInfo.version} (url: ${(0, builder_util_runtime_1.asArray)(updateInfo.files).map((it) => it.url).join(", ")})`);
      this.emit("update-available", updateInfo);
    }
    /**
     * Start downloading update manually. You can use this method if `autoDownload` option is set to `false`.
     * @returns {Promise<Array<string>>} Paths to downloaded files.
     */
    downloadUpdate(cancellationToken = new builder_util_runtime_1.CancellationToken()) {
      const updateInfoAndProvider = this.updateInfoAndProvider;
      if (updateInfoAndProvider == null) {
        const error2 = new Error("Please check update first");
        this.dispatchError(error2);
        return Promise.reject(error2);
      }
      if (this.downloadPromise != null) {
        this._logger.info("Downloading update (already in progress)");
        return this.downloadPromise;
      }
      this._logger.info(`Downloading update from ${(0, builder_util_runtime_1.asArray)(updateInfoAndProvider.info.files).map((it) => it.url).join(", ")}`);
      const errorHandler = (e) => {
        if (!(e instanceof builder_util_runtime_1.CancellationError)) {
          try {
            this.dispatchError(e);
          } catch (nestedError) {
            this._logger.warn(`Cannot dispatch error event: ${nestedError.stack || nestedError}`);
          }
        }
        return e;
      };
      this.downloadPromise = this.doDownloadUpdate({
        updateInfoAndProvider,
        requestHeaders: this.computeRequestHeaders(updateInfoAndProvider.provider),
        cancellationToken,
        disableWebInstaller: this.disableWebInstaller,
        disableDifferentialDownload: this.disableDifferentialDownload
      }).catch((e) => {
        throw errorHandler(e);
      }).finally(() => {
        this.downloadPromise = null;
      });
      return this.downloadPromise;
    }
    dispatchError(e) {
      this.emit("error", e, (e.stack || e).toString());
    }
    dispatchUpdateDownloaded(event) {
      this.emit(types_1.UPDATE_DOWNLOADED, event);
    }
    async loadUpdateConfig() {
      if (this._appUpdateConfigPath == null) {
        this._appUpdateConfigPath = this.app.appUpdateConfigPath;
      }
      return (0, js_yaml_1.load)(await (0, fs_extra_1.readFile)(this._appUpdateConfigPath, "utf-8"));
    }
    computeRequestHeaders(provider) {
      const fileExtraDownloadHeaders = provider.fileExtraDownloadHeaders;
      if (fileExtraDownloadHeaders != null) {
        const requestHeaders = this.requestHeaders;
        return requestHeaders == null ? fileExtraDownloadHeaders : {
          ...fileExtraDownloadHeaders,
          ...requestHeaders
        };
      }
      return this.computeFinalHeaders({ accept: "*/*" });
    }
    async getOrCreateStagingUserId() {
      const file2 = path.join(this.app.userDataPath, ".updaterId");
      try {
        const id2 = await (0, fs_extra_1.readFile)(file2, "utf-8");
        if (builder_util_runtime_1.UUID.check(id2)) {
          return id2;
        } else {
          this._logger.warn(`Staging user id file exists, but content was invalid: ${id2}`);
        }
      } catch (e) {
        if (e.code !== "ENOENT") {
          this._logger.warn(`Couldn't read staging user ID, creating a blank one: ${e}`);
        }
      }
      const id = builder_util_runtime_1.UUID.v5((0, crypto_1.randomBytes)(4096), builder_util_runtime_1.UUID.OID);
      this._logger.info(`Generated new staging user ID: ${id}`);
      try {
        await (0, fs_extra_1.outputFile)(file2, id);
      } catch (e) {
        this._logger.warn(`Couldn't write out staging user ID: ${e}`);
      }
      return id;
    }
    /** @internal */
    get isAddNoCacheQuery() {
      const headers = this.requestHeaders;
      if (headers == null) {
        return true;
      }
      for (const headerName of Object.keys(headers)) {
        const s = headerName.toLowerCase();
        if (s === "authorization" || s === "private-token") {
          return false;
        }
      }
      return true;
    }
    async getOrCreateDownloadHelper() {
      let result = this.downloadedUpdateHelper;
      if (result == null) {
        const dirName = (await this.configOnDisk.value).updaterCacheDirName;
        const logger = this._logger;
        if (dirName == null) {
          logger.error("updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?");
        }
        const cacheDir = path.join(this.app.baseCachePath, dirName || this.app.name);
        if (logger.debug != null) {
          logger.debug(`updater cache dir: ${cacheDir}`);
        }
        result = new DownloadedUpdateHelper_1.DownloadedUpdateHelper(cacheDir);
        this.downloadedUpdateHelper = result;
      }
      return result;
    }
    async executeDownload(taskOptions) {
      const fileInfo = taskOptions.fileInfo;
      const downloadOptions = {
        headers: taskOptions.downloadUpdateOptions.requestHeaders,
        cancellationToken: taskOptions.downloadUpdateOptions.cancellationToken,
        sha2: fileInfo.info.sha2,
        sha512: fileInfo.info.sha512
      };
      if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);
      }
      const updateInfo = taskOptions.downloadUpdateOptions.updateInfoAndProvider.info;
      const version2 = updateInfo.version;
      const packageInfo = fileInfo.packageInfo;
      function getCacheUpdateFileName() {
        const urlPath = decodeURIComponent(taskOptions.fileInfo.url.pathname);
        if (urlPath.toLowerCase().endsWith(`.${taskOptions.fileExtension.toLowerCase()}`)) {
          return path.basename(urlPath);
        } else {
          return taskOptions.fileInfo.info.url;
        }
      }
      const downloadedUpdateHelper = await this.getOrCreateDownloadHelper();
      const cacheDir = downloadedUpdateHelper.cacheDirForPendingUpdate;
      await (0, fs_extra_1.mkdir)(cacheDir, { recursive: true });
      const updateFileName = getCacheUpdateFileName();
      let updateFile = path.join(cacheDir, updateFileName);
      const packageFile = packageInfo == null ? null : path.join(cacheDir, `package-${version2}${path.extname(packageInfo.path) || ".7z"}`);
      const done = async (isSaveCache) => {
        await downloadedUpdateHelper.setDownloadedFile(updateFile, packageFile, updateInfo, fileInfo, updateFileName, isSaveCache);
        await taskOptions.done({
          ...updateInfo,
          downloadedFile: updateFile
        });
        const currentBlockMapFile = path.join(cacheDir, "current.blockmap");
        if (await (0, fs_extra_1.pathExists)(currentBlockMapFile)) {
          await (0, fs_extra_1.copyFile)(currentBlockMapFile, path.join(downloadedUpdateHelper.cacheDir, "current.blockmap"));
        }
        return packageFile == null ? [updateFile] : [updateFile, packageFile];
      };
      const log = this._logger;
      const cachedUpdateFile = await downloadedUpdateHelper.validateDownloadedPath(updateFile, updateInfo, fileInfo, log);
      if (cachedUpdateFile != null) {
        updateFile = cachedUpdateFile;
        return await done(false);
      }
      const removeFileIfAny = async () => {
        await downloadedUpdateHelper.clear().catch(() => {
        });
        return await (0, fs_extra_1.unlink)(updateFile).catch(() => {
        });
      };
      const tempUpdateFile = await (0, DownloadedUpdateHelper_1.createTempUpdateFile)(`temp-${updateFileName}`, cacheDir, log);
      try {
        await taskOptions.task(tempUpdateFile, downloadOptions, packageFile, removeFileIfAny);
        await (0, builder_util_runtime_1.retry)(() => (0, fs_extra_1.rename)(tempUpdateFile, updateFile), {
          retries: 60,
          interval: 500,
          shouldRetry: (error2) => {
            if (error2 instanceof Error && /^EBUSY:/.test(error2.message)) {
              return true;
            }
            log.warn(`Cannot rename temp file to final file: ${error2.message || error2.stack}`);
            return false;
          }
        });
      } catch (e) {
        await removeFileIfAny();
        if (e instanceof builder_util_runtime_1.CancellationError) {
          log.info("cancelled");
          this.emit("update-cancelled", updateInfo);
        }
        throw e;
      }
      log.info(`New version ${version2} has been downloaded to ${updateFile}`);
      return await done(true);
    }
    async differentialDownloadInstaller(fileInfo, downloadUpdateOptions, installerPath, provider, oldInstallerFileName) {
      try {
        if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload) {
          return true;
        }
        const provider2 = downloadUpdateOptions.updateInfoAndProvider.provider;
        const blockmapFileUrls = await provider2.getBlockMapFiles(fileInfo.url, this.app.version, downloadUpdateOptions.updateInfoAndProvider.info.version, this.previousBlockmapBaseUrlOverride);
        this._logger.info(`Download block maps (old: "${blockmapFileUrls[0]}", new: ${blockmapFileUrls[1]})`);
        const downloadBlockMap = async (url) => {
          const data = await this.httpExecutor.downloadToBuffer(url, {
            headers: downloadUpdateOptions.requestHeaders,
            cancellationToken: downloadUpdateOptions.cancellationToken
          });
          if (data == null || data.length === 0) {
            throw new Error(`Blockmap "${url.href}" is empty`);
          }
          try {
            return JSON.parse((0, zlib_1.gunzipSync)(data).toString());
          } catch (e) {
            throw new Error(`Cannot parse blockmap "${url.href}", error: ${e}`);
          }
        };
        const downloadOptions = {
          newUrl: fileInfo.url,
          oldFile: path.join(this.downloadedUpdateHelper.cacheDir, oldInstallerFileName),
          logger: this._logger,
          newFile: installerPath,
          isUseMultipleRangeRequest: provider2.isUseMultipleRangeRequest,
          requestHeaders: downloadUpdateOptions.requestHeaders,
          cancellationToken: downloadUpdateOptions.cancellationToken
        };
        if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {
          downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);
        }
        const saveBlockMapToCacheDir = async (blockMapData, cacheDir) => {
          const blockMapFile = path.join(cacheDir, "current.blockmap");
          await (0, fs_extra_1.outputFile)(blockMapFile, (0, zlib_1.gzipSync)(JSON.stringify(blockMapData)));
        };
        const getBlockMapFromCacheDir = async (cacheDir) => {
          const blockMapFile = path.join(cacheDir, "current.blockmap");
          try {
            if (await (0, fs_extra_1.pathExists)(blockMapFile)) {
              return JSON.parse((0, zlib_1.gunzipSync)(await (0, fs_extra_1.readFile)(blockMapFile)).toString());
            }
          } catch (e) {
            this._logger.warn(`Cannot parse blockmap "${blockMapFile}", error: ${e}`);
          }
          return null;
        };
        const newBlockMapData = await downloadBlockMap(blockmapFileUrls[1]);
        await saveBlockMapToCacheDir(newBlockMapData, this.downloadedUpdateHelper.cacheDirForPendingUpdate);
        let oldBlockMapData = await getBlockMapFromCacheDir(this.downloadedUpdateHelper.cacheDir);
        if (oldBlockMapData == null) {
          oldBlockMapData = await downloadBlockMap(blockmapFileUrls[0]);
        }
        await new GenericDifferentialDownloader_1.GenericDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download(oldBlockMapData, newBlockMapData);
        return false;
      } catch (e) {
        this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
        if (this._testOnlyOptions != null) {
          throw e;
        }
        return true;
      }
    }
  };
  AppUpdater.AppUpdater = AppUpdater$1;
  function hasPrereleaseComponents(version2) {
    const versionPrereleaseComponent = (0, semver_1.prerelease)(version2);
    return versionPrereleaseComponent != null && versionPrereleaseComponent.length > 0;
  }
  class NoOpLogger {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    info(message) {
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    warn(message) {
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    error(message) {
    }
  }
  AppUpdater.NoOpLogger = NoOpLogger;
  return AppUpdater;
}
var hasRequiredBaseUpdater;
function requireBaseUpdater() {
  if (hasRequiredBaseUpdater) return BaseUpdater;
  hasRequiredBaseUpdater = 1;
  Object.defineProperty(BaseUpdater, "__esModule", { value: true });
  BaseUpdater.BaseUpdater = void 0;
  const child_process_1 = require$$1$6;
  const AppUpdater_1 = requireAppUpdater();
  let BaseUpdater$1 = class BaseUpdater extends AppUpdater_1.AppUpdater {
    constructor(options, app) {
      super(options, app);
      this.quitAndInstallCalled = false;
      this.quitHandlerAdded = false;
    }
    quitAndInstall(isSilent = false, isForceRunAfter = false) {
      this._logger.info(`Install on explicit quitAndInstall`);
      const isInstalled = this.install(isSilent, isSilent ? isForceRunAfter : this.autoRunAppAfterInstall);
      if (isInstalled) {
        setImmediate(() => {
          require$$1$5.autoUpdater.emit("before-quit-for-update");
          this.app.quit();
        });
      } else {
        this.quitAndInstallCalled = false;
      }
    }
    executeDownload(taskOptions) {
      return super.executeDownload({
        ...taskOptions,
        done: (event) => {
          this.dispatchUpdateDownloaded(event);
          this.addQuitHandler();
          return Promise.resolve();
        }
      });
    }
    get installerPath() {
      return this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.file;
    }
    // must be sync (because quit even handler is not async)
    install(isSilent = false, isForceRunAfter = false) {
      if (this.quitAndInstallCalled) {
        this._logger.warn("install call ignored: quitAndInstallCalled is set to true");
        return false;
      }
      const downloadedUpdateHelper = this.downloadedUpdateHelper;
      const installerPath = this.installerPath;
      const downloadedFileInfo = downloadedUpdateHelper == null ? null : downloadedUpdateHelper.downloadedFileInfo;
      if (installerPath == null || downloadedFileInfo == null) {
        this.dispatchError(new Error("No update filepath provided, can't quit and install"));
        return false;
      }
      this.quitAndInstallCalled = true;
      try {
        this._logger.info(`Install: isSilent: ${isSilent}, isForceRunAfter: ${isForceRunAfter}`);
        return this.doInstall({
          isSilent,
          isForceRunAfter,
          isAdminRightsRequired: downloadedFileInfo.isAdminRightsRequired
        });
      } catch (e) {
        this.dispatchError(e);
        return false;
      }
    }
    addQuitHandler() {
      if (this.quitHandlerAdded || !this.autoInstallOnAppQuit) {
        return;
      }
      this.quitHandlerAdded = true;
      this.app.onQuit((exitCode) => {
        if (this.quitAndInstallCalled) {
          this._logger.info("Update installer has already been triggered. Quitting application.");
          return;
        }
        if (!this.autoInstallOnAppQuit) {
          this._logger.info("Update will not be installed on quit because autoInstallOnAppQuit is set to false.");
          return;
        }
        if (exitCode !== 0) {
          this._logger.info(`Update will be not installed on quit because application is quitting with exit code ${exitCode}`);
          return;
        }
        this._logger.info("Auto install update on quit");
        this.install(true, false);
      });
    }
    spawnSyncLog(cmd, args = [], env = {}) {
      this._logger.info(`Executing: ${cmd} with args: ${args}`);
      const response = (0, child_process_1.spawnSync)(cmd, args, {
        env: { ...process.env, ...env },
        encoding: "utf-8",
        shell: true
      });
      const { error: error2, status, stdout, stderr } = response;
      if (error2 != null) {
        this._logger.error(stderr);
        throw error2;
      } else if (status != null && status !== 0) {
        this._logger.error(stderr);
        throw new Error(`Command ${cmd} exited with code ${status}`);
      }
      return stdout.trim();
    }
    /**
     * This handles both node 8 and node 10 way of emitting error when spawning a process
     *   - node 8: Throws the error
     *   - node 10: Emit the error(Need to listen with on)
     */
    // https://github.com/electron-userland/electron-builder/issues/1129
    // Node 8 sends errors: https://nodejs.org/dist/latest-v8.x/docs/api/errors.html#errors_common_system_errors
    async spawnLog(cmd, args = [], env = void 0, stdio = "ignore") {
      this._logger.info(`Executing: ${cmd} with args: ${args}`);
      return new Promise((resolve, reject) => {
        try {
          const params = { stdio, env, detached: true };
          const p = (0, child_process_1.spawn)(cmd, args, params);
          p.on("error", (error2) => {
            reject(error2);
          });
          p.unref();
          if (p.pid !== void 0) {
            resolve(true);
          }
        } catch (error2) {
          reject(error2);
        }
      });
    }
  };
  BaseUpdater.BaseUpdater = BaseUpdater$1;
  return BaseUpdater;
}
var AppImageUpdater = {};
var FileWithEmbeddedBlockMapDifferentialDownloader = {};
var hasRequiredFileWithEmbeddedBlockMapDifferentialDownloader;
function requireFileWithEmbeddedBlockMapDifferentialDownloader() {
  if (hasRequiredFileWithEmbeddedBlockMapDifferentialDownloader) return FileWithEmbeddedBlockMapDifferentialDownloader;
  hasRequiredFileWithEmbeddedBlockMapDifferentialDownloader = 1;
  Object.defineProperty(FileWithEmbeddedBlockMapDifferentialDownloader, "__esModule", { value: true });
  FileWithEmbeddedBlockMapDifferentialDownloader.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;
  const fs_extra_1 = /* @__PURE__ */ requireLib$3();
  const DifferentialDownloader_1 = requireDifferentialDownloader();
  const zlib_1 = require$$14;
  let FileWithEmbeddedBlockMapDifferentialDownloader$1 = class FileWithEmbeddedBlockMapDifferentialDownloader extends DifferentialDownloader_1.DifferentialDownloader {
    async download() {
      const packageInfo = this.blockAwareFileInfo;
      const fileSize = packageInfo.size;
      const offset = fileSize - (packageInfo.blockMapSize + 4);
      this.fileMetadataBuffer = await this.readRemoteBytes(offset, fileSize - 1);
      const newBlockMap = readBlockMap(this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4));
      await this.doDownload(await readEmbeddedBlockMapData(this.options.oldFile), newBlockMap);
    }
  };
  FileWithEmbeddedBlockMapDifferentialDownloader.FileWithEmbeddedBlockMapDifferentialDownloader = FileWithEmbeddedBlockMapDifferentialDownloader$1;
  function readBlockMap(data) {
    return JSON.parse((0, zlib_1.inflateRawSync)(data).toString());
  }
  async function readEmbeddedBlockMapData(file2) {
    const fd = await (0, fs_extra_1.open)(file2, "r");
    try {
      const fileSize = (await (0, fs_extra_1.fstat)(fd)).size;
      const sizeBuffer = Buffer.allocUnsafe(4);
      await (0, fs_extra_1.read)(fd, sizeBuffer, 0, sizeBuffer.length, fileSize - sizeBuffer.length);
      const dataBuffer = Buffer.allocUnsafe(sizeBuffer.readUInt32BE(0));
      await (0, fs_extra_1.read)(fd, dataBuffer, 0, dataBuffer.length, fileSize - sizeBuffer.length - dataBuffer.length);
      await (0, fs_extra_1.close)(fd);
      return readBlockMap(dataBuffer);
    } catch (e) {
      await (0, fs_extra_1.close)(fd);
      throw e;
    }
  }
  return FileWithEmbeddedBlockMapDifferentialDownloader;
}
var hasRequiredAppImageUpdater;
function requireAppImageUpdater() {
  if (hasRequiredAppImageUpdater) return AppImageUpdater;
  hasRequiredAppImageUpdater = 1;
  Object.defineProperty(AppImageUpdater, "__esModule", { value: true });
  AppImageUpdater.AppImageUpdater = void 0;
  const builder_util_runtime_1 = requireOut();
  const child_process_1 = require$$1$6;
  const fs_extra_1 = /* @__PURE__ */ requireLib$3();
  const fs_1 = require$$1$2;
  const path = require$$1$3;
  const BaseUpdater_1 = requireBaseUpdater();
  const FileWithEmbeddedBlockMapDifferentialDownloader_1 = requireFileWithEmbeddedBlockMapDifferentialDownloader();
  const Provider_1 = requireProvider();
  const types_1 = requireTypes$1();
  let AppImageUpdater$1 = class AppImageUpdater extends BaseUpdater_1.BaseUpdater {
    constructor(options, app) {
      super(options, app);
    }
    isUpdaterActive() {
      if (process.env["APPIMAGE"] == null && !this.forceDevUpdateConfig) {
        if (process.env["SNAP"] == null) {
          this._logger.warn("APPIMAGE env is not defined, current application is not an AppImage");
        } else {
          this._logger.info("SNAP env is defined, updater is disabled");
        }
        return false;
      }
      return super.isUpdaterActive();
    }
    /*** @private */
    doDownloadUpdate(downloadUpdateOptions) {
      const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
      const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "AppImage", ["rpm", "deb", "pacman"]);
      return this.executeDownload({
        fileExtension: "AppImage",
        fileInfo,
        downloadUpdateOptions,
        task: async (updateFile, downloadOptions) => {
          const oldFile = process.env["APPIMAGE"];
          if (oldFile == null) {
            throw (0, builder_util_runtime_1.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
          }
          if (downloadUpdateOptions.disableDifferentialDownload || await this.downloadDifferential(fileInfo, oldFile, updateFile, provider, downloadUpdateOptions)) {
            await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
          }
          await (0, fs_extra_1.chmod)(updateFile, 493);
        }
      });
    }
    async downloadDifferential(fileInfo, oldFile, updateFile, provider, downloadUpdateOptions) {
      try {
        const downloadOptions = {
          newUrl: fileInfo.url,
          oldFile,
          logger: this._logger,
          newFile: updateFile,
          isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
          requestHeaders: downloadUpdateOptions.requestHeaders,
          cancellationToken: downloadUpdateOptions.cancellationToken
        };
        if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {
          downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);
        }
        await new FileWithEmbeddedBlockMapDifferentialDownloader_1.FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download();
        return false;
      } catch (e) {
        this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
        return process.platform === "linux";
      }
    }
    doInstall(options) {
      const appImageFile = process.env["APPIMAGE"];
      if (appImageFile == null) {
        throw (0, builder_util_runtime_1.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
      }
      (0, fs_1.unlinkSync)(appImageFile);
      let destination;
      const existingBaseName = path.basename(appImageFile);
      const installerPath = this.installerPath;
      if (installerPath == null) {
        this.dispatchError(new Error("No update filepath provided, can't quit and install"));
        return false;
      }
      if (path.basename(installerPath) === existingBaseName || !/\d+\.\d+\.\d+/.test(existingBaseName)) {
        destination = appImageFile;
      } else {
        destination = path.join(path.dirname(appImageFile), path.basename(installerPath));
      }
      (0, child_process_1.execFileSync)("mv", ["-f", installerPath, destination]);
      if (destination !== appImageFile) {
        this.emit("appimage-filename-updated", destination);
      }
      const env = {
        ...process.env,
        APPIMAGE_SILENT_INSTALL: "true"
      };
      if (options.isForceRunAfter) {
        this.spawnLog(destination, [], env);
      } else {
        env.APPIMAGE_EXIT_AFTER_INSTALL = "true";
        (0, child_process_1.execFileSync)(destination, [], { env });
      }
      return true;
    }
  };
  AppImageUpdater.AppImageUpdater = AppImageUpdater$1;
  return AppImageUpdater;
}
var DebUpdater = {};
var LinuxUpdater = {};
var hasRequiredLinuxUpdater;
function requireLinuxUpdater() {
  if (hasRequiredLinuxUpdater) return LinuxUpdater;
  hasRequiredLinuxUpdater = 1;
  Object.defineProperty(LinuxUpdater, "__esModule", { value: true });
  LinuxUpdater.LinuxUpdater = void 0;
  const BaseUpdater_1 = requireBaseUpdater();
  let LinuxUpdater$1 = class LinuxUpdater extends BaseUpdater_1.BaseUpdater {
    constructor(options, app) {
      super(options, app);
    }
    /**
     * Returns true if the current process is running as root.
     */
    isRunningAsRoot() {
      var _a;
      return ((_a = process.getuid) === null || _a === void 0 ? void 0 : _a.call(process)) === 0;
    }
    /**
     * Sanitizies the installer path for using with command line tools.
     */
    get installerPath() {
      var _a, _b;
      return (_b = (_a = super.installerPath) === null || _a === void 0 ? void 0 : _a.replace(/\\/g, "\\\\").replace(/ /g, "\\ ")) !== null && _b !== void 0 ? _b : null;
    }
    runCommandWithSudoIfNeeded(commandWithArgs) {
      if (this.isRunningAsRoot()) {
        this._logger.info("Running as root, no need to use sudo");
        return this.spawnSyncLog(commandWithArgs[0], commandWithArgs.slice(1));
      }
      const { name } = this.app;
      const installComment = `"${name} would like to update"`;
      const sudo = this.sudoWithArgs(installComment);
      this._logger.info(`Running as non-root user, using sudo to install: ${sudo}`);
      let wrapper = `"`;
      if (/pkexec/i.test(sudo[0]) || sudo[0] === "sudo") {
        wrapper = "";
      }
      return this.spawnSyncLog(sudo[0], [...sudo.length > 1 ? sudo.slice(1) : [], `${wrapper}/bin/bash`, "-c", `'${commandWithArgs.join(" ")}'${wrapper}`]);
    }
    sudoWithArgs(installComment) {
      const sudo = this.determineSudoCommand();
      const command2 = [sudo];
      if (/kdesudo/i.test(sudo)) {
        command2.push("--comment", installComment);
        command2.push("-c");
      } else if (/gksudo/i.test(sudo)) {
        command2.push("--message", installComment);
      } else if (/pkexec/i.test(sudo)) {
        command2.push("--disable-internal-agent");
      }
      return command2;
    }
    hasCommand(cmd) {
      try {
        this.spawnSyncLog(`command`, ["-v", cmd]);
        return true;
      } catch {
        return false;
      }
    }
    determineSudoCommand() {
      const sudos = ["gksudo", "kdesudo", "pkexec", "beesu"];
      for (const sudo of sudos) {
        if (this.hasCommand(sudo)) {
          return sudo;
        }
      }
      return "sudo";
    }
    /**
     * Detects the package manager to use based on the available commands.
     * Allows overriding the default behavior by setting the ELECTRON_BUILDER_LINUX_PACKAGE_MANAGER environment variable.
     * If the environment variable is set, it will be used directly. (This is useful for testing each package manager logic path.)
     * Otherwise, it checks for the presence of the specified package manager commands in the order provided.
     * @param pms - An array of package manager commands to check for, in priority order.
     * @returns The detected package manager command or "unknown" if none are found.
     */
    detectPackageManager(pms) {
      var _a;
      const pmOverride = (_a = process.env.ELECTRON_BUILDER_LINUX_PACKAGE_MANAGER) === null || _a === void 0 ? void 0 : _a.trim();
      if (pmOverride) {
        return pmOverride;
      }
      for (const pm of pms) {
        if (this.hasCommand(pm)) {
          return pm;
        }
      }
      this._logger.warn(`No package manager found in the list: ${pms.join(", ")}. Defaulting to the first one: ${pms[0]}`);
      return pms[0];
    }
  };
  LinuxUpdater.LinuxUpdater = LinuxUpdater$1;
  return LinuxUpdater;
}
var hasRequiredDebUpdater;
function requireDebUpdater() {
  if (hasRequiredDebUpdater) return DebUpdater;
  hasRequiredDebUpdater = 1;
  Object.defineProperty(DebUpdater, "__esModule", { value: true });
  DebUpdater.DebUpdater = void 0;
  const Provider_1 = requireProvider();
  const types_1 = requireTypes$1();
  const LinuxUpdater_1 = requireLinuxUpdater();
  let DebUpdater$1 = class DebUpdater2 extends LinuxUpdater_1.LinuxUpdater {
    constructor(options, app) {
      super(options, app);
    }
    /*** @private */
    doDownloadUpdate(downloadUpdateOptions) {
      const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
      const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "deb", ["AppImage", "rpm", "pacman"]);
      return this.executeDownload({
        fileExtension: "deb",
        fileInfo,
        downloadUpdateOptions,
        task: async (updateFile, downloadOptions) => {
          if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {
            downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);
          }
          await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
        }
      });
    }
    doInstall(options) {
      const installerPath = this.installerPath;
      if (installerPath == null) {
        this.dispatchError(new Error("No update filepath provided, can't quit and install"));
        return false;
      }
      if (!this.hasCommand("dpkg") && !this.hasCommand("apt")) {
        this.dispatchError(new Error("Neither dpkg nor apt command found. Cannot install .deb package."));
        return false;
      }
      const priorityList = ["dpkg", "apt"];
      const packageManager = this.detectPackageManager(priorityList);
      try {
        DebUpdater2.installWithCommandRunner(packageManager, installerPath, this.runCommandWithSudoIfNeeded.bind(this), this._logger);
      } catch (error2) {
        this.dispatchError(error2);
        return false;
      }
      if (options.isForceRunAfter) {
        this.app.relaunch();
      }
      return true;
    }
    static installWithCommandRunner(packageManager, installerPath, commandRunner, logger) {
      var _a;
      if (packageManager === "dpkg") {
        try {
          commandRunner(["dpkg", "-i", installerPath]);
        } catch (error2) {
          logger.warn((_a = error2.message) !== null && _a !== void 0 ? _a : error2);
          logger.warn("dpkg installation failed, trying to fix broken dependencies with apt-get");
          commandRunner(["apt-get", "install", "-f", "-y"]);
        }
      } else if (packageManager === "apt") {
        logger.warn("Using apt to install a local .deb. This may fail for unsigned packages unless properly configured.");
        commandRunner([
          "apt",
          "install",
          "-y",
          "--allow-unauthenticated",
          // needed for unsigned .debs
          "--allow-downgrades",
          // allow lower version installs
          "--allow-change-held-packages",
          installerPath
        ]);
      } else {
        throw new Error(`Package manager ${packageManager} not supported`);
      }
    }
  };
  DebUpdater.DebUpdater = DebUpdater$1;
  return DebUpdater;
}
var PacmanUpdater = {};
var hasRequiredPacmanUpdater;
function requirePacmanUpdater() {
  if (hasRequiredPacmanUpdater) return PacmanUpdater;
  hasRequiredPacmanUpdater = 1;
  Object.defineProperty(PacmanUpdater, "__esModule", { value: true });
  PacmanUpdater.PacmanUpdater = void 0;
  const types_1 = requireTypes$1();
  const Provider_1 = requireProvider();
  const LinuxUpdater_1 = requireLinuxUpdater();
  let PacmanUpdater$1 = class PacmanUpdater2 extends LinuxUpdater_1.LinuxUpdater {
    constructor(options, app) {
      super(options, app);
    }
    /*** @private */
    doDownloadUpdate(downloadUpdateOptions) {
      const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
      const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "pacman", ["AppImage", "deb", "rpm"]);
      return this.executeDownload({
        fileExtension: "pacman",
        fileInfo,
        downloadUpdateOptions,
        task: async (updateFile, downloadOptions) => {
          if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {
            downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);
          }
          await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
        }
      });
    }
    doInstall(options) {
      const installerPath = this.installerPath;
      if (installerPath == null) {
        this.dispatchError(new Error("No update filepath provided, can't quit and install"));
        return false;
      }
      try {
        PacmanUpdater2.installWithCommandRunner(installerPath, this.runCommandWithSudoIfNeeded.bind(this), this._logger);
      } catch (error2) {
        this.dispatchError(error2);
        return false;
      }
      if (options.isForceRunAfter) {
        this.app.relaunch();
      }
      return true;
    }
    static installWithCommandRunner(installerPath, commandRunner, logger) {
      var _a;
      try {
        commandRunner(["pacman", "-U", "--noconfirm", installerPath]);
      } catch (error2) {
        logger.warn((_a = error2.message) !== null && _a !== void 0 ? _a : error2);
        logger.warn("pacman installation failed, attempting to update package database and retry");
        try {
          commandRunner(["pacman", "-Sy", "--noconfirm"]);
          commandRunner(["pacman", "-U", "--noconfirm", installerPath]);
        } catch (retryError) {
          logger.error("Retry after pacman -Sy failed");
          throw retryError;
        }
      }
    }
  };
  PacmanUpdater.PacmanUpdater = PacmanUpdater$1;
  return PacmanUpdater;
}
var RpmUpdater = {};
var hasRequiredRpmUpdater;
function requireRpmUpdater() {
  if (hasRequiredRpmUpdater) return RpmUpdater;
  hasRequiredRpmUpdater = 1;
  Object.defineProperty(RpmUpdater, "__esModule", { value: true });
  RpmUpdater.RpmUpdater = void 0;
  const types_1 = requireTypes$1();
  const Provider_1 = requireProvider();
  const LinuxUpdater_1 = requireLinuxUpdater();
  let RpmUpdater$1 = class RpmUpdater2 extends LinuxUpdater_1.LinuxUpdater {
    constructor(options, app) {
      super(options, app);
    }
    /*** @private */
    doDownloadUpdate(downloadUpdateOptions) {
      const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
      const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "rpm", ["AppImage", "deb", "pacman"]);
      return this.executeDownload({
        fileExtension: "rpm",
        fileInfo,
        downloadUpdateOptions,
        task: async (updateFile, downloadOptions) => {
          if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {
            downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);
          }
          await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
        }
      });
    }
    doInstall(options) {
      const installerPath = this.installerPath;
      if (installerPath == null) {
        this.dispatchError(new Error("No update filepath provided, can't quit and install"));
        return false;
      }
      const priorityList = ["zypper", "dnf", "yum", "rpm"];
      const packageManager = this.detectPackageManager(priorityList);
      try {
        RpmUpdater2.installWithCommandRunner(packageManager, installerPath, this.runCommandWithSudoIfNeeded.bind(this), this._logger);
      } catch (error2) {
        this.dispatchError(error2);
        return false;
      }
      if (options.isForceRunAfter) {
        this.app.relaunch();
      }
      return true;
    }
    static installWithCommandRunner(packageManager, installerPath, commandRunner, logger) {
      if (packageManager === "zypper") {
        return commandRunner(["zypper", "--non-interactive", "--no-refresh", "install", "--allow-unsigned-rpm", "-f", installerPath]);
      }
      if (packageManager === "dnf") {
        return commandRunner(["dnf", "install", "--nogpgcheck", "-y", installerPath]);
      }
      if (packageManager === "yum") {
        return commandRunner(["yum", "install", "--nogpgcheck", "-y", installerPath]);
      }
      if (packageManager === "rpm") {
        logger.warn("Installing with rpm only (no dependency resolution).");
        return commandRunner(["rpm", "-Uvh", "--replacepkgs", "--replacefiles", "--nodeps", installerPath]);
      }
      throw new Error(`Package manager ${packageManager} not supported`);
    }
  };
  RpmUpdater.RpmUpdater = RpmUpdater$1;
  return RpmUpdater;
}
var MacUpdater = {};
var hasRequiredMacUpdater;
function requireMacUpdater() {
  if (hasRequiredMacUpdater) return MacUpdater;
  hasRequiredMacUpdater = 1;
  Object.defineProperty(MacUpdater, "__esModule", { value: true });
  MacUpdater.MacUpdater = void 0;
  const builder_util_runtime_1 = requireOut();
  const fs_extra_1 = /* @__PURE__ */ requireLib$3();
  const fs_1 = require$$1$2;
  const path = require$$1$3;
  const http_1 = require$$4$1;
  const AppUpdater_1 = requireAppUpdater();
  const Provider_1 = requireProvider();
  const child_process_1 = require$$1$6;
  const crypto_1 = require$$0$4;
  let MacUpdater$1 = class MacUpdater extends AppUpdater_1.AppUpdater {
    constructor(options, app) {
      super(options, app);
      this.nativeUpdater = require$$1$5.autoUpdater;
      this.squirrelDownloadedUpdate = false;
      this.nativeUpdater.on("error", (it) => {
        this._logger.warn(it);
        this.emit("error", it);
      });
      this.nativeUpdater.on("update-downloaded", () => {
        this.squirrelDownloadedUpdate = true;
        this.debug("nativeUpdater.update-downloaded");
      });
    }
    debug(message) {
      if (this._logger.debug != null) {
        this._logger.debug(message);
      }
    }
    closeServerIfExists() {
      if (this.server) {
        this.debug("Closing proxy server");
        this.server.close((err) => {
          if (err) {
            this.debug("proxy server wasn't already open, probably attempted closing again as a safety check before quit");
          }
        });
      }
    }
    async doDownloadUpdate(downloadUpdateOptions) {
      let files = downloadUpdateOptions.updateInfoAndProvider.provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info);
      const log = this._logger;
      const sysctlRosettaInfoKey = "sysctl.proc_translated";
      let isRosetta = false;
      try {
        this.debug("Checking for macOS Rosetta environment");
        const result = (0, child_process_1.execFileSync)("sysctl", [sysctlRosettaInfoKey], { encoding: "utf8" });
        isRosetta = result.includes(`${sysctlRosettaInfoKey}: 1`);
        log.info(`Checked for macOS Rosetta environment (isRosetta=${isRosetta})`);
      } catch (e) {
        log.warn(`sysctl shell command to check for macOS Rosetta environment failed: ${e}`);
      }
      let isArm64Mac = false;
      try {
        this.debug("Checking for arm64 in uname");
        const result = (0, child_process_1.execFileSync)("uname", ["-a"], { encoding: "utf8" });
        const isArm = result.includes("ARM");
        log.info(`Checked 'uname -a': arm64=${isArm}`);
        isArm64Mac = isArm64Mac || isArm;
      } catch (e) {
        log.warn(`uname shell command to check for arm64 failed: ${e}`);
      }
      isArm64Mac = isArm64Mac || process.arch === "arm64" || isRosetta;
      const isArm64 = (file2) => {
        var _a;
        return file2.url.pathname.includes("arm64") || ((_a = file2.info.url) === null || _a === void 0 ? void 0 : _a.includes("arm64"));
      };
      if (isArm64Mac && files.some(isArm64)) {
        files = files.filter((file2) => isArm64Mac === isArm64(file2));
      } else {
        files = files.filter((file2) => !isArm64(file2));
      }
      const zipFileInfo = (0, Provider_1.findFile)(files, "zip", ["pkg", "dmg"]);
      if (zipFileInfo == null) {
        throw (0, builder_util_runtime_1.newError)(`ZIP file not provided: ${(0, builder_util_runtime_1.safeStringifyJson)(files)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
      }
      const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
      const CURRENT_MAC_APP_ZIP_FILE_NAME = "update.zip";
      return this.executeDownload({
        fileExtension: "zip",
        fileInfo: zipFileInfo,
        downloadUpdateOptions,
        task: async (destinationFile, downloadOptions) => {
          const cachedUpdateFilePath = path.join(this.downloadedUpdateHelper.cacheDir, CURRENT_MAC_APP_ZIP_FILE_NAME);
          const canDifferentialDownload = () => {
            if (!(0, fs_extra_1.pathExistsSync)(cachedUpdateFilePath)) {
              log.info("Unable to locate previous update.zip for differential download (is this first install?), falling back to full download");
              return false;
            }
            return !downloadUpdateOptions.disableDifferentialDownload;
          };
          let differentialDownloadFailed = true;
          if (canDifferentialDownload()) {
            differentialDownloadFailed = await this.differentialDownloadInstaller(zipFileInfo, downloadUpdateOptions, destinationFile, provider, CURRENT_MAC_APP_ZIP_FILE_NAME);
          }
          if (differentialDownloadFailed) {
            await this.httpExecutor.download(zipFileInfo.url, destinationFile, downloadOptions);
          }
        },
        done: async (event) => {
          if (!downloadUpdateOptions.disableDifferentialDownload) {
            try {
              const cachedUpdateFilePath = path.join(this.downloadedUpdateHelper.cacheDir, CURRENT_MAC_APP_ZIP_FILE_NAME);
              await (0, fs_extra_1.copyFile)(event.downloadedFile, cachedUpdateFilePath);
            } catch (error2) {
              this._logger.warn(`Unable to copy file for caching for future differential downloads: ${error2.message}`);
            }
          }
          return this.updateDownloaded(zipFileInfo, event);
        }
      });
    }
    async updateDownloaded(zipFileInfo, event) {
      var _a;
      const downloadedFile = event.downloadedFile;
      const updateFileSize = (_a = zipFileInfo.info.size) !== null && _a !== void 0 ? _a : (await (0, fs_extra_1.stat)(downloadedFile)).size;
      const log = this._logger;
      const logContext = `fileToProxy=${zipFileInfo.url.href}`;
      this.closeServerIfExists();
      this.debug(`Creating proxy server for native Squirrel.Mac (${logContext})`);
      this.server = (0, http_1.createServer)();
      this.debug(`Proxy server for native Squirrel.Mac is created (${logContext})`);
      this.server.on("close", () => {
        log.info(`Proxy server for native Squirrel.Mac is closed (${logContext})`);
      });
      const getServerUrl = (s) => {
        const address = s.address();
        if (typeof address === "string") {
          return address;
        }
        return `http://127.0.0.1:${address === null || address === void 0 ? void 0 : address.port}`;
      };
      return await new Promise((resolve, reject) => {
        const pass = (0, crypto_1.randomBytes)(64).toString("base64").replace(/\//g, "_").replace(/\+/g, "-");
        const authInfo = Buffer.from(`autoupdater:${pass}`, "ascii");
        const fileUrl = `/${(0, crypto_1.randomBytes)(64).toString("hex")}.zip`;
        this.server.on("request", (request, response) => {
          const requestUrl = request.url;
          log.info(`${requestUrl} requested`);
          if (requestUrl === "/") {
            if (!request.headers.authorization || request.headers.authorization.indexOf("Basic ") === -1) {
              response.statusCode = 401;
              response.statusMessage = "Invalid Authentication Credentials";
              response.end();
              log.warn("No authenthication info");
              return;
            }
            const base64Credentials = request.headers.authorization.split(" ")[1];
            const credentials = Buffer.from(base64Credentials, "base64").toString("ascii");
            const [username, password] = credentials.split(":");
            if (username !== "autoupdater" || password !== pass) {
              response.statusCode = 401;
              response.statusMessage = "Invalid Authentication Credentials";
              response.end();
              log.warn("Invalid authenthication credentials");
              return;
            }
            const data = Buffer.from(`{ "url": "${getServerUrl(this.server)}${fileUrl}" }`);
            response.writeHead(200, { "Content-Type": "application/json", "Content-Length": data.length });
            response.end(data);
            return;
          }
          if (!requestUrl.startsWith(fileUrl)) {
            log.warn(`${requestUrl} requested, but not supported`);
            response.writeHead(404);
            response.end();
            return;
          }
          log.info(`${fileUrl} requested by Squirrel.Mac, pipe ${downloadedFile}`);
          let errorOccurred = false;
          response.on("finish", () => {
            if (!errorOccurred) {
              this.nativeUpdater.removeListener("error", reject);
              resolve([]);
            }
          });
          const readStream = (0, fs_1.createReadStream)(downloadedFile);
          readStream.on("error", (error2) => {
            try {
              response.end();
            } catch (e) {
              log.warn(`cannot end response: ${e}`);
            }
            errorOccurred = true;
            this.nativeUpdater.removeListener("error", reject);
            reject(new Error(`Cannot pipe "${downloadedFile}": ${error2}`));
          });
          response.writeHead(200, {
            "Content-Type": "application/zip",
            "Content-Length": updateFileSize
          });
          readStream.pipe(response);
        });
        this.debug(`Proxy server for native Squirrel.Mac is starting to listen (${logContext})`);
        this.server.listen(0, "127.0.0.1", () => {
          this.debug(`Proxy server for native Squirrel.Mac is listening (address=${getServerUrl(this.server)}, ${logContext})`);
          this.nativeUpdater.setFeedURL({
            url: getServerUrl(this.server),
            headers: {
              "Cache-Control": "no-cache",
              Authorization: `Basic ${authInfo.toString("base64")}`
            }
          });
          this.dispatchUpdateDownloaded(event);
          if (this.autoInstallOnAppQuit) {
            this.nativeUpdater.once("error", reject);
            this.nativeUpdater.checkForUpdates();
          } else {
            resolve([]);
          }
        });
      });
    }
    handleUpdateDownloaded() {
      if (this.autoRunAppAfterInstall) {
        this.nativeUpdater.quitAndInstall();
      } else {
        this.app.quit();
      }
      this.closeServerIfExists();
    }
    quitAndInstall() {
      if (this.squirrelDownloadedUpdate) {
        this.handleUpdateDownloaded();
      } else {
        this.nativeUpdater.on("update-downloaded", () => this.handleUpdateDownloaded());
        if (!this.autoInstallOnAppQuit) {
          this.nativeUpdater.checkForUpdates();
        }
      }
    }
  };
  MacUpdater.MacUpdater = MacUpdater$1;
  return MacUpdater;
}
var NsisUpdater = {};
var windowsExecutableCodeSignatureVerifier = {};
var hasRequiredWindowsExecutableCodeSignatureVerifier;
function requireWindowsExecutableCodeSignatureVerifier() {
  if (hasRequiredWindowsExecutableCodeSignatureVerifier) return windowsExecutableCodeSignatureVerifier;
  hasRequiredWindowsExecutableCodeSignatureVerifier = 1;
  Object.defineProperty(windowsExecutableCodeSignatureVerifier, "__esModule", { value: true });
  windowsExecutableCodeSignatureVerifier.verifySignature = verifySignature;
  const builder_util_runtime_1 = requireOut();
  const child_process_1 = require$$1$6;
  const os = require$$2$1;
  const path = require$$1$3;
  function preparePowerShellExec(command2, timeout) {
    const executable = `set "PSModulePath=" & chcp 65001 >NUL & powershell.exe`;
    const args = ["-NoProfile", "-NonInteractive", "-InputFormat", "None", "-Command", command2];
    const options = {
      shell: true,
      timeout
    };
    return [executable, args, options];
  }
  function verifySignature(publisherNames, unescapedTempUpdateFile, logger) {
    return new Promise((resolve, reject) => {
      const tempUpdateFile = unescapedTempUpdateFile.replace(/'/g, "''");
      logger.info(`Verifying signature ${tempUpdateFile}`);
      (0, child_process_1.execFile)(...preparePowerShellExec(`"Get-AuthenticodeSignature -LiteralPath '${tempUpdateFile}' | ConvertTo-Json -Compress"`, 20 * 1e3), (error2, stdout, stderr) => {
        var _a;
        try {
          if (error2 != null || stderr) {
            handleError(logger, error2, stderr, reject);
            resolve(null);
            return;
          }
          const data = parseOut(stdout);
          if (data.Status === 0) {
            try {
              const normlaizedUpdateFilePath = path.normalize(data.Path);
              const normalizedTempUpdateFile = path.normalize(unescapedTempUpdateFile);
              logger.info(`LiteralPath: ${normlaizedUpdateFilePath}. Update Path: ${normalizedTempUpdateFile}`);
              if (normlaizedUpdateFilePath !== normalizedTempUpdateFile) {
                handleError(logger, new Error(`LiteralPath of ${normlaizedUpdateFilePath} is different than ${normalizedTempUpdateFile}`), stderr, reject);
                resolve(null);
                return;
              }
            } catch (error3) {
              logger.warn(`Unable to verify LiteralPath of update asset due to missing data.Path. Skipping this step of validation. Message: ${(_a = error3.message) !== null && _a !== void 0 ? _a : error3.stack}`);
            }
            const subject = (0, builder_util_runtime_1.parseDn)(data.SignerCertificate.Subject);
            let match = false;
            for (const name of publisherNames) {
              const dn = (0, builder_util_runtime_1.parseDn)(name);
              if (dn.size) {
                const allKeys = Array.from(dn.keys());
                match = allKeys.every((key) => {
                  return dn.get(key) === subject.get(key);
                });
              } else if (name === subject.get("CN")) {
                logger.warn(`Signature validated using only CN ${name}. Please add your full Distinguished Name (DN) to publisherNames configuration`);
                match = true;
              }
              if (match) {
                resolve(null);
                return;
              }
            }
          }
          const result = `publisherNames: ${publisherNames.join(" | ")}, raw info: ` + JSON.stringify(data, (name, value) => name === "RawData" ? void 0 : value, 2);
          logger.warn(`Sign verification failed, installer signed with incorrect certificate: ${result}`);
          resolve(result);
        } catch (e) {
          handleError(logger, e, null, reject);
          resolve(null);
          return;
        }
      });
    });
  }
  function parseOut(out2) {
    const data = JSON.parse(out2);
    delete data.PrivateKey;
    delete data.IsOSBinary;
    delete data.SignatureType;
    const signerCertificate = data.SignerCertificate;
    if (signerCertificate != null) {
      delete signerCertificate.Archived;
      delete signerCertificate.Extensions;
      delete signerCertificate.Handle;
      delete signerCertificate.HasPrivateKey;
      delete signerCertificate.SubjectName;
    }
    return data;
  }
  function handleError(logger, error2, stderr, reject) {
    if (isOldWin6()) {
      logger.warn(`Cannot execute Get-AuthenticodeSignature: ${error2 || stderr}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
      return;
    }
    try {
      (0, child_process_1.execFileSync)(...preparePowerShellExec("ConvertTo-Json test", 10 * 1e3));
    } catch (testError) {
      logger.warn(`Cannot execute ConvertTo-Json: ${testError.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
      return;
    }
    if (error2 != null) {
      reject(error2);
    }
    if (stderr) {
      reject(new Error(`Cannot execute Get-AuthenticodeSignature, stderr: ${stderr}. Failing signature validation due to unknown stderr.`));
    }
  }
  function isOldWin6() {
    const winVersion = os.release();
    return winVersion.startsWith("6.") && !winVersion.startsWith("6.3");
  }
  return windowsExecutableCodeSignatureVerifier;
}
var hasRequiredNsisUpdater;
function requireNsisUpdater() {
  if (hasRequiredNsisUpdater) return NsisUpdater;
  hasRequiredNsisUpdater = 1;
  Object.defineProperty(NsisUpdater, "__esModule", { value: true });
  NsisUpdater.NsisUpdater = void 0;
  const builder_util_runtime_1 = requireOut();
  const path = require$$1$3;
  const BaseUpdater_1 = requireBaseUpdater();
  const FileWithEmbeddedBlockMapDifferentialDownloader_1 = requireFileWithEmbeddedBlockMapDifferentialDownloader();
  const types_1 = requireTypes$1();
  const Provider_1 = requireProvider();
  const fs_extra_1 = /* @__PURE__ */ requireLib$3();
  const windowsExecutableCodeSignatureVerifier_1 = requireWindowsExecutableCodeSignatureVerifier();
  const url_1 = require$$2$2;
  let NsisUpdater$1 = class NsisUpdater extends BaseUpdater_1.BaseUpdater {
    constructor(options, app) {
      super(options, app);
      this._verifyUpdateCodeSignature = (publisherNames, unescapedTempUpdateFile) => (0, windowsExecutableCodeSignatureVerifier_1.verifySignature)(publisherNames, unescapedTempUpdateFile, this._logger);
    }
    /**
     * The verifyUpdateCodeSignature. You can pass [win-verify-signature](https://github.com/beyondkmp/win-verify-trust) or another custom verify function: ` (publisherName: string[], path: string) => Promise<string | null>`.
     * The default verify function uses [windowsExecutableCodeSignatureVerifier](https://github.com/electron-userland/electron-builder/blob/master/packages/electron-updater/src/windowsExecutableCodeSignatureVerifier.ts)
     */
    get verifyUpdateCodeSignature() {
      return this._verifyUpdateCodeSignature;
    }
    set verifyUpdateCodeSignature(value) {
      if (value) {
        this._verifyUpdateCodeSignature = value;
      }
    }
    /*** @private */
    doDownloadUpdate(downloadUpdateOptions) {
      const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
      const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "exe");
      return this.executeDownload({
        fileExtension: "exe",
        downloadUpdateOptions,
        fileInfo,
        task: async (destinationFile, downloadOptions, packageFile, removeTempDirIfAny) => {
          const packageInfo = fileInfo.packageInfo;
          const isWebInstaller = packageInfo != null && packageFile != null;
          if (isWebInstaller && downloadUpdateOptions.disableWebInstaller) {
            throw (0, builder_util_runtime_1.newError)(`Unable to download new version ${downloadUpdateOptions.updateInfoAndProvider.info.version}. Web Installers are disabled`, "ERR_UPDATER_WEB_INSTALLER_DISABLED");
          }
          if (!isWebInstaller && !downloadUpdateOptions.disableWebInstaller) {
            this._logger.warn("disableWebInstaller is set to false, you should set it to true if you do not plan on using a web installer. This will default to true in a future version.");
          }
          if (isWebInstaller || downloadUpdateOptions.disableDifferentialDownload || await this.differentialDownloadInstaller(fileInfo, downloadUpdateOptions, destinationFile, provider, builder_util_runtime_1.CURRENT_APP_INSTALLER_FILE_NAME)) {
            await this.httpExecutor.download(fileInfo.url, destinationFile, downloadOptions);
          }
          const signatureVerificationStatus = await this.verifySignature(destinationFile);
          if (signatureVerificationStatus != null) {
            await removeTempDirIfAny();
            throw (0, builder_util_runtime_1.newError)(`New version ${downloadUpdateOptions.updateInfoAndProvider.info.version} is not signed by the application owner: ${signatureVerificationStatus}`, "ERR_UPDATER_INVALID_SIGNATURE");
          }
          if (isWebInstaller) {
            if (await this.differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packageFile, provider)) {
              try {
                await this.httpExecutor.download(new url_1.URL(packageInfo.path), packageFile, {
                  headers: downloadUpdateOptions.requestHeaders,
                  cancellationToken: downloadUpdateOptions.cancellationToken,
                  sha512: packageInfo.sha512
                });
              } catch (e) {
                try {
                  await (0, fs_extra_1.unlink)(packageFile);
                } catch (_ignored) {
                }
                throw e;
              }
            }
          }
        }
      });
    }
    // $certificateInfo = (Get-AuthenticodeSignature 'xxx\yyy.exe'
    // | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains("CN=siemens.com")})
    // | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }
    async verifySignature(tempUpdateFile) {
      let publisherName;
      try {
        publisherName = (await this.configOnDisk.value).publisherName;
        if (publisherName == null) {
          return null;
        }
      } catch (e) {
        if (e.code === "ENOENT") {
          return null;
        }
        throw e;
      }
      return await this._verifyUpdateCodeSignature(Array.isArray(publisherName) ? publisherName : [publisherName], tempUpdateFile);
    }
    doInstall(options) {
      const installerPath = this.installerPath;
      if (installerPath == null) {
        this.dispatchError(new Error("No update filepath provided, can't quit and install"));
        return false;
      }
      const args = ["--updated"];
      if (options.isSilent) {
        args.push("/S");
      }
      if (options.isForceRunAfter) {
        args.push("--force-run");
      }
      if (this.installDirectory) {
        args.push(`/D=${this.installDirectory}`);
      }
      const packagePath = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.packageFile;
      if (packagePath != null) {
        args.push(`--package-file=${packagePath}`);
      }
      const callUsingElevation = () => {
        this.spawnLog(path.join(process.resourcesPath, "elevate.exe"), [installerPath].concat(args)).catch((e) => this.dispatchError(e));
      };
      if (options.isAdminRightsRequired) {
        this._logger.info("isAdminRightsRequired is set to true, run installer using elevate.exe");
        callUsingElevation();
        return true;
      }
      this.spawnLog(installerPath, args).catch((e) => {
        const errorCode = e.code;
        this._logger.info(`Cannot run installer: error code: ${errorCode}, error message: "${e.message}", will be executed again using elevate if EACCES, and will try to use electron.shell.openItem if ENOENT`);
        if (errorCode === "UNKNOWN" || errorCode === "EACCES") {
          callUsingElevation();
        } else if (errorCode === "ENOENT") {
          require$$1$5.shell.openPath(installerPath).catch((err) => this.dispatchError(err));
        } else {
          this.dispatchError(e);
        }
      });
      return true;
    }
    async differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packagePath, provider) {
      if (packageInfo.blockMapSize == null) {
        return true;
      }
      try {
        const downloadOptions = {
          newUrl: new url_1.URL(packageInfo.path),
          oldFile: path.join(this.downloadedUpdateHelper.cacheDir, builder_util_runtime_1.CURRENT_APP_PACKAGE_FILE_NAME),
          logger: this._logger,
          newFile: packagePath,
          requestHeaders: this.requestHeaders,
          isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
          cancellationToken: downloadUpdateOptions.cancellationToken
        };
        if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {
          downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);
        }
        await new FileWithEmbeddedBlockMapDifferentialDownloader_1.FileWithEmbeddedBlockMapDifferentialDownloader(packageInfo, this.httpExecutor, downloadOptions).download();
      } catch (e) {
        this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
        return process.platform === "win32";
      }
      return false;
    }
  };
  NsisUpdater.NsisUpdater = NsisUpdater$1;
  return NsisUpdater;
}
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain) return main$1;
  hasRequiredMain = 1;
  (function(exports$1) {
    var __createBinding = main$1 && main$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = main$1 && main$1.__exportStar || function(m, exports$12) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
    };
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.NsisUpdater = exports$1.MacUpdater = exports$1.RpmUpdater = exports$1.PacmanUpdater = exports$1.DebUpdater = exports$1.AppImageUpdater = exports$1.Provider = exports$1.NoOpLogger = exports$1.AppUpdater = exports$1.BaseUpdater = void 0;
    const fs_extra_1 = /* @__PURE__ */ requireLib$3();
    const path = require$$1$3;
    var BaseUpdater_1 = requireBaseUpdater();
    Object.defineProperty(exports$1, "BaseUpdater", { enumerable: true, get: function() {
      return BaseUpdater_1.BaseUpdater;
    } });
    var AppUpdater_1 = requireAppUpdater();
    Object.defineProperty(exports$1, "AppUpdater", { enumerable: true, get: function() {
      return AppUpdater_1.AppUpdater;
    } });
    Object.defineProperty(exports$1, "NoOpLogger", { enumerable: true, get: function() {
      return AppUpdater_1.NoOpLogger;
    } });
    var Provider_1 = requireProvider();
    Object.defineProperty(exports$1, "Provider", { enumerable: true, get: function() {
      return Provider_1.Provider;
    } });
    var AppImageUpdater_1 = requireAppImageUpdater();
    Object.defineProperty(exports$1, "AppImageUpdater", { enumerable: true, get: function() {
      return AppImageUpdater_1.AppImageUpdater;
    } });
    var DebUpdater_1 = requireDebUpdater();
    Object.defineProperty(exports$1, "DebUpdater", { enumerable: true, get: function() {
      return DebUpdater_1.DebUpdater;
    } });
    var PacmanUpdater_1 = requirePacmanUpdater();
    Object.defineProperty(exports$1, "PacmanUpdater", { enumerable: true, get: function() {
      return PacmanUpdater_1.PacmanUpdater;
    } });
    var RpmUpdater_1 = requireRpmUpdater();
    Object.defineProperty(exports$1, "RpmUpdater", { enumerable: true, get: function() {
      return RpmUpdater_1.RpmUpdater;
    } });
    var MacUpdater_1 = requireMacUpdater();
    Object.defineProperty(exports$1, "MacUpdater", { enumerable: true, get: function() {
      return MacUpdater_1.MacUpdater;
    } });
    var NsisUpdater_1 = requireNsisUpdater();
    Object.defineProperty(exports$1, "NsisUpdater", { enumerable: true, get: function() {
      return NsisUpdater_1.NsisUpdater;
    } });
    __exportStar(requireTypes$1(), exports$1);
    let _autoUpdater;
    function doLoadAutoUpdater() {
      if (process.platform === "win32") {
        _autoUpdater = new (requireNsisUpdater()).NsisUpdater();
      } else if (process.platform === "darwin") {
        _autoUpdater = new (requireMacUpdater()).MacUpdater();
      } else {
        _autoUpdater = new (requireAppImageUpdater()).AppImageUpdater();
        try {
          const identity = path.join(process.resourcesPath, "package-type");
          if (!(0, fs_extra_1.existsSync)(identity)) {
            return _autoUpdater;
          }
          console.info("Checking for beta autoupdate feature for deb/rpm distributions");
          const fileType = (0, fs_extra_1.readFileSync)(identity).toString().trim();
          console.info("Found package-type:", fileType);
          switch (fileType) {
            case "deb":
              _autoUpdater = new (requireDebUpdater()).DebUpdater();
              break;
            case "rpm":
              _autoUpdater = new (requireRpmUpdater()).RpmUpdater();
              break;
            case "pacman":
              _autoUpdater = new (requirePacmanUpdater()).PacmanUpdater();
              break;
            default:
              break;
          }
        } catch (error2) {
          console.warn("Unable to detect 'package-type' for autoUpdater (rpm/deb/pacman support). If you'd like to expand support, please consider contributing to electron-builder", error2.message);
        }
      }
      return _autoUpdater;
    }
    Object.defineProperty(exports$1, "autoUpdater", {
      enumerable: true,
      get: () => {
        return _autoUpdater || doLoadAutoUpdater();
      }
    });
  })(main$1);
  return main$1;
}
var mainExports = requireMain();
const require$2 = module$1.createRequire(typeof document === "undefined" ? require("url").pathToFileURL(__filename).href : _documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === "SCRIPT" && _documentCurrentScript.src || new URL("index.js", document.baseURI).href);
const sqlite3$1 = require$2("sqlite3");
class InternalDBService {
  db;
  constructor() {
    const userDataPath = require$$1$5.app.getPath("userData");
    const dbPath = require$$1$3.join(userDataPath, "app_data.db");
    this.db = new sqlite3$1.Database(dbPath);
    this.init();
  }
  init() {
    this.db.serialize(() => {
      this.db.run(`
        CREATE TABLE IF NOT EXISTS connections (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL,
          type TEXT NOT NULL,
          host TEXT,
          port INTEGER,
          user TEXT,
          password TEXT,
          database TEXT
        )
      `);
      this.db.run(`
        CREATE TABLE IF NOT EXISTS settings (
          key TEXT PRIMARY KEY,
          value TEXT
        )
      `);
      this.db.run(`
        CREATE TABLE IF NOT EXISTS consoles (
          id TEXT PRIMARY KEY,
          connectionId INTEGER,
          name TEXT NOT NULL,
          sql TEXT,
          dbName TEXT,
          createdAt DATETIME DEFAULT CURRENT_TIMESTAMP
        )
      `);
    });
  }
  saveConsole(console2) {
    return new Promise((resolve, reject) => {
      this.db.run(
        "INSERT OR REPLACE INTO consoles (id, connectionId, name, sql, dbName) VALUES (?, ?, ?, ?, ?)",
        [console2.id, console2.connectionId, console2.name, console2.sql, console2.dbName],
        (err) => {
          if (err) reject(err);
          else resolve();
        }
      );
    });
  }
  deleteConsole(id) {
    return new Promise((resolve, reject) => {
      this.db.run("DELETE FROM consoles WHERE id = ?", [id], (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }
  getConsoles(connectionId) {
    return new Promise((resolve, reject) => {
      const query2 = connectionId ? "SELECT * FROM consoles WHERE connectionId = ? ORDER BY createdAt ASC" : "SELECT * FROM consoles ORDER BY createdAt ASC";
      const params = connectionId ? [connectionId] : [];
      this.db.all(query2, params, (err, rows) => {
        if (err) reject(err);
        else resolve(rows);
      });
    });
  }
  saveSetting(key, value) {
    return new Promise((resolve, reject) => {
      this.db.run("INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)", [key, value], (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }
  getSetting(key) {
    return new Promise((resolve, reject) => {
      this.db.get("SELECT value FROM settings WHERE key = ?", [key], (err, row) => {
        if (err) reject(err);
        else resolve(row ? row.value : null);
      });
    });
  }
  saveConnection(config) {
    return new Promise((resolve, reject) => {
      if (config.id) {
        const stmt = this.db.prepare(`
          UPDATE connections 
          SET name = ?, type = ?, host = ?, port = ?, user = ?, password = ?, database = ?
          WHERE id = ?
        `);
        stmt.run(
          config.name,
          config.type,
          config.host || null,
          config.port || null,
          config.user || null,
          config.password || null,
          config.database || null,
          config.id,
          (err) => {
            if (err) reject(err);
            else resolve();
          }
        );
        stmt.finalize();
      } else {
        const stmt = this.db.prepare(`
          INSERT INTO connections (name, type, host, port, user, password, database)
          VALUES (?, ?, ?, ?, ?, ?, ?)
        `);
        stmt.run(
          config.name,
          config.type,
          config.host || null,
          config.port || null,
          config.user || null,
          config.password || null,
          config.database || null,
          (err) => {
            if (err) reject(err);
            else resolve();
          }
        );
        stmt.finalize();
      }
    });
  }
  getConnections() {
    return new Promise((resolve, reject) => {
      this.db.all("SELECT * FROM connections", (err, rows) => {
        if (err) reject(err);
        else resolve(rows);
      });
    });
  }
  deleteConnection(id) {
    return new Promise((resolve, reject) => {
      this.db.run("DELETE FROM connections WHERE id = ?", id, (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }
}
const internalDB = new InternalDBService();
var promise = {};
var SqlString = {};
var hasRequiredSqlString;
function requireSqlString() {
  if (hasRequiredSqlString) return SqlString;
  hasRequiredSqlString = 1;
  (function(exports$1) {
    var SqlString2 = exports$1;
    var ID_GLOBAL_REGEXP = /`/g;
    var QUAL_GLOBAL_REGEXP = /\./g;
    var CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g;
    var CHARS_ESCAPE_MAP = {
      "\0": "\\0",
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\r": "\\r",
      "": "\\Z",
      '"': '\\"',
      "'": "\\'",
      "\\": "\\\\"
    };
    SqlString2.escapeId = function escapeId(val, forbidQualified) {
      if (Array.isArray(val)) {
        var sql = "";
        for (var i = 0; i < val.length; i++) {
          sql += (i === 0 ? "" : ", ") + SqlString2.escapeId(val[i], forbidQualified);
        }
        return sql;
      } else if (forbidQualified) {
        return "`" + String(val).replace(ID_GLOBAL_REGEXP, "``") + "`";
      } else {
        return "`" + String(val).replace(ID_GLOBAL_REGEXP, "``").replace(QUAL_GLOBAL_REGEXP, "`.`") + "`";
      }
    };
    SqlString2.escape = function escape(val, stringifyObjects, timeZone) {
      if (val === void 0 || val === null) {
        return "NULL";
      }
      switch (typeof val) {
        case "boolean":
          return val ? "true" : "false";
        case "number":
          return val + "";
        case "object":
          if (Object.prototype.toString.call(val) === "[object Date]") {
            return SqlString2.dateToString(val, timeZone || "local");
          } else if (Array.isArray(val)) {
            return SqlString2.arrayToList(val, timeZone);
          } else if (Buffer.isBuffer(val)) {
            return SqlString2.bufferToString(val);
          } else if (typeof val.toSqlString === "function") {
            return String(val.toSqlString());
          } else if (stringifyObjects) {
            return escapeString(val.toString());
          } else {
            return SqlString2.objectToValues(val, timeZone);
          }
        default:
          return escapeString(val);
      }
    };
    SqlString2.arrayToList = function arrayToList(array, timeZone) {
      var sql = "";
      for (var i = 0; i < array.length; i++) {
        var val = array[i];
        if (Array.isArray(val)) {
          sql += (i === 0 ? "" : ", ") + "(" + SqlString2.arrayToList(val, timeZone) + ")";
        } else {
          sql += (i === 0 ? "" : ", ") + SqlString2.escape(val, true, timeZone);
        }
      }
      return sql;
    };
    SqlString2.format = function format(sql, values, stringifyObjects, timeZone) {
      if (values == null) {
        return sql;
      }
      if (!Array.isArray(values)) {
        values = [values];
      }
      var chunkIndex = 0;
      var placeholdersRegex = /\?+/g;
      var result = "";
      var valuesIndex = 0;
      var match;
      while (valuesIndex < values.length && (match = placeholdersRegex.exec(sql))) {
        var len = match[0].length;
        if (len > 2) {
          continue;
        }
        var value = len === 2 ? SqlString2.escapeId(values[valuesIndex]) : SqlString2.escape(values[valuesIndex], stringifyObjects, timeZone);
        result += sql.slice(chunkIndex, match.index) + value;
        chunkIndex = placeholdersRegex.lastIndex;
        valuesIndex++;
      }
      if (chunkIndex === 0) {
        return sql;
      }
      if (chunkIndex < sql.length) {
        return result + sql.slice(chunkIndex);
      }
      return result;
    };
    SqlString2.dateToString = function dateToString(date, timeZone) {
      var dt = new Date(date);
      if (isNaN(dt.getTime())) {
        return "NULL";
      }
      var year;
      var month;
      var day;
      var hour;
      var minute;
      var second;
      var millisecond;
      if (timeZone === "local") {
        year = dt.getFullYear();
        month = dt.getMonth() + 1;
        day = dt.getDate();
        hour = dt.getHours();
        minute = dt.getMinutes();
        second = dt.getSeconds();
        millisecond = dt.getMilliseconds();
      } else {
        var tz = convertTimezone(timeZone);
        if (tz !== false && tz !== 0) {
          dt.setTime(dt.getTime() + tz * 6e4);
        }
        year = dt.getUTCFullYear();
        month = dt.getUTCMonth() + 1;
        day = dt.getUTCDate();
        hour = dt.getUTCHours();
        minute = dt.getUTCMinutes();
        second = dt.getUTCSeconds();
        millisecond = dt.getUTCMilliseconds();
      }
      var str2 = zeroPad(year, 4) + "-" + zeroPad(month, 2) + "-" + zeroPad(day, 2) + " " + zeroPad(hour, 2) + ":" + zeroPad(minute, 2) + ":" + zeroPad(second, 2) + "." + zeroPad(millisecond, 3);
      return escapeString(str2);
    };
    SqlString2.bufferToString = function bufferToString(buffer) {
      return "X" + escapeString(buffer.toString("hex"));
    };
    SqlString2.objectToValues = function objectToValues(object, timeZone) {
      var sql = "";
      for (var key in object) {
        var val = object[key];
        if (typeof val === "function") {
          continue;
        }
        sql += (sql.length === 0 ? "" : ", ") + SqlString2.escapeId(key) + " = " + SqlString2.escape(val, true, timeZone);
      }
      return sql;
    };
    SqlString2.raw = function raw(sql) {
      if (typeof sql !== "string") {
        throw new TypeError("argument sql must be a string");
      }
      return {
        toSqlString: function toSqlString() {
          return sql;
        }
      };
    };
    function escapeString(val) {
      var chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
      var escapedVal = "";
      var match;
      while (match = CHARS_GLOBAL_REGEXP.exec(val)) {
        escapedVal += val.slice(chunkIndex, match.index) + CHARS_ESCAPE_MAP[match[0]];
        chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
      }
      if (chunkIndex === 0) {
        return "'" + val + "'";
      }
      if (chunkIndex < val.length) {
        return "'" + escapedVal + val.slice(chunkIndex) + "'";
      }
      return "'" + escapedVal + "'";
    }
    function zeroPad(number, length) {
      number = number.toString();
      while (number.length < length) {
        number = "0" + number;
      }
      return number;
    }
    function convertTimezone(tz) {
      if (tz === "Z") {
        return 0;
      }
      var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
      if (m) {
        return (m[1] === "-" ? -1 : 1) * (parseInt(m[2], 10) + (m[3] ? parseInt(m[3], 10) : 0) / 60) * 60;
      }
      return false;
    }
  })(SqlString);
  return SqlString;
}
var sqlstring;
var hasRequiredSqlstring;
function requireSqlstring() {
  if (hasRequiredSqlstring) return sqlstring;
  hasRequiredSqlstring = 1;
  sqlstring = requireSqlString();
  return sqlstring;
}
var lib$3 = {};
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$3;
  hasRequiredLib$2 = 1;
  Object.defineProperty(lib$3, "__esModule", { value: true });
  lib$3.createLRU = void 0;
  const createLRU = (options) => {
    let { max } = options;
    if (!(Number.isInteger(max) && max > 0))
      throw new TypeError("`max` must be a positive integer");
    let size = 0;
    let head = 0;
    let tail = 0;
    let free = [];
    const { onEviction } = options;
    const keyMap = /* @__PURE__ */ new Map();
    const keyList = new Array(max).fill(void 0);
    const valList = new Array(max).fill(void 0);
    const next = new Array(max).fill(0);
    const prev = new Array(max).fill(0);
    const linkTail = (index) => {
      next[tail] = index;
      prev[index] = tail;
      next[index] = 0;
      tail = index;
    };
    const moveToTail = (index) => {
      if (index === tail)
        return;
      const nextIndex = next[index];
      const prevIndex = prev[index];
      if (index === head)
        head = nextIndex;
      else
        next[prevIndex] = nextIndex;
      prev[nextIndex] = prevIndex;
      linkTail(index);
    };
    const _shrink = (newMax) => {
      let current = tail;
      const preserve = Math.min(size, newMax);
      const remove = size - preserve;
      const newKeyList = new Array(preserve);
      const newValList = new Array(preserve);
      for (let i = 0; i < remove; i++) {
        const key = keyList[head];
        onEviction === null || onEviction === void 0 ? void 0 : onEviction(key, valList[head]);
        keyMap.delete(key);
        head = next[head];
      }
      for (let i = preserve - 1; i >= 0; i--) {
        newKeyList[i] = keyList[current];
        newValList[i] = valList[current];
        keyMap.set(keyList[current], i);
        current = prev[current];
      }
      head = 0;
      tail = preserve - 1;
      size = preserve;
      keyList.length = newMax;
      valList.length = newMax;
      next.length = newMax;
      prev.length = newMax;
      for (let i = 0; i < preserve; i++) {
        keyList[i] = newKeyList[i];
        valList[i] = newValList[i];
        next[i] = i + 1;
        prev[i] = i - 1;
      }
      free = [];
      for (let i = preserve; i < newMax; i++)
        free.push(i);
    };
    const _grow = (newMax) => {
      keyList.length = newMax;
      valList.length = newMax;
      next.length = newMax;
      prev.length = newMax;
      keyList.fill(void 0, max);
      valList.fill(void 0, max);
      next.fill(0, max);
      prev.fill(0, max);
    };
    return {
      /** Adds a key-value pair to the cache. Updates the value if the key already exists. */
      set(key, value) {
        if (key === void 0)
          return;
        let index = keyMap.get(key);
        if (index === void 0) {
          if (size === max) {
            index = head;
            const evictKey = keyList[index];
            onEviction === null || onEviction === void 0 ? void 0 : onEviction(evictKey, valList[index]);
            keyMap.delete(evictKey);
            head = next[index];
            prev[head] = 0;
          } else {
            index = free.length > 0 ? free.pop() : size;
            size++;
          }
          keyMap.set(key, index);
          keyList[index] = key;
          valList[index] = value;
          if (size === 1)
            head = tail = index;
          else
            linkTail(index);
        } else {
          onEviction === null || onEviction === void 0 ? void 0 : onEviction(key, valList[index]);
          valList[index] = value;
          moveToTail(index);
        }
      },
      /** Retrieves the value for a given key and moves the key to the most recent position. */
      get(key) {
        const index = keyMap.get(key);
        if (index === void 0)
          return;
        if (index !== tail)
          moveToTail(index);
        return valList[index];
      },
      /** Retrieves the value for a given key without changing its position. */
      peek: (key) => {
        const index = keyMap.get(key);
        return index !== void 0 ? valList[index] : void 0;
      },
      /** Checks if a key exists in the cache. */
      has: (key) => keyMap.has(key),
      /** Iterates over all keys in the cache, from most recent to least recent. */
      *keys() {
        let current = tail;
        for (let i = 0; i < size; i++) {
          yield keyList[current];
          current = prev[current];
        }
      },
      /** Iterates over all values in the cache, from most recent to least recent. */
      *values() {
        let current = tail;
        for (let i = 0; i < size; i++) {
          yield valList[current];
          current = prev[current];
        }
      },
      /** Iterates over `[key, value]` pairs in the cache, from most recent to least recent. */
      *entries() {
        let current = tail;
        for (let i = 0; i < size; i++) {
          yield [keyList[current], valList[current]];
          current = prev[current];
        }
      },
      /** Iterates over each value-key pair in the cache, from most recent to least recent. */
      forEach: (callback) => {
        let current = tail;
        for (let i = 0; i < size; i++) {
          const key = keyList[current];
          const value = valList[current];
          callback(value, key);
          current = prev[current];
        }
      },
      /** Deletes a key-value pair from the cache. */
      delete(key) {
        const index = keyMap.get(key);
        if (index === void 0)
          return false;
        onEviction === null || onEviction === void 0 ? void 0 : onEviction(key, valList[index]);
        keyMap.delete(key);
        free.push(index);
        keyList[index] = void 0;
        valList[index] = void 0;
        const prevIndex = prev[index];
        const nextIndex = next[index];
        if (index === head)
          head = nextIndex;
        else
          next[prevIndex] = nextIndex;
        if (index === tail)
          tail = prevIndex;
        else
          prev[nextIndex] = prevIndex;
        size--;
        return true;
      },
      /** Evicts the oldest item or the specified number of the oldest items from the cache. */
      evict: (number) => {
        let toPrune = Math.min(number, size);
        while (toPrune > 0) {
          const evictHead = head;
          const key = keyList[evictHead];
          onEviction === null || onEviction === void 0 ? void 0 : onEviction(key, valList[evictHead]);
          keyMap.delete(key);
          keyList[evictHead] = void 0;
          valList[evictHead] = void 0;
          head = next[evictHead];
          prev[head] = 0;
          size--;
          free.push(evictHead);
          toPrune--;
        }
        if (size === 0)
          head = tail = 0;
      },
      /** Clears all key-value pairs from the cache. */
      clear() {
        if (onEviction) {
          let current = head;
          for (let i = 0; i < size; i++) {
            onEviction(keyList[current], valList[current]);
            current = next[current];
          }
        }
        keyMap.clear();
        keyList.fill(void 0);
        valList.fill(void 0);
        free = [];
        size = 0;
        head = tail = 0;
      },
      /** Resizes the cache to a new maximum size, evicting items if necessary. */
      resize: (newMax) => {
        if (!(Number.isInteger(newMax) && newMax > 0))
          throw new TypeError("`max` must be a positive integer");
        if (newMax === max)
          return;
        if (newMax < max)
          _shrink(newMax);
        else
          _grow(newMax);
        max = newMax;
      },
      /** Returns the maximum number of items that can be stored in the cache. */
      get max() {
        return max;
      },
      /** Returns the number of items currently stored in the cache. */
      get size() {
        return size;
      },
      /** Returns the number of currently available slots in the cache before reaching the maximum size. */
      get available() {
        return max - size;
      }
    };
  };
  lib$3.createLRU = createLRU;
  return lib$3;
}
var parser_cache;
var hasRequiredParser_cache;
function requireParser_cache() {
  if (hasRequiredParser_cache) return parser_cache;
  hasRequiredParser_cache = 1;
  const { createLRU } = requireLib$2();
  const parserCache = createLRU({
    max: 15e3
  });
  function keyFromFields(type2, fields, options, config) {
    const res = [
      type2,
      typeof options.nestTables,
      options.nestTables,
      Boolean(options.rowsAsArray),
      Boolean(options.supportBigNumbers || config.supportBigNumbers),
      Boolean(options.bigNumberStrings || config.bigNumberStrings),
      typeof options.typeCast === "boolean" ? options.typeCast : typeof options.typeCast,
      options.timezone || config.timezone,
      Boolean(options.decimalNumbers),
      options.dateStrings
    ];
    for (let i = 0; i < fields.length; ++i) {
      const field = fields[i];
      res.push([
        field.name,
        field.columnType,
        field.length,
        field.schema,
        field.table,
        field.flags,
        field.characterSet
      ]);
    }
    return JSON.stringify(res, null, 0);
  }
  function getParser(type2, fields, options, config, compiler) {
    const key = keyFromFields(type2, fields, options, config);
    let parser = parserCache.get(key);
    if (parser) {
      return parser;
    }
    parser = compiler(fields, options, config);
    parserCache.set(key, parser);
    return parser;
  }
  function setMaxCache(max) {
    parserCache.resize(max);
  }
  function clearCache() {
    parserCache.clear();
  }
  parser_cache = {
    getParser,
    setMaxCache,
    clearCache,
    _keyFromFields: keyFromFields
  };
  return parser_cache;
}
var denque;
var hasRequiredDenque;
function requireDenque() {
  if (hasRequiredDenque) return denque;
  hasRequiredDenque = 1;
  function Denque(array, options) {
    var options = options || {};
    this._capacity = options.capacity;
    this._head = 0;
    this._tail = 0;
    if (Array.isArray(array)) {
      this._fromArray(array);
    } else {
      this._capacityMask = 3;
      this._list = new Array(4);
    }
  }
  Denque.prototype.peekAt = function peekAt(index) {
    var i = index;
    if (i !== (i | 0)) {
      return void 0;
    }
    var len = this.size();
    if (i >= len || i < -len) return void 0;
    if (i < 0) i += len;
    i = this._head + i & this._capacityMask;
    return this._list[i];
  };
  Denque.prototype.get = function get(i) {
    return this.peekAt(i);
  };
  Denque.prototype.peek = function peek() {
    if (this._head === this._tail) return void 0;
    return this._list[this._head];
  };
  Denque.prototype.peekFront = function peekFront() {
    return this.peek();
  };
  Denque.prototype.peekBack = function peekBack() {
    return this.peekAt(-1);
  };
  Object.defineProperty(Denque.prototype, "length", {
    get: function length() {
      return this.size();
    }
  });
  Denque.prototype.size = function size() {
    if (this._head === this._tail) return 0;
    if (this._head < this._tail) return this._tail - this._head;
    else return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.unshift = function unshift(item) {
    if (arguments.length === 0) return this.size();
    var len = this._list.length;
    this._head = this._head - 1 + len & this._capacityMask;
    this._list[this._head] = item;
    if (this._tail === this._head) this._growArray();
    if (this._capacity && this.size() > this._capacity) this.pop();
    if (this._head < this._tail) return this._tail - this._head;
    else return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.shift = function shift() {
    var head = this._head;
    if (head === this._tail) return void 0;
    var item = this._list[head];
    this._list[head] = void 0;
    this._head = head + 1 & this._capacityMask;
    if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2) this._shrinkArray();
    return item;
  };
  Denque.prototype.push = function push(item) {
    if (arguments.length === 0) return this.size();
    var tail = this._tail;
    this._list[tail] = item;
    this._tail = tail + 1 & this._capacityMask;
    if (this._tail === this._head) {
      this._growArray();
    }
    if (this._capacity && this.size() > this._capacity) {
      this.shift();
    }
    if (this._head < this._tail) return this._tail - this._head;
    else return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.pop = function pop() {
    var tail = this._tail;
    if (tail === this._head) return void 0;
    var len = this._list.length;
    this._tail = tail - 1 + len & this._capacityMask;
    var item = this._list[this._tail];
    this._list[this._tail] = void 0;
    if (this._head < 2 && tail > 1e4 && tail <= len >>> 2) this._shrinkArray();
    return item;
  };
  Denque.prototype.removeOne = function removeOne(index) {
    var i = index;
    if (i !== (i | 0)) {
      return void 0;
    }
    if (this._head === this._tail) return void 0;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size) return void 0;
    if (i < 0) i += size;
    i = this._head + i & this._capacityMask;
    var item = this._list[i];
    var k;
    if (index < size / 2) {
      for (k = index; k > 0; k--) {
        this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
      }
      this._list[i] = void 0;
      this._head = this._head + 1 + len & this._capacityMask;
    } else {
      for (k = size - 1 - index; k > 0; k--) {
        this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
      }
      this._list[i] = void 0;
      this._tail = this._tail - 1 + len & this._capacityMask;
    }
    return item;
  };
  Denque.prototype.remove = function remove(index, count) {
    var i = index;
    var removed;
    var del_count = count;
    if (i !== (i | 0)) {
      return void 0;
    }
    if (this._head === this._tail) return void 0;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size || count < 1) return void 0;
    if (i < 0) i += size;
    if (count === 1 || !count) {
      removed = new Array(1);
      removed[0] = this.removeOne(i);
      return removed;
    }
    if (i === 0 && i + count >= size) {
      removed = this.toArray();
      this.clear();
      return removed;
    }
    if (i + count > size) count = size - i;
    var k;
    removed = new Array(count);
    for (k = 0; k < count; k++) {
      removed[k] = this._list[this._head + i + k & this._capacityMask];
    }
    i = this._head + i & this._capacityMask;
    if (index + count === size) {
      this._tail = this._tail - count + len & this._capacityMask;
      for (k = count; k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = void 0;
      }
      return removed;
    }
    if (index === 0) {
      this._head = this._head + count + len & this._capacityMask;
      for (k = count - 1; k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = void 0;
      }
      return removed;
    }
    if (i < size / 2) {
      this._head = this._head + index + count + len & this._capacityMask;
      for (k = index; k > 0; k--) {
        this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
      }
      i = this._head - 1 + len & this._capacityMask;
      while (del_count > 0) {
        this._list[i = i - 1 + len & this._capacityMask] = void 0;
        del_count--;
      }
      if (index < 0) this._tail = i;
    } else {
      this._tail = i;
      i = i + count + len & this._capacityMask;
      for (k = size - (count + index); k > 0; k--) {
        this.push(this._list[i++]);
      }
      i = this._tail;
      while (del_count > 0) {
        this._list[i = i + 1 + len & this._capacityMask] = void 0;
        del_count--;
      }
    }
    if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2) this._shrinkArray();
    return removed;
  };
  Denque.prototype.splice = function splice(index, count) {
    var i = index;
    if (i !== (i | 0)) {
      return void 0;
    }
    var size = this.size();
    if (i < 0) i += size;
    if (i > size) return void 0;
    if (arguments.length > 2) {
      var k;
      var temp;
      var removed;
      var arg_len = arguments.length;
      var len = this._list.length;
      var arguments_index = 2;
      if (!size || i < size / 2) {
        temp = new Array(i);
        for (k = 0; k < i; k++) {
          temp[k] = this._list[this._head + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i > 0) {
            this._head = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._head = this._head + i + len & this._capacityMask;
        }
        while (arg_len > arguments_index) {
          this.unshift(arguments[--arg_len]);
        }
        for (k = i; k > 0; k--) {
          this.unshift(temp[k - 1]);
        }
      } else {
        temp = new Array(size - (i + count));
        var leng = temp.length;
        for (k = 0; k < leng; k++) {
          temp[k] = this._list[this._head + i + count + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i != size) {
            this._tail = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._tail = this._tail - leng + len & this._capacityMask;
        }
        while (arguments_index < arg_len) {
          this.push(arguments[arguments_index++]);
        }
        for (k = 0; k < leng; k++) {
          this.push(temp[k]);
        }
      }
      return removed;
    } else {
      return this.remove(i, count);
    }
  };
  Denque.prototype.clear = function clear() {
    this._list = new Array(this._list.length);
    this._head = 0;
    this._tail = 0;
  };
  Denque.prototype.isEmpty = function isEmpty() {
    return this._head === this._tail;
  };
  Denque.prototype.toArray = function toArray() {
    return this._copyArray(false);
  };
  Denque.prototype._fromArray = function _fromArray(array) {
    var length = array.length;
    var capacity = this._nextPowerOf2(length);
    this._list = new Array(capacity);
    this._capacityMask = capacity - 1;
    this._tail = length;
    for (var i = 0; i < length; i++) this._list[i] = array[i];
  };
  Denque.prototype._copyArray = function _copyArray(fullCopy, size) {
    var src2 = this._list;
    var capacity = src2.length;
    var length = this.length;
    size = size | length;
    if (size == length && this._head < this._tail) {
      return this._list.slice(this._head, this._tail);
    }
    var dest = new Array(size);
    var k = 0;
    var i;
    if (fullCopy || this._head > this._tail) {
      for (i = this._head; i < capacity; i++) dest[k++] = src2[i];
      for (i = 0; i < this._tail; i++) dest[k++] = src2[i];
    } else {
      for (i = this._head; i < this._tail; i++) dest[k++] = src2[i];
    }
    return dest;
  };
  Denque.prototype._growArray = function _growArray() {
    if (this._head != 0) {
      var newList = this._copyArray(true, this._list.length << 1);
      this._tail = this._list.length;
      this._head = 0;
      this._list = newList;
    } else {
      this._tail = this._list.length;
      this._list.length <<= 1;
    }
    this._capacityMask = this._capacityMask << 1 | 1;
  };
  Denque.prototype._shrinkArray = function _shrinkArray() {
    this._list.length >>>= 1;
    this._capacityMask >>>= 1;
  };
  Denque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
    var log2 = Math.log(num) / Math.log(2);
    var nextPow2 = 1 << log2 + 1;
    return Math.max(nextPow2, 4);
  };
  denque = Denque;
  return denque;
}
var errors = {};
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  (function(exports$1) {
    exports$1.EE_CANTCREATEFILE = 1;
    exports$1.EE_READ = 2;
    exports$1.EE_WRITE = 3;
    exports$1.EE_BADCLOSE = 4;
    exports$1.EE_OUTOFMEMORY = 5;
    exports$1.EE_DELETE = 6;
    exports$1.EE_LINK = 7;
    exports$1.EE_EOFERR = 9;
    exports$1.EE_CANTLOCK = 10;
    exports$1.EE_CANTUNLOCK = 11;
    exports$1.EE_DIR = 12;
    exports$1.EE_STAT = 13;
    exports$1.EE_CANT_CHSIZE = 14;
    exports$1.EE_CANT_OPEN_STREAM = 15;
    exports$1.EE_GETWD = 16;
    exports$1.EE_SETWD = 17;
    exports$1.EE_LINK_WARNING = 18;
    exports$1.EE_OPEN_WARNING = 19;
    exports$1.EE_DISK_FULL = 20;
    exports$1.EE_CANT_MKDIR = 21;
    exports$1.EE_UNKNOWN_CHARSET = 22;
    exports$1.EE_OUT_OF_FILERESOURCES = 23;
    exports$1.EE_CANT_READLINK = 24;
    exports$1.EE_CANT_SYMLINK = 25;
    exports$1.EE_REALPATH = 26;
    exports$1.EE_SYNC = 27;
    exports$1.EE_UNKNOWN_COLLATION = 28;
    exports$1.EE_FILENOTFOUND = 29;
    exports$1.EE_FILE_NOT_CLOSED = 30;
    exports$1.EE_CHANGE_OWNERSHIP = 31;
    exports$1.EE_CHANGE_PERMISSIONS = 32;
    exports$1.EE_CANT_SEEK = 33;
    exports$1.EE_CAPACITY_EXCEEDED = 34;
    exports$1.EE_DISK_FULL_WITH_RETRY_MSG = 35;
    exports$1.EE_FAILED_TO_CREATE_TIMER = 36;
    exports$1.EE_FAILED_TO_DELETE_TIMER = 37;
    exports$1.EE_FAILED_TO_CREATE_TIMER_QUEUE = 38;
    exports$1.EE_FAILED_TO_START_TIMER_NOTIFY_THREAD = 39;
    exports$1.EE_FAILED_TO_CREATE_TIMER_NOTIFY_THREAD_INTERRUPT_EVENT = 40;
    exports$1.EE_EXITING_TIMER_NOTIFY_THREAD = 41;
    exports$1.EE_WIN_LIBRARY_LOAD_FAILED = 42;
    exports$1.EE_WIN_RUN_TIME_ERROR_CHECK = 43;
    exports$1.EE_FAILED_TO_DETERMINE_LARGE_PAGE_SIZE = 44;
    exports$1.EE_FAILED_TO_KILL_ALL_THREADS = 45;
    exports$1.EE_FAILED_TO_CREATE_IO_COMPLETION_PORT = 46;
    exports$1.EE_FAILED_TO_OPEN_DEFAULTS_FILE = 47;
    exports$1.EE_FAILED_TO_HANDLE_DEFAULTS_FILE = 48;
    exports$1.EE_WRONG_DIRECTIVE_IN_CONFIG_FILE = 49;
    exports$1.EE_SKIPPING_DIRECTIVE_DUE_TO_MAX_INCLUDE_RECURSION = 50;
    exports$1.EE_INCORRECT_GRP_DEFINITION_IN_CONFIG_FILE = 51;
    exports$1.EE_OPTION_WITHOUT_GRP_IN_CONFIG_FILE = 52;
    exports$1.EE_CONFIG_FILE_PERMISSION_ERROR = 53;
    exports$1.EE_IGNORE_WORLD_WRITABLE_CONFIG_FILE = 54;
    exports$1.EE_USING_DISABLED_OPTION = 55;
    exports$1.EE_USING_DISABLED_SHORT_OPTION = 56;
    exports$1.EE_USING_PASSWORD_ON_CLI_IS_INSECURE = 57;
    exports$1.EE_UNKNOWN_SUFFIX_FOR_VARIABLE = 58;
    exports$1.EE_SSL_ERROR_FROM_FILE = 59;
    exports$1.EE_SSL_ERROR = 60;
    exports$1.EE_NET_SEND_ERROR_IN_BOOTSTRAP = 61;
    exports$1.EE_PACKETS_OUT_OF_ORDER = 62;
    exports$1.EE_UNKNOWN_PROTOCOL_OPTION = 63;
    exports$1.EE_FAILED_TO_LOCATE_SERVER_PUBLIC_KEY = 64;
    exports$1.EE_PUBLIC_KEY_NOT_IN_PEM_FORMAT = 65;
    exports$1.EE_DEBUG_INFO = 66;
    exports$1.EE_UNKNOWN_VARIABLE = 67;
    exports$1.EE_UNKNOWN_OPTION = 68;
    exports$1.EE_UNKNOWN_SHORT_OPTION = 69;
    exports$1.EE_OPTION_WITHOUT_ARGUMENT = 70;
    exports$1.EE_OPTION_REQUIRES_ARGUMENT = 71;
    exports$1.EE_SHORT_OPTION_REQUIRES_ARGUMENT = 72;
    exports$1.EE_OPTION_IGNORED_DUE_TO_INVALID_VALUE = 73;
    exports$1.EE_OPTION_WITH_EMPTY_VALUE = 74;
    exports$1.EE_FAILED_TO_ASSIGN_MAX_VALUE_TO_OPTION = 75;
    exports$1.EE_INCORRECT_BOOLEAN_VALUE_FOR_OPTION = 76;
    exports$1.EE_FAILED_TO_SET_OPTION_VALUE = 77;
    exports$1.EE_INCORRECT_INT_VALUE_FOR_OPTION = 78;
    exports$1.EE_INCORRECT_UINT_VALUE_FOR_OPTION = 79;
    exports$1.EE_ADJUSTED_SIGNED_VALUE_FOR_OPTION = 80;
    exports$1.EE_ADJUSTED_UNSIGNED_VALUE_FOR_OPTION = 81;
    exports$1.EE_ADJUSTED_ULONGLONG_VALUE_FOR_OPTION = 82;
    exports$1.EE_ADJUSTED_DOUBLE_VALUE_FOR_OPTION = 83;
    exports$1.EE_INVALID_DECIMAL_VALUE_FOR_OPTION = 84;
    exports$1.EE_COLLATION_PARSER_ERROR = 85;
    exports$1.EE_FAILED_TO_RESET_BEFORE_PRIMARY_IGNORABLE_CHAR = 86;
    exports$1.EE_FAILED_TO_RESET_BEFORE_TERTIARY_IGNORABLE_CHAR = 87;
    exports$1.EE_SHIFT_CHAR_OUT_OF_RANGE = 88;
    exports$1.EE_RESET_CHAR_OUT_OF_RANGE = 89;
    exports$1.EE_UNKNOWN_LDML_TAG = 90;
    exports$1.EE_FAILED_TO_RESET_BEFORE_SECONDARY_IGNORABLE_CHAR = 91;
    exports$1.EE_FAILED_PROCESSING_DIRECTIVE = 92;
    exports$1.EE_PTHREAD_KILL_FAILED = 93;
    exports$1.HA_ERR_KEY_NOT_FOUND = 120;
    exports$1.HA_ERR_FOUND_DUPP_KEY = 121;
    exports$1.HA_ERR_INTERNAL_ERROR = 122;
    exports$1.HA_ERR_RECORD_CHANGED = 123;
    exports$1.HA_ERR_WRONG_INDEX = 124;
    exports$1.HA_ERR_ROLLED_BACK = 125;
    exports$1.HA_ERR_CRASHED = 126;
    exports$1.HA_ERR_WRONG_IN_RECORD = 127;
    exports$1.HA_ERR_OUT_OF_MEM = 128;
    exports$1.HA_ERR_NOT_A_TABLE = 130;
    exports$1.HA_ERR_WRONG_COMMAND = 131;
    exports$1.HA_ERR_OLD_FILE = 132;
    exports$1.HA_ERR_NO_ACTIVE_RECORD = 133;
    exports$1.HA_ERR_RECORD_DELETED = 134;
    exports$1.HA_ERR_RECORD_FILE_FULL = 135;
    exports$1.HA_ERR_INDEX_FILE_FULL = 136;
    exports$1.HA_ERR_END_OF_FILE = 137;
    exports$1.HA_ERR_UNSUPPORTED = 138;
    exports$1.HA_ERR_TOO_BIG_ROW = 139;
    exports$1.HA_WRONG_CREATE_OPTION = 140;
    exports$1.HA_ERR_FOUND_DUPP_UNIQUE = 141;
    exports$1.HA_ERR_UNKNOWN_CHARSET = 142;
    exports$1.HA_ERR_WRONG_MRG_TABLE_DEF = 143;
    exports$1.HA_ERR_CRASHED_ON_REPAIR = 144;
    exports$1.HA_ERR_CRASHED_ON_USAGE = 145;
    exports$1.HA_ERR_LOCK_WAIT_TIMEOUT = 146;
    exports$1.HA_ERR_LOCK_TABLE_FULL = 147;
    exports$1.HA_ERR_READ_ONLY_TRANSACTION = 148;
    exports$1.HA_ERR_LOCK_DEADLOCK = 149;
    exports$1.HA_ERR_CANNOT_ADD_FOREIGN = 150;
    exports$1.HA_ERR_NO_REFERENCED_ROW = 151;
    exports$1.HA_ERR_ROW_IS_REFERENCED = 152;
    exports$1.HA_ERR_NO_SAVEPOINT = 153;
    exports$1.HA_ERR_NON_UNIQUE_BLOCK_SIZE = 154;
    exports$1.HA_ERR_NO_SUCH_TABLE = 155;
    exports$1.HA_ERR_TABLE_EXIST = 156;
    exports$1.HA_ERR_NO_CONNECTION = 157;
    exports$1.HA_ERR_NULL_IN_SPATIAL = 158;
    exports$1.HA_ERR_TABLE_DEF_CHANGED = 159;
    exports$1.HA_ERR_NO_PARTITION_FOUND = 160;
    exports$1.HA_ERR_RBR_LOGGING_FAILED = 161;
    exports$1.HA_ERR_DROP_INDEX_FK = 162;
    exports$1.HA_ERR_FOREIGN_DUPLICATE_KEY = 163;
    exports$1.HA_ERR_TABLE_NEEDS_UPGRADE = 164;
    exports$1.HA_ERR_TABLE_READONLY = 165;
    exports$1.HA_ERR_AUTOINC_READ_FAILED = 166;
    exports$1.HA_ERR_AUTOINC_ERANGE = 167;
    exports$1.HA_ERR_GENERIC = 168;
    exports$1.HA_ERR_RECORD_IS_THE_SAME = 169;
    exports$1.HA_ERR_LOGGING_IMPOSSIBLE = 170;
    exports$1.HA_ERR_CORRUPT_EVENT = 171;
    exports$1.HA_ERR_NEW_FILE = 172;
    exports$1.HA_ERR_ROWS_EVENT_APPLY = 173;
    exports$1.HA_ERR_INITIALIZATION = 174;
    exports$1.HA_ERR_FILE_TOO_SHORT = 175;
    exports$1.HA_ERR_WRONG_CRC = 176;
    exports$1.HA_ERR_TOO_MANY_CONCURRENT_TRXS = 177;
    exports$1.HA_ERR_NOT_IN_LOCK_PARTITIONS = 178;
    exports$1.HA_ERR_INDEX_COL_TOO_LONG = 179;
    exports$1.HA_ERR_INDEX_CORRUPT = 180;
    exports$1.HA_ERR_UNDO_REC_TOO_BIG = 181;
    exports$1.HA_FTS_INVALID_DOCID = 182;
    exports$1.HA_ERR_TABLE_IN_FK_CHECK = 183;
    exports$1.HA_ERR_TABLESPACE_EXISTS = 184;
    exports$1.HA_ERR_TOO_MANY_FIELDS = 185;
    exports$1.HA_ERR_ROW_IN_WRONG_PARTITION = 186;
    exports$1.HA_ERR_INNODB_READ_ONLY = 187;
    exports$1.HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT = 188;
    exports$1.HA_ERR_TEMP_FILE_WRITE_FAILURE = 189;
    exports$1.HA_ERR_INNODB_FORCED_RECOVERY = 190;
    exports$1.HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE = 191;
    exports$1.HA_ERR_FK_DEPTH_EXCEEDED = 192;
    exports$1.HA_MISSING_CREATE_OPTION = 193;
    exports$1.HA_ERR_SE_OUT_OF_MEMORY = 194;
    exports$1.HA_ERR_TABLE_CORRUPT = 195;
    exports$1.HA_ERR_QUERY_INTERRUPTED = 196;
    exports$1.HA_ERR_TABLESPACE_MISSING = 197;
    exports$1.HA_ERR_TABLESPACE_IS_NOT_EMPTY = 198;
    exports$1.HA_ERR_WRONG_FILE_NAME = 199;
    exports$1.HA_ERR_NOT_ALLOWED_COMMAND = 200;
    exports$1.HA_ERR_COMPUTE_FAILED = 201;
    exports$1.HA_ERR_ROW_FORMAT_CHANGED = 202;
    exports$1.HA_ERR_NO_WAIT_LOCK = 203;
    exports$1.HA_ERR_DISK_FULL_NOWAIT = 204;
    exports$1.HA_ERR_NO_SESSION_TEMP = 205;
    exports$1.HA_ERR_WRONG_TABLE_NAME = 206;
    exports$1.HA_ERR_TOO_LONG_PATH = 207;
    exports$1.HA_ERR_SAMPLING_INIT_FAILED = 208;
    exports$1.HA_ERR_FTS_TOO_MANY_NESTED_EXP = 209;
    exports$1.ER_HASHCHK = 1e3;
    exports$1.ER_NISAMCHK = 1001;
    exports$1.ER_NO = 1002;
    exports$1.ER_YES = 1003;
    exports$1.ER_CANT_CREATE_FILE = 1004;
    exports$1.ER_CANT_CREATE_TABLE = 1005;
    exports$1.ER_CANT_CREATE_DB = 1006;
    exports$1.ER_DB_CREATE_EXISTS = 1007;
    exports$1.ER_DB_DROP_EXISTS = 1008;
    exports$1.ER_DB_DROP_DELETE = 1009;
    exports$1.ER_DB_DROP_RMDIR = 1010;
    exports$1.ER_CANT_DELETE_FILE = 1011;
    exports$1.ER_CANT_FIND_SYSTEM_REC = 1012;
    exports$1.ER_CANT_GET_STAT = 1013;
    exports$1.ER_CANT_GET_WD = 1014;
    exports$1.ER_CANT_LOCK = 1015;
    exports$1.ER_CANT_OPEN_FILE = 1016;
    exports$1.ER_FILE_NOT_FOUND = 1017;
    exports$1.ER_CANT_READ_DIR = 1018;
    exports$1.ER_CANT_SET_WD = 1019;
    exports$1.ER_CHECKREAD = 1020;
    exports$1.ER_DISK_FULL = 1021;
    exports$1.ER_DUP_KEY = 1022;
    exports$1.ER_ERROR_ON_CLOSE = 1023;
    exports$1.ER_ERROR_ON_READ = 1024;
    exports$1.ER_ERROR_ON_RENAME = 1025;
    exports$1.ER_ERROR_ON_WRITE = 1026;
    exports$1.ER_FILE_USED = 1027;
    exports$1.ER_FILSORT_ABORT = 1028;
    exports$1.ER_FORM_NOT_FOUND = 1029;
    exports$1.ER_GET_ERRNO = 1030;
    exports$1.ER_ILLEGAL_HA = 1031;
    exports$1.ER_KEY_NOT_FOUND = 1032;
    exports$1.ER_NOT_FORM_FILE = 1033;
    exports$1.ER_NOT_KEYFILE = 1034;
    exports$1.ER_OLD_KEYFILE = 1035;
    exports$1.ER_OPEN_AS_READONLY = 1036;
    exports$1.ER_OUTOFMEMORY = 1037;
    exports$1.ER_OUT_OF_SORTMEMORY = 1038;
    exports$1.ER_UNEXPECTED_EOF = 1039;
    exports$1.ER_CON_COUNT_ERROR = 1040;
    exports$1.ER_OUT_OF_RESOURCES = 1041;
    exports$1.ER_BAD_HOST_ERROR = 1042;
    exports$1.ER_HANDSHAKE_ERROR = 1043;
    exports$1.ER_DBACCESS_DENIED_ERROR = 1044;
    exports$1.ER_ACCESS_DENIED_ERROR = 1045;
    exports$1.ER_NO_DB_ERROR = 1046;
    exports$1.ER_UNKNOWN_COM_ERROR = 1047;
    exports$1.ER_BAD_NULL_ERROR = 1048;
    exports$1.ER_BAD_DB_ERROR = 1049;
    exports$1.ER_TABLE_EXISTS_ERROR = 1050;
    exports$1.ER_BAD_TABLE_ERROR = 1051;
    exports$1.ER_NON_UNIQ_ERROR = 1052;
    exports$1.ER_SERVER_SHUTDOWN = 1053;
    exports$1.ER_BAD_FIELD_ERROR = 1054;
    exports$1.ER_WRONG_FIELD_WITH_GROUP = 1055;
    exports$1.ER_WRONG_GROUP_FIELD = 1056;
    exports$1.ER_WRONG_SUM_SELECT = 1057;
    exports$1.ER_WRONG_VALUE_COUNT = 1058;
    exports$1.ER_TOO_LONG_IDENT = 1059;
    exports$1.ER_DUP_FIELDNAME = 1060;
    exports$1.ER_DUP_KEYNAME = 1061;
    exports$1.ER_DUP_ENTRY = 1062;
    exports$1.ER_WRONG_FIELD_SPEC = 1063;
    exports$1.ER_PARSE_ERROR = 1064;
    exports$1.ER_EMPTY_QUERY = 1065;
    exports$1.ER_NONUNIQ_TABLE = 1066;
    exports$1.ER_INVALID_DEFAULT = 1067;
    exports$1.ER_MULTIPLE_PRI_KEY = 1068;
    exports$1.ER_TOO_MANY_KEYS = 1069;
    exports$1.ER_TOO_MANY_KEY_PARTS = 1070;
    exports$1.ER_TOO_LONG_KEY = 1071;
    exports$1.ER_KEY_COLUMN_DOES_NOT_EXITS = 1072;
    exports$1.ER_BLOB_USED_AS_KEY = 1073;
    exports$1.ER_TOO_BIG_FIELDLENGTH = 1074;
    exports$1.ER_WRONG_AUTO_KEY = 1075;
    exports$1.ER_READY = 1076;
    exports$1.ER_NORMAL_SHUTDOWN = 1077;
    exports$1.ER_GOT_SIGNAL = 1078;
    exports$1.ER_SHUTDOWN_COMPLETE = 1079;
    exports$1.ER_FORCING_CLOSE = 1080;
    exports$1.ER_IPSOCK_ERROR = 1081;
    exports$1.ER_NO_SUCH_INDEX = 1082;
    exports$1.ER_WRONG_FIELD_TERMINATORS = 1083;
    exports$1.ER_BLOBS_AND_NO_TERMINATED = 1084;
    exports$1.ER_TEXTFILE_NOT_READABLE = 1085;
    exports$1.ER_FILE_EXISTS_ERROR = 1086;
    exports$1.ER_LOAD_INFO = 1087;
    exports$1.ER_ALTER_INFO = 1088;
    exports$1.ER_WRONG_SUB_KEY = 1089;
    exports$1.ER_CANT_REMOVE_ALL_FIELDS = 1090;
    exports$1.ER_CANT_DROP_FIELD_OR_KEY = 1091;
    exports$1.ER_INSERT_INFO = 1092;
    exports$1.ER_UPDATE_TABLE_USED = 1093;
    exports$1.ER_NO_SUCH_THREAD = 1094;
    exports$1.ER_KILL_DENIED_ERROR = 1095;
    exports$1.ER_NO_TABLES_USED = 1096;
    exports$1.ER_TOO_BIG_SET = 1097;
    exports$1.ER_NO_UNIQUE_LOGFILE = 1098;
    exports$1.ER_TABLE_NOT_LOCKED_FOR_WRITE = 1099;
    exports$1.ER_TABLE_NOT_LOCKED = 1100;
    exports$1.ER_BLOB_CANT_HAVE_DEFAULT = 1101;
    exports$1.ER_WRONG_DB_NAME = 1102;
    exports$1.ER_WRONG_TABLE_NAME = 1103;
    exports$1.ER_TOO_BIG_SELECT = 1104;
    exports$1.ER_UNKNOWN_ERROR = 1105;
    exports$1.ER_UNKNOWN_PROCEDURE = 1106;
    exports$1.ER_WRONG_PARAMCOUNT_TO_PROCEDURE = 1107;
    exports$1.ER_WRONG_PARAMETERS_TO_PROCEDURE = 1108;
    exports$1.ER_UNKNOWN_TABLE = 1109;
    exports$1.ER_FIELD_SPECIFIED_TWICE = 1110;
    exports$1.ER_INVALID_GROUP_FUNC_USE = 1111;
    exports$1.ER_UNSUPPORTED_EXTENSION = 1112;
    exports$1.ER_TABLE_MUST_HAVE_COLUMNS = 1113;
    exports$1.ER_RECORD_FILE_FULL = 1114;
    exports$1.ER_UNKNOWN_CHARACTER_SET = 1115;
    exports$1.ER_TOO_MANY_TABLES = 1116;
    exports$1.ER_TOO_MANY_FIELDS = 1117;
    exports$1.ER_TOO_BIG_ROWSIZE = 1118;
    exports$1.ER_STACK_OVERRUN = 1119;
    exports$1.ER_WRONG_OUTER_JOIN = 1120;
    exports$1.ER_NULL_COLUMN_IN_INDEX = 1121;
    exports$1.ER_CANT_FIND_UDF = 1122;
    exports$1.ER_CANT_INITIALIZE_UDF = 1123;
    exports$1.ER_UDF_NO_PATHS = 1124;
    exports$1.ER_UDF_EXISTS = 1125;
    exports$1.ER_CANT_OPEN_LIBRARY = 1126;
    exports$1.ER_CANT_FIND_DL_ENTRY = 1127;
    exports$1.ER_FUNCTION_NOT_DEFINED = 1128;
    exports$1.ER_HOST_IS_BLOCKED = 1129;
    exports$1.ER_HOST_NOT_PRIVILEGED = 1130;
    exports$1.ER_PASSWORD_ANONYMOUS_USER = 1131;
    exports$1.ER_PASSWORD_NOT_ALLOWED = 1132;
    exports$1.ER_PASSWORD_NO_MATCH = 1133;
    exports$1.ER_UPDATE_INFO = 1134;
    exports$1.ER_CANT_CREATE_THREAD = 1135;
    exports$1.ER_WRONG_VALUE_COUNT_ON_ROW = 1136;
    exports$1.ER_CANT_REOPEN_TABLE = 1137;
    exports$1.ER_INVALID_USE_OF_NULL = 1138;
    exports$1.ER_REGEXP_ERROR = 1139;
    exports$1.ER_MIX_OF_GROUP_FUNC_AND_FIELDS = 1140;
    exports$1.ER_NONEXISTING_GRANT = 1141;
    exports$1.ER_TABLEACCESS_DENIED_ERROR = 1142;
    exports$1.ER_COLUMNACCESS_DENIED_ERROR = 1143;
    exports$1.ER_ILLEGAL_GRANT_FOR_TABLE = 1144;
    exports$1.ER_GRANT_WRONG_HOST_OR_USER = 1145;
    exports$1.ER_NO_SUCH_TABLE = 1146;
    exports$1.ER_NONEXISTING_TABLE_GRANT = 1147;
    exports$1.ER_NOT_ALLOWED_COMMAND = 1148;
    exports$1.ER_SYNTAX_ERROR = 1149;
    exports$1.ER_UNUSED1 = 1150;
    exports$1.ER_UNUSED2 = 1151;
    exports$1.ER_ABORTING_CONNECTION = 1152;
    exports$1.ER_NET_PACKET_TOO_LARGE = 1153;
    exports$1.ER_NET_READ_ERROR_FROM_PIPE = 1154;
    exports$1.ER_NET_FCNTL_ERROR = 1155;
    exports$1.ER_NET_PACKETS_OUT_OF_ORDER = 1156;
    exports$1.ER_NET_UNCOMPRESS_ERROR = 1157;
    exports$1.ER_NET_READ_ERROR = 1158;
    exports$1.ER_NET_READ_INTERRUPTED = 1159;
    exports$1.ER_NET_ERROR_ON_WRITE = 1160;
    exports$1.ER_NET_WRITE_INTERRUPTED = 1161;
    exports$1.ER_TOO_LONG_STRING = 1162;
    exports$1.ER_TABLE_CANT_HANDLE_BLOB = 1163;
    exports$1.ER_TABLE_CANT_HANDLE_AUTO_INCREMENT = 1164;
    exports$1.ER_UNUSED3 = 1165;
    exports$1.ER_WRONG_COLUMN_NAME = 1166;
    exports$1.ER_WRONG_KEY_COLUMN = 1167;
    exports$1.ER_WRONG_MRG_TABLE = 1168;
    exports$1.ER_DUP_UNIQUE = 1169;
    exports$1.ER_BLOB_KEY_WITHOUT_LENGTH = 1170;
    exports$1.ER_PRIMARY_CANT_HAVE_NULL = 1171;
    exports$1.ER_TOO_MANY_ROWS = 1172;
    exports$1.ER_REQUIRES_PRIMARY_KEY = 1173;
    exports$1.ER_NO_RAID_COMPILED = 1174;
    exports$1.ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE = 1175;
    exports$1.ER_KEY_DOES_NOT_EXITS = 1176;
    exports$1.ER_CHECK_NO_SUCH_TABLE = 1177;
    exports$1.ER_CHECK_NOT_IMPLEMENTED = 1178;
    exports$1.ER_CANT_DO_THIS_DURING_AN_TRANSACTION = 1179;
    exports$1.ER_ERROR_DURING_COMMIT = 1180;
    exports$1.ER_ERROR_DURING_ROLLBACK = 1181;
    exports$1.ER_ERROR_DURING_FLUSH_LOGS = 1182;
    exports$1.ER_ERROR_DURING_CHECKPOINT = 1183;
    exports$1.ER_NEW_ABORTING_CONNECTION = 1184;
    exports$1.ER_DUMP_NOT_IMPLEMENTED = 1185;
    exports$1.ER_FLUSH_MASTER_BINLOG_CLOSED = 1186;
    exports$1.ER_INDEX_REBUILD = 1187;
    exports$1.ER_SOURCE = 1188;
    exports$1.ER_SOURCE_NET_READ = 1189;
    exports$1.ER_SOURCE_NET_WRITE = 1190;
    exports$1.ER_FT_MATCHING_KEY_NOT_FOUND = 1191;
    exports$1.ER_LOCK_OR_ACTIVE_TRANSACTION = 1192;
    exports$1.ER_UNKNOWN_SYSTEM_VARIABLE = 1193;
    exports$1.ER_CRASHED_ON_USAGE = 1194;
    exports$1.ER_CRASHED_ON_REPAIR = 1195;
    exports$1.ER_WARNING_NOT_COMPLETE_ROLLBACK = 1196;
    exports$1.ER_TRANS_CACHE_FULL = 1197;
    exports$1.ER_SLAVE_MUST_STOP = 1198;
    exports$1.ER_REPLICA_NOT_RUNNING = 1199;
    exports$1.ER_BAD_REPLICA = 1200;
    exports$1.ER_CONNECTION_METADATA = 1201;
    exports$1.ER_REPLICA_THREAD = 1202;
    exports$1.ER_TOO_MANY_USER_CONNECTIONS = 1203;
    exports$1.ER_SET_CONSTANTS_ONLY = 1204;
    exports$1.ER_LOCK_WAIT_TIMEOUT = 1205;
    exports$1.ER_LOCK_TABLE_FULL = 1206;
    exports$1.ER_READ_ONLY_TRANSACTION = 1207;
    exports$1.ER_DROP_DB_WITH_READ_LOCK = 1208;
    exports$1.ER_CREATE_DB_WITH_READ_LOCK = 1209;
    exports$1.ER_WRONG_ARGUMENTS = 1210;
    exports$1.ER_NO_PERMISSION_TO_CREATE_USER = 1211;
    exports$1.ER_UNION_TABLES_IN_DIFFERENT_DIR = 1212;
    exports$1.ER_LOCK_DEADLOCK = 1213;
    exports$1.ER_TABLE_CANT_HANDLE_FT = 1214;
    exports$1.ER_CANNOT_ADD_FOREIGN = 1215;
    exports$1.ER_NO_REFERENCED_ROW = 1216;
    exports$1.ER_ROW_IS_REFERENCED = 1217;
    exports$1.ER_CONNECT_TO_SOURCE = 1218;
    exports$1.ER_QUERY_ON_MASTER = 1219;
    exports$1.ER_ERROR_WHEN_EXECUTING_COMMAND = 1220;
    exports$1.ER_WRONG_USAGE = 1221;
    exports$1.ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT = 1222;
    exports$1.ER_CANT_UPDATE_WITH_READLOCK = 1223;
    exports$1.ER_MIXING_NOT_ALLOWED = 1224;
    exports$1.ER_DUP_ARGUMENT = 1225;
    exports$1.ER_USER_LIMIT_REACHED = 1226;
    exports$1.ER_SPECIFIC_ACCESS_DENIED_ERROR = 1227;
    exports$1.ER_LOCAL_VARIABLE = 1228;
    exports$1.ER_GLOBAL_VARIABLE = 1229;
    exports$1.ER_NO_DEFAULT = 1230;
    exports$1.ER_WRONG_VALUE_FOR_VAR = 1231;
    exports$1.ER_WRONG_TYPE_FOR_VAR = 1232;
    exports$1.ER_VAR_CANT_BE_READ = 1233;
    exports$1.ER_CANT_USE_OPTION_HERE = 1234;
    exports$1.ER_NOT_SUPPORTED_YET = 1235;
    exports$1.ER_SOURCE_FATAL_ERROR_READING_BINLOG = 1236;
    exports$1.ER_REPLICA_IGNORED_TABLE = 1237;
    exports$1.ER_INCORRECT_GLOBAL_LOCAL_VAR = 1238;
    exports$1.ER_WRONG_FK_DEF = 1239;
    exports$1.ER_KEY_REF_DO_NOT_MATCH_TABLE_REF = 1240;
    exports$1.ER_OPERAND_COLUMNS = 1241;
    exports$1.ER_SUBQUERY_NO_1_ROW = 1242;
    exports$1.ER_UNKNOWN_STMT_HANDLER = 1243;
    exports$1.ER_CORRUPT_HELP_DB = 1244;
    exports$1.ER_CYCLIC_REFERENCE = 1245;
    exports$1.ER_AUTO_CONVERT = 1246;
    exports$1.ER_ILLEGAL_REFERENCE = 1247;
    exports$1.ER_DERIVED_MUST_HAVE_ALIAS = 1248;
    exports$1.ER_SELECT_REDUCED = 1249;
    exports$1.ER_TABLENAME_NOT_ALLOWED_HERE = 1250;
    exports$1.ER_NOT_SUPPORTED_AUTH_MODE = 1251;
    exports$1.ER_SPATIAL_CANT_HAVE_NULL = 1252;
    exports$1.ER_COLLATION_CHARSET_MISMATCH = 1253;
    exports$1.ER_SLAVE_WAS_RUNNING = 1254;
    exports$1.ER_SLAVE_WAS_NOT_RUNNING = 1255;
    exports$1.ER_TOO_BIG_FOR_UNCOMPRESS = 1256;
    exports$1.ER_ZLIB_Z_MEM_ERROR = 1257;
    exports$1.ER_ZLIB_Z_BUF_ERROR = 1258;
    exports$1.ER_ZLIB_Z_DATA_ERROR = 1259;
    exports$1.ER_CUT_VALUE_GROUP_CONCAT = 1260;
    exports$1.ER_WARN_TOO_FEW_RECORDS = 1261;
    exports$1.ER_WARN_TOO_MANY_RECORDS = 1262;
    exports$1.ER_WARN_NULL_TO_NOTNULL = 1263;
    exports$1.ER_WARN_DATA_OUT_OF_RANGE = 1264;
    exports$1.WARN_DATA_TRUNCATED = 1265;
    exports$1.ER_WARN_USING_OTHER_HANDLER = 1266;
    exports$1.ER_CANT_AGGREGATE_2COLLATIONS = 1267;
    exports$1.ER_DROP_USER = 1268;
    exports$1.ER_REVOKE_GRANTS = 1269;
    exports$1.ER_CANT_AGGREGATE_3COLLATIONS = 1270;
    exports$1.ER_CANT_AGGREGATE_NCOLLATIONS = 1271;
    exports$1.ER_VARIABLE_IS_NOT_STRUCT = 1272;
    exports$1.ER_UNKNOWN_COLLATION = 1273;
    exports$1.ER_REPLICA_IGNORED_SSL_PARAMS = 1274;
    exports$1.ER_SERVER_IS_IN_SECURE_AUTH_MODE = 1275;
    exports$1.ER_WARN_FIELD_RESOLVED = 1276;
    exports$1.ER_BAD_REPLICA_UNTIL_COND = 1277;
    exports$1.ER_MISSING_SKIP_REPLICA = 1278;
    exports$1.ER_UNTIL_COND_IGNORED = 1279;
    exports$1.ER_WRONG_NAME_FOR_INDEX = 1280;
    exports$1.ER_WRONG_NAME_FOR_CATALOG = 1281;
    exports$1.ER_WARN_QC_RESIZE = 1282;
    exports$1.ER_BAD_FT_COLUMN = 1283;
    exports$1.ER_UNKNOWN_KEY_CACHE = 1284;
    exports$1.ER_WARN_HOSTNAME_WONT_WORK = 1285;
    exports$1.ER_UNKNOWN_STORAGE_ENGINE = 1286;
    exports$1.ER_WARN_DEPRECATED_SYNTAX = 1287;
    exports$1.ER_NON_UPDATABLE_TABLE = 1288;
    exports$1.ER_FEATURE_DISABLED = 1289;
    exports$1.ER_OPTION_PREVENTS_STATEMENT = 1290;
    exports$1.ER_DUPLICATED_VALUE_IN_TYPE = 1291;
    exports$1.ER_TRUNCATED_WRONG_VALUE = 1292;
    exports$1.ER_TOO_MUCH_AUTO_TIMESTAMP_COLS = 1293;
    exports$1.ER_INVALID_ON_UPDATE = 1294;
    exports$1.ER_UNSUPPORTED_PS = 1295;
    exports$1.ER_GET_ERRMSG = 1296;
    exports$1.ER_GET_TEMPORARY_ERRMSG = 1297;
    exports$1.ER_UNKNOWN_TIME_ZONE = 1298;
    exports$1.ER_WARN_INVALID_TIMESTAMP = 1299;
    exports$1.ER_INVALID_CHARACTER_STRING = 1300;
    exports$1.ER_WARN_ALLOWED_PACKET_OVERFLOWED = 1301;
    exports$1.ER_CONFLICTING_DECLARATIONS = 1302;
    exports$1.ER_SP_NO_RECURSIVE_CREATE = 1303;
    exports$1.ER_SP_ALREADY_EXISTS = 1304;
    exports$1.ER_SP_DOES_NOT_EXIST = 1305;
    exports$1.ER_SP_DROP_FAILED = 1306;
    exports$1.ER_SP_STORE_FAILED = 1307;
    exports$1.ER_SP_LILABEL_MISMATCH = 1308;
    exports$1.ER_SP_LABEL_REDEFINE = 1309;
    exports$1.ER_SP_LABEL_MISMATCH = 1310;
    exports$1.ER_SP_UNINIT_VAR = 1311;
    exports$1.ER_SP_BADSELECT = 1312;
    exports$1.ER_SP_BADRETURN = 1313;
    exports$1.ER_SP_BADSTATEMENT = 1314;
    exports$1.ER_UPDATE_LOG_DEPRECATED_IGNORED = 1315;
    exports$1.ER_UPDATE_LOG_DEPRECATED_TRANSLATED = 1316;
    exports$1.ER_QUERY_INTERRUPTED = 1317;
    exports$1.ER_SP_WRONG_NO_OF_ARGS = 1318;
    exports$1.ER_SP_COND_MISMATCH = 1319;
    exports$1.ER_SP_NORETURN = 1320;
    exports$1.ER_SP_NORETURNEND = 1321;
    exports$1.ER_SP_BAD_CURSOR_QUERY = 1322;
    exports$1.ER_SP_BAD_CURSOR_SELECT = 1323;
    exports$1.ER_SP_CURSOR_MISMATCH = 1324;
    exports$1.ER_SP_CURSOR_ALREADY_OPEN = 1325;
    exports$1.ER_SP_CURSOR_NOT_OPEN = 1326;
    exports$1.ER_SP_UNDECLARED_VAR = 1327;
    exports$1.ER_SP_WRONG_NO_OF_FETCH_ARGS = 1328;
    exports$1.ER_SP_FETCH_NO_DATA = 1329;
    exports$1.ER_SP_DUP_PARAM = 1330;
    exports$1.ER_SP_DUP_VAR = 1331;
    exports$1.ER_SP_DUP_COND = 1332;
    exports$1.ER_SP_DUP_CURS = 1333;
    exports$1.ER_SP_CANT_ALTER = 1334;
    exports$1.ER_SP_SUBSELECT_NYI = 1335;
    exports$1.ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG = 1336;
    exports$1.ER_SP_VARCOND_AFTER_CURSHNDLR = 1337;
    exports$1.ER_SP_CURSOR_AFTER_HANDLER = 1338;
    exports$1.ER_SP_CASE_NOT_FOUND = 1339;
    exports$1.ER_FPARSER_TOO_BIG_FILE = 1340;
    exports$1.ER_FPARSER_BAD_HEADER = 1341;
    exports$1.ER_FPARSER_EOF_IN_COMMENT = 1342;
    exports$1.ER_FPARSER_ERROR_IN_PARAMETER = 1343;
    exports$1.ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER = 1344;
    exports$1.ER_VIEW_NO_EXPLAIN = 1345;
    exports$1.ER_FRM_UNKNOWN_TYPE = 1346;
    exports$1.ER_WRONG_OBJECT = 1347;
    exports$1.ER_NONUPDATEABLE_COLUMN = 1348;
    exports$1.ER_VIEW_SELECT_DERIVED = 1349;
    exports$1.ER_VIEW_SELECT_CLAUSE = 1350;
    exports$1.ER_VIEW_SELECT_VARIABLE = 1351;
    exports$1.ER_VIEW_SELECT_TMPTABLE = 1352;
    exports$1.ER_VIEW_WRONG_LIST = 1353;
    exports$1.ER_WARN_VIEW_MERGE = 1354;
    exports$1.ER_WARN_VIEW_WITHOUT_KEY = 1355;
    exports$1.ER_VIEW_INVALID = 1356;
    exports$1.ER_SP_NO_DROP_SP = 1357;
    exports$1.ER_SP_GOTO_IN_HNDLR = 1358;
    exports$1.ER_TRG_ALREADY_EXISTS = 1359;
    exports$1.ER_TRG_DOES_NOT_EXIST = 1360;
    exports$1.ER_TRG_ON_VIEW_OR_TEMP_TABLE = 1361;
    exports$1.ER_TRG_CANT_CHANGE_ROW = 1362;
    exports$1.ER_TRG_NO_SUCH_ROW_IN_TRG = 1363;
    exports$1.ER_NO_DEFAULT_FOR_FIELD = 1364;
    exports$1.ER_DIVISION_BY_ZERO = 1365;
    exports$1.ER_TRUNCATED_WRONG_VALUE_FOR_FIELD = 1366;
    exports$1.ER_ILLEGAL_VALUE_FOR_TYPE = 1367;
    exports$1.ER_VIEW_NONUPD_CHECK = 1368;
    exports$1.ER_VIEW_CHECK_FAILED = 1369;
    exports$1.ER_PROCACCESS_DENIED_ERROR = 1370;
    exports$1.ER_RELAY_LOG_FAIL = 1371;
    exports$1.ER_PASSWD_LENGTH = 1372;
    exports$1.ER_UNKNOWN_TARGET_BINLOG = 1373;
    exports$1.ER_IO_ERR_LOG_INDEX_READ = 1374;
    exports$1.ER_BINLOG_PURGE_PROHIBITED = 1375;
    exports$1.ER_FSEEK_FAIL = 1376;
    exports$1.ER_BINLOG_PURGE_FATAL_ERR = 1377;
    exports$1.ER_LOG_IN_USE = 1378;
    exports$1.ER_LOG_PURGE_UNKNOWN_ERR = 1379;
    exports$1.ER_RELAY_LOG_INIT = 1380;
    exports$1.ER_NO_BINARY_LOGGING = 1381;
    exports$1.ER_RESERVED_SYNTAX = 1382;
    exports$1.ER_WSAS_FAILED = 1383;
    exports$1.ER_DIFF_GROUPS_PROC = 1384;
    exports$1.ER_NO_GROUP_FOR_PROC = 1385;
    exports$1.ER_ORDER_WITH_PROC = 1386;
    exports$1.ER_LOGGING_PROHIBIT_CHANGING_OF = 1387;
    exports$1.ER_NO_FILE_MAPPING = 1388;
    exports$1.ER_WRONG_MAGIC = 1389;
    exports$1.ER_PS_MANY_PARAM = 1390;
    exports$1.ER_KEY_PART_0 = 1391;
    exports$1.ER_VIEW_CHECKSUM = 1392;
    exports$1.ER_VIEW_MULTIUPDATE = 1393;
    exports$1.ER_VIEW_NO_INSERT_FIELD_LIST = 1394;
    exports$1.ER_VIEW_DELETE_MERGE_VIEW = 1395;
    exports$1.ER_CANNOT_USER = 1396;
    exports$1.ER_XAER_NOTA = 1397;
    exports$1.ER_XAER_INVAL = 1398;
    exports$1.ER_XAER_RMFAIL = 1399;
    exports$1.ER_XAER_OUTSIDE = 1400;
    exports$1.ER_XAER_RMERR = 1401;
    exports$1.ER_XA_RBROLLBACK = 1402;
    exports$1.ER_NONEXISTING_PROC_GRANT = 1403;
    exports$1.ER_PROC_AUTO_GRANT_FAIL = 1404;
    exports$1.ER_PROC_AUTO_REVOKE_FAIL = 1405;
    exports$1.ER_DATA_TOO_LONG = 1406;
    exports$1.ER_SP_BAD_SQLSTATE = 1407;
    exports$1.ER_STARTUP = 1408;
    exports$1.ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR = 1409;
    exports$1.ER_CANT_CREATE_USER_WITH_GRANT = 1410;
    exports$1.ER_WRONG_VALUE_FOR_TYPE = 1411;
    exports$1.ER_TABLE_DEF_CHANGED = 1412;
    exports$1.ER_SP_DUP_HANDLER = 1413;
    exports$1.ER_SP_NOT_VAR_ARG = 1414;
    exports$1.ER_SP_NO_RETSET = 1415;
    exports$1.ER_CANT_CREATE_GEOMETRY_OBJECT = 1416;
    exports$1.ER_FAILED_ROUTINE_BREAK_BINLOG = 1417;
    exports$1.ER_BINLOG_UNSAFE_ROUTINE = 1418;
    exports$1.ER_BINLOG_CREATE_ROUTINE_NEED_SUPER = 1419;
    exports$1.ER_EXEC_STMT_WITH_OPEN_CURSOR = 1420;
    exports$1.ER_STMT_HAS_NO_OPEN_CURSOR = 1421;
    exports$1.ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG = 1422;
    exports$1.ER_NO_DEFAULT_FOR_VIEW_FIELD = 1423;
    exports$1.ER_SP_NO_RECURSION = 1424;
    exports$1.ER_TOO_BIG_SCALE = 1425;
    exports$1.ER_TOO_BIG_PRECISION = 1426;
    exports$1.ER_M_BIGGER_THAN_D = 1427;
    exports$1.ER_WRONG_LOCK_OF_SYSTEM_TABLE = 1428;
    exports$1.ER_CONNECT_TO_FOREIGN_DATA_SOURCE = 1429;
    exports$1.ER_QUERY_ON_FOREIGN_DATA_SOURCE = 1430;
    exports$1.ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST = 1431;
    exports$1.ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE = 1432;
    exports$1.ER_FOREIGN_DATA_STRING_INVALID = 1433;
    exports$1.ER_CANT_CREATE_FEDERATED_TABLE = 1434;
    exports$1.ER_TRG_IN_WRONG_SCHEMA = 1435;
    exports$1.ER_STACK_OVERRUN_NEED_MORE = 1436;
    exports$1.ER_TOO_LONG_BODY = 1437;
    exports$1.ER_WARN_CANT_DROP_DEFAULT_KEYCACHE = 1438;
    exports$1.ER_TOO_BIG_DISPLAYWIDTH = 1439;
    exports$1.ER_XAER_DUPID = 1440;
    exports$1.ER_DATETIME_FUNCTION_OVERFLOW = 1441;
    exports$1.ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG = 1442;
    exports$1.ER_VIEW_PREVENT_UPDATE = 1443;
    exports$1.ER_PS_NO_RECURSION = 1444;
    exports$1.ER_SP_CANT_SET_AUTOCOMMIT = 1445;
    exports$1.ER_MALFORMED_DEFINER = 1446;
    exports$1.ER_VIEW_FRM_NO_USER = 1447;
    exports$1.ER_VIEW_OTHER_USER = 1448;
    exports$1.ER_NO_SUCH_USER = 1449;
    exports$1.ER_FORBID_SCHEMA_CHANGE = 1450;
    exports$1.ER_ROW_IS_REFERENCED_2 = 1451;
    exports$1.ER_NO_REFERENCED_ROW_2 = 1452;
    exports$1.ER_SP_BAD_VAR_SHADOW = 1453;
    exports$1.ER_TRG_NO_DEFINER = 1454;
    exports$1.ER_OLD_FILE_FORMAT = 1455;
    exports$1.ER_SP_RECURSION_LIMIT = 1456;
    exports$1.ER_SP_PROC_TABLE_CORRUPT = 1457;
    exports$1.ER_SP_WRONG_NAME = 1458;
    exports$1.ER_TABLE_NEEDS_UPGRADE = 1459;
    exports$1.ER_SP_NO_AGGREGATE = 1460;
    exports$1.ER_MAX_PREPARED_STMT_COUNT_REACHED = 1461;
    exports$1.ER_VIEW_RECURSIVE = 1462;
    exports$1.ER_NON_GROUPING_FIELD_USED = 1463;
    exports$1.ER_TABLE_CANT_HANDLE_SPKEYS = 1464;
    exports$1.ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA = 1465;
    exports$1.ER_REMOVED_SPACES = 1466;
    exports$1.ER_AUTOINC_READ_FAILED = 1467;
    exports$1.ER_USERNAME = 1468;
    exports$1.ER_HOSTNAME = 1469;
    exports$1.ER_WRONG_STRING_LENGTH = 1470;
    exports$1.ER_NON_INSERTABLE_TABLE = 1471;
    exports$1.ER_ADMIN_WRONG_MRG_TABLE = 1472;
    exports$1.ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT = 1473;
    exports$1.ER_NAME_BECOMES_EMPTY = 1474;
    exports$1.ER_AMBIGUOUS_FIELD_TERM = 1475;
    exports$1.ER_FOREIGN_SERVER_EXISTS = 1476;
    exports$1.ER_FOREIGN_SERVER_DOESNT_EXIST = 1477;
    exports$1.ER_ILLEGAL_HA_CREATE_OPTION = 1478;
    exports$1.ER_PARTITION_REQUIRES_VALUES_ERROR = 1479;
    exports$1.ER_PARTITION_WRONG_VALUES_ERROR = 1480;
    exports$1.ER_PARTITION_MAXVALUE_ERROR = 1481;
    exports$1.ER_PARTITION_SUBPARTITION_ERROR = 1482;
    exports$1.ER_PARTITION_SUBPART_MIX_ERROR = 1483;
    exports$1.ER_PARTITION_WRONG_NO_PART_ERROR = 1484;
    exports$1.ER_PARTITION_WRONG_NO_SUBPART_ERROR = 1485;
    exports$1.ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR = 1486;
    exports$1.ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR = 1487;
    exports$1.ER_FIELD_NOT_FOUND_PART_ERROR = 1488;
    exports$1.ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR = 1489;
    exports$1.ER_INCONSISTENT_PARTITION_INFO_ERROR = 1490;
    exports$1.ER_PARTITION_FUNC_NOT_ALLOWED_ERROR = 1491;
    exports$1.ER_PARTITIONS_MUST_BE_DEFINED_ERROR = 1492;
    exports$1.ER_RANGE_NOT_INCREASING_ERROR = 1493;
    exports$1.ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR = 1494;
    exports$1.ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR = 1495;
    exports$1.ER_PARTITION_ENTRY_ERROR = 1496;
    exports$1.ER_MIX_HANDLER_ERROR = 1497;
    exports$1.ER_PARTITION_NOT_DEFINED_ERROR = 1498;
    exports$1.ER_TOO_MANY_PARTITIONS_ERROR = 1499;
    exports$1.ER_SUBPARTITION_ERROR = 1500;
    exports$1.ER_CANT_CREATE_HANDLER_FILE = 1501;
    exports$1.ER_BLOB_FIELD_IN_PART_FUNC_ERROR = 1502;
    exports$1.ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF = 1503;
    exports$1.ER_NO_PARTS_ERROR = 1504;
    exports$1.ER_PARTITION_MGMT_ON_NONPARTITIONED = 1505;
    exports$1.ER_FOREIGN_KEY_ON_PARTITIONED = 1506;
    exports$1.ER_DROP_PARTITION_NON_EXISTENT = 1507;
    exports$1.ER_DROP_LAST_PARTITION = 1508;
    exports$1.ER_COALESCE_ONLY_ON_HASH_PARTITION = 1509;
    exports$1.ER_REORG_HASH_ONLY_ON_SAME_NO = 1510;
    exports$1.ER_REORG_NO_PARAM_ERROR = 1511;
    exports$1.ER_ONLY_ON_RANGE_LIST_PARTITION = 1512;
    exports$1.ER_ADD_PARTITION_SUBPART_ERROR = 1513;
    exports$1.ER_ADD_PARTITION_NO_NEW_PARTITION = 1514;
    exports$1.ER_COALESCE_PARTITION_NO_PARTITION = 1515;
    exports$1.ER_REORG_PARTITION_NOT_EXIST = 1516;
    exports$1.ER_SAME_NAME_PARTITION = 1517;
    exports$1.ER_NO_BINLOG_ERROR = 1518;
    exports$1.ER_CONSECUTIVE_REORG_PARTITIONS = 1519;
    exports$1.ER_REORG_OUTSIDE_RANGE = 1520;
    exports$1.ER_PARTITION_FUNCTION_FAILURE = 1521;
    exports$1.ER_PART_STATE_ERROR = 1522;
    exports$1.ER_LIMITED_PART_RANGE = 1523;
    exports$1.ER_PLUGIN_IS_NOT_LOADED = 1524;
    exports$1.ER_WRONG_VALUE = 1525;
    exports$1.ER_NO_PARTITION_FOR_GIVEN_VALUE = 1526;
    exports$1.ER_FILEGROUP_OPTION_ONLY_ONCE = 1527;
    exports$1.ER_CREATE_FILEGROUP_FAILED = 1528;
    exports$1.ER_DROP_FILEGROUP_FAILED = 1529;
    exports$1.ER_TABLESPACE_AUTO_EXTEND_ERROR = 1530;
    exports$1.ER_WRONG_SIZE_NUMBER = 1531;
    exports$1.ER_SIZE_OVERFLOW_ERROR = 1532;
    exports$1.ER_ALTER_FILEGROUP_FAILED = 1533;
    exports$1.ER_BINLOG_ROW_LOGGING_FAILED = 1534;
    exports$1.ER_BINLOG_ROW_WRONG_TABLE_DEF = 1535;
    exports$1.ER_BINLOG_ROW_RBR_TO_SBR = 1536;
    exports$1.ER_EVENT_ALREADY_EXISTS = 1537;
    exports$1.ER_EVENT_STORE_FAILED = 1538;
    exports$1.ER_EVENT_DOES_NOT_EXIST = 1539;
    exports$1.ER_EVENT_CANT_ALTER = 1540;
    exports$1.ER_EVENT_DROP_FAILED = 1541;
    exports$1.ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG = 1542;
    exports$1.ER_EVENT_ENDS_BEFORE_STARTS = 1543;
    exports$1.ER_EVENT_EXEC_TIME_IN_THE_PAST = 1544;
    exports$1.ER_EVENT_OPEN_TABLE_FAILED = 1545;
    exports$1.ER_EVENT_NEITHER_M_EXPR_NOR_M_AT = 1546;
    exports$1.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED = 1547;
    exports$1.ER_CANNOT_LOAD_FROM_TABLE = 1548;
    exports$1.ER_EVENT_CANNOT_DELETE = 1549;
    exports$1.ER_EVENT_COMPILE_ERROR = 1550;
    exports$1.ER_EVENT_SAME_NAME = 1551;
    exports$1.ER_EVENT_DATA_TOO_LONG = 1552;
    exports$1.ER_DROP_INDEX_FK = 1553;
    exports$1.ER_WARN_DEPRECATED_SYNTAX_WITH_VER = 1554;
    exports$1.ER_CANT_WRITE_LOCK_LOG_TABLE = 1555;
    exports$1.ER_CANT_LOCK_LOG_TABLE = 1556;
    exports$1.ER_FOREIGN_DUPLICATE_KEY = 1557;
    exports$1.ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE = 1558;
    exports$1.ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR = 1559;
    exports$1.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT = 1560;
    exports$1.ER_NDB_CANT_SWITCH_BINLOG_FORMAT = 1561;
    exports$1.ER_PARTITION_NO_TEMPORARY = 1562;
    exports$1.ER_PARTITION_CONST_DOMAIN_ERROR = 1563;
    exports$1.ER_PARTITION_FUNCTION_IS_NOT_ALLOWED = 1564;
    exports$1.ER_DDL_LOG_ERROR = 1565;
    exports$1.ER_NULL_IN_VALUES_LESS_THAN = 1566;
    exports$1.ER_WRONG_PARTITION_NAME = 1567;
    exports$1.ER_CANT_CHANGE_TX_CHARACTERISTICS = 1568;
    exports$1.ER_DUP_ENTRY_AUTOINCREMENT_CASE = 1569;
    exports$1.ER_EVENT_MODIFY_QUEUE_ERROR = 1570;
    exports$1.ER_EVENT_SET_VAR_ERROR = 1571;
    exports$1.ER_PARTITION_MERGE_ERROR = 1572;
    exports$1.ER_CANT_ACTIVATE_LOG = 1573;
    exports$1.ER_RBR_NOT_AVAILABLE = 1574;
    exports$1.ER_BASE64_DECODE_ERROR = 1575;
    exports$1.ER_EVENT_RECURSION_FORBIDDEN = 1576;
    exports$1.ER_EVENTS_DB_ERROR = 1577;
    exports$1.ER_ONLY_INTEGERS_ALLOWED = 1578;
    exports$1.ER_UNSUPORTED_LOG_ENGINE = 1579;
    exports$1.ER_BAD_LOG_STATEMENT = 1580;
    exports$1.ER_CANT_RENAME_LOG_TABLE = 1581;
    exports$1.ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT = 1582;
    exports$1.ER_WRONG_PARAMETERS_TO_NATIVE_FCT = 1583;
    exports$1.ER_WRONG_PARAMETERS_TO_STORED_FCT = 1584;
    exports$1.ER_NATIVE_FCT_NAME_COLLISION = 1585;
    exports$1.ER_DUP_ENTRY_WITH_KEY_NAME = 1586;
    exports$1.ER_BINLOG_PURGE_EMFILE = 1587;
    exports$1.ER_EVENT_CANNOT_CREATE_IN_THE_PAST = 1588;
    exports$1.ER_EVENT_CANNOT_ALTER_IN_THE_PAST = 1589;
    exports$1.ER_SLAVE_INCIDENT = 1590;
    exports$1.ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT = 1591;
    exports$1.ER_BINLOG_UNSAFE_STATEMENT = 1592;
    exports$1.ER_BINLOG_FATAL_ERROR = 1593;
    exports$1.ER_SLAVE_RELAY_LOG_READ_FAILURE = 1594;
    exports$1.ER_SLAVE_RELAY_LOG_WRITE_FAILURE = 1595;
    exports$1.ER_SLAVE_CREATE_EVENT_FAILURE = 1596;
    exports$1.ER_SLAVE_MASTER_COM_FAILURE = 1597;
    exports$1.ER_BINLOG_LOGGING_IMPOSSIBLE = 1598;
    exports$1.ER_VIEW_NO_CREATION_CTX = 1599;
    exports$1.ER_VIEW_INVALID_CREATION_CTX = 1600;
    exports$1.ER_SR_INVALID_CREATION_CTX = 1601;
    exports$1.ER_TRG_CORRUPTED_FILE = 1602;
    exports$1.ER_TRG_NO_CREATION_CTX = 1603;
    exports$1.ER_TRG_INVALID_CREATION_CTX = 1604;
    exports$1.ER_EVENT_INVALID_CREATION_CTX = 1605;
    exports$1.ER_TRG_CANT_OPEN_TABLE = 1606;
    exports$1.ER_CANT_CREATE_SROUTINE = 1607;
    exports$1.ER_NEVER_USED = 1608;
    exports$1.ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT = 1609;
    exports$1.ER_REPLICA_CORRUPT_EVENT = 1610;
    exports$1.ER_LOAD_DATA_INVALID_COLUMN = 1611;
    exports$1.ER_LOG_PURGE_NO_FILE = 1612;
    exports$1.ER_XA_RBTIMEOUT = 1613;
    exports$1.ER_XA_RBDEADLOCK = 1614;
    exports$1.ER_NEED_REPREPARE = 1615;
    exports$1.ER_DELAYED_NOT_SUPPORTED = 1616;
    exports$1.WARN_NO_CONNECTION_METADATA = 1617;
    exports$1.WARN_OPTION_IGNORED = 1618;
    exports$1.ER_PLUGIN_DELETE_BUILTIN = 1619;
    exports$1.WARN_PLUGIN_BUSY = 1620;
    exports$1.ER_VARIABLE_IS_READONLY = 1621;
    exports$1.ER_WARN_ENGINE_TRANSACTION_ROLLBACK = 1622;
    exports$1.ER_SLAVE_HEARTBEAT_FAILURE = 1623;
    exports$1.ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE = 1624;
    exports$1.ER_NDB_REPLICATION_SCHEMA_ERROR = 1625;
    exports$1.ER_CONFLICT_FN_PARSE_ERROR = 1626;
    exports$1.ER_EXCEPTIONS_WRITE_ERROR = 1627;
    exports$1.ER_TOO_LONG_TABLE_COMMENT = 1628;
    exports$1.ER_TOO_LONG_FIELD_COMMENT = 1629;
    exports$1.ER_FUNC_INEXISTENT_NAME_COLLISION = 1630;
    exports$1.ER_DATABASE_NAME = 1631;
    exports$1.ER_TABLE_NAME = 1632;
    exports$1.ER_PARTITION_NAME = 1633;
    exports$1.ER_SUBPARTITION_NAME = 1634;
    exports$1.ER_TEMPORARY_NAME = 1635;
    exports$1.ER_RENAMED_NAME = 1636;
    exports$1.ER_TOO_MANY_CONCURRENT_TRXS = 1637;
    exports$1.WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED = 1638;
    exports$1.ER_DEBUG_SYNC_TIMEOUT = 1639;
    exports$1.ER_DEBUG_SYNC_HIT_LIMIT = 1640;
    exports$1.ER_DUP_SIGNAL_SET = 1641;
    exports$1.ER_SIGNAL_WARN = 1642;
    exports$1.ER_SIGNAL_NOT_FOUND = 1643;
    exports$1.ER_SIGNAL_EXCEPTION = 1644;
    exports$1.ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER = 1645;
    exports$1.ER_SIGNAL_BAD_CONDITION_TYPE = 1646;
    exports$1.WARN_COND_ITEM_TRUNCATED = 1647;
    exports$1.ER_COND_ITEM_TOO_LONG = 1648;
    exports$1.ER_UNKNOWN_LOCALE = 1649;
    exports$1.ER_REPLICA_IGNORE_SERVER_IDS = 1650;
    exports$1.ER_QUERY_CACHE_DISABLED = 1651;
    exports$1.ER_SAME_NAME_PARTITION_FIELD = 1652;
    exports$1.ER_PARTITION_COLUMN_LIST_ERROR = 1653;
    exports$1.ER_WRONG_TYPE_COLUMN_VALUE_ERROR = 1654;
    exports$1.ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR = 1655;
    exports$1.ER_MAXVALUE_IN_VALUES_IN = 1656;
    exports$1.ER_TOO_MANY_VALUES_ERROR = 1657;
    exports$1.ER_ROW_SINGLE_PARTITION_FIELD_ERROR = 1658;
    exports$1.ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD = 1659;
    exports$1.ER_PARTITION_FIELDS_TOO_LONG = 1660;
    exports$1.ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE = 1661;
    exports$1.ER_BINLOG_ROW_MODE_AND_STMT_ENGINE = 1662;
    exports$1.ER_BINLOG_UNSAFE_AND_STMT_ENGINE = 1663;
    exports$1.ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE = 1664;
    exports$1.ER_BINLOG_STMT_MODE_AND_ROW_ENGINE = 1665;
    exports$1.ER_BINLOG_ROW_INJECTION_AND_STMT_MODE = 1666;
    exports$1.ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE = 1667;
    exports$1.ER_BINLOG_UNSAFE_LIMIT = 1668;
    exports$1.ER_UNUSED4 = 1669;
    exports$1.ER_BINLOG_UNSAFE_SYSTEM_TABLE = 1670;
    exports$1.ER_BINLOG_UNSAFE_AUTOINC_COLUMNS = 1671;
    exports$1.ER_BINLOG_UNSAFE_UDF = 1672;
    exports$1.ER_BINLOG_UNSAFE_SYSTEM_VARIABLE = 1673;
    exports$1.ER_BINLOG_UNSAFE_SYSTEM_FUNCTION = 1674;
    exports$1.ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS = 1675;
    exports$1.ER_MESSAGE_AND_STATEMENT = 1676;
    exports$1.ER_SLAVE_CONVERSION_FAILED = 1677;
    exports$1.ER_REPLICA_CANT_CREATE_CONVERSION = 1678;
    exports$1.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT = 1679;
    exports$1.ER_PATH_LENGTH = 1680;
    exports$1.ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT = 1681;
    exports$1.ER_WRONG_NATIVE_TABLE_STRUCTURE = 1682;
    exports$1.ER_WRONG_PERFSCHEMA_USAGE = 1683;
    exports$1.ER_WARN_I_S_SKIPPED_TABLE = 1684;
    exports$1.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT = 1685;
    exports$1.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT = 1686;
    exports$1.ER_SPATIAL_MUST_HAVE_GEOM_COL = 1687;
    exports$1.ER_TOO_LONG_INDEX_COMMENT = 1688;
    exports$1.ER_LOCK_ABORTED = 1689;
    exports$1.ER_DATA_OUT_OF_RANGE = 1690;
    exports$1.ER_WRONG_SPVAR_TYPE_IN_LIMIT = 1691;
    exports$1.ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE = 1692;
    exports$1.ER_BINLOG_UNSAFE_MIXED_STATEMENT = 1693;
    exports$1.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN = 1694;
    exports$1.ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN = 1695;
    exports$1.ER_FAILED_READ_FROM_PAR_FILE = 1696;
    exports$1.ER_VALUES_IS_NOT_INT_TYPE_ERROR = 1697;
    exports$1.ER_ACCESS_DENIED_NO_PASSWORD_ERROR = 1698;
    exports$1.ER_SET_PASSWORD_AUTH_PLUGIN = 1699;
    exports$1.ER_GRANT_PLUGIN_USER_EXISTS = 1700;
    exports$1.ER_TRUNCATE_ILLEGAL_FK = 1701;
    exports$1.ER_PLUGIN_IS_PERMANENT = 1702;
    exports$1.ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN = 1703;
    exports$1.ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX = 1704;
    exports$1.ER_STMT_CACHE_FULL = 1705;
    exports$1.ER_MULTI_UPDATE_KEY_CONFLICT = 1706;
    exports$1.ER_TABLE_NEEDS_REBUILD = 1707;
    exports$1.WARN_OPTION_BELOW_LIMIT = 1708;
    exports$1.ER_INDEX_COLUMN_TOO_LONG = 1709;
    exports$1.ER_ERROR_IN_TRIGGER_BODY = 1710;
    exports$1.ER_ERROR_IN_UNKNOWN_TRIGGER_BODY = 1711;
    exports$1.ER_INDEX_CORRUPT = 1712;
    exports$1.ER_UNDO_RECORD_TOO_BIG = 1713;
    exports$1.ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT = 1714;
    exports$1.ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE = 1715;
    exports$1.ER_BINLOG_UNSAFE_REPLACE_SELECT = 1716;
    exports$1.ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT = 1717;
    exports$1.ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT = 1718;
    exports$1.ER_BINLOG_UNSAFE_UPDATE_IGNORE = 1719;
    exports$1.ER_PLUGIN_NO_UNINSTALL = 1720;
    exports$1.ER_PLUGIN_NO_INSTALL = 1721;
    exports$1.ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT = 1722;
    exports$1.ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC = 1723;
    exports$1.ER_BINLOG_UNSAFE_INSERT_TWO_KEYS = 1724;
    exports$1.ER_TABLE_IN_FK_CHECK = 1725;
    exports$1.ER_UNSUPPORTED_ENGINE = 1726;
    exports$1.ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST = 1727;
    exports$1.ER_CANNOT_LOAD_FROM_TABLE_V2 = 1728;
    exports$1.ER_SOURCE_DELAY_VALUE_OUT_OF_RANGE = 1729;
    exports$1.ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT = 1730;
    exports$1.ER_PARTITION_EXCHANGE_DIFFERENT_OPTION = 1731;
    exports$1.ER_PARTITION_EXCHANGE_PART_TABLE = 1732;
    exports$1.ER_PARTITION_EXCHANGE_TEMP_TABLE = 1733;
    exports$1.ER_PARTITION_INSTEAD_OF_SUBPARTITION = 1734;
    exports$1.ER_UNKNOWN_PARTITION = 1735;
    exports$1.ER_TABLES_DIFFERENT_METADATA = 1736;
    exports$1.ER_ROW_DOES_NOT_MATCH_PARTITION = 1737;
    exports$1.ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX = 1738;
    exports$1.ER_WARN_INDEX_NOT_APPLICABLE = 1739;
    exports$1.ER_PARTITION_EXCHANGE_FOREIGN_KEY = 1740;
    exports$1.ER_NO_SUCH_KEY_VALUE = 1741;
    exports$1.ER_RPL_INFO_DATA_TOO_LONG = 1742;
    exports$1.ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE = 1743;
    exports$1.ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE = 1744;
    exports$1.ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX = 1745;
    exports$1.ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT = 1746;
    exports$1.ER_PARTITION_CLAUSE_ON_NONPARTITIONED = 1747;
    exports$1.ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET = 1748;
    exports$1.ER_NO_SUCH_PARTITION = 1749;
    exports$1.ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE = 1750;
    exports$1.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE = 1751;
    exports$1.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE = 1752;
    exports$1.ER_MTA_FEATURE_IS_NOT_SUPPORTED = 1753;
    exports$1.ER_MTA_UPDATED_DBS_GREATER_MAX = 1754;
    exports$1.ER_MTA_CANT_PARALLEL = 1755;
    exports$1.ER_MTA_INCONSISTENT_DATA = 1756;
    exports$1.ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING = 1757;
    exports$1.ER_DA_INVALID_CONDITION_NUMBER = 1758;
    exports$1.ER_INSECURE_PLAIN_TEXT = 1759;
    exports$1.ER_INSECURE_CHANGE_SOURCE = 1760;
    exports$1.ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO = 1761;
    exports$1.ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO = 1762;
    exports$1.ER_SQLTHREAD_WITH_SECURE_REPLICA = 1763;
    exports$1.ER_TABLE_HAS_NO_FT = 1764;
    exports$1.ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER = 1765;
    exports$1.ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION = 1766;
    exports$1.ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST = 1767;
    exports$1.ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION = 1768;
    exports$1.ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION = 1769;
    exports$1.ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL = 1770;
    exports$1.ER_SKIPPING_LOGGED_TRANSACTION = 1771;
    exports$1.ER_MALFORMED_GTID_SET_SPECIFICATION = 1772;
    exports$1.ER_MALFORMED_GTID_SET_ENCODING = 1773;
    exports$1.ER_MALFORMED_GTID_SPECIFICATION = 1774;
    exports$1.ER_GNO_EXHAUSTED = 1775;
    exports$1.ER_BAD_REPLICA_AUTO_POSITION = 1776;
    exports$1.ER_AUTO_POSITION_REQUIRES_GTID_MODE_NOT_OFF = 1777;
    exports$1.ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET = 1778;
    exports$1.ER_GTID_MODE_ON_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON = 1779;
    exports$1.ER_GTID_MODE_REQUIRES_BINLOG = 1780;
    exports$1.ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF = 1781;
    exports$1.ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON = 1782;
    exports$1.ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF = 1783;
    exports$1.ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF = 1784;
    exports$1.ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE = 1785;
    exports$1.ER_GTID_UNSAFE_CREATE_SELECT = 1786;
    exports$1.ER_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRANSACTION = 1787;
    exports$1.ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME = 1788;
    exports$1.ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS = 1789;
    exports$1.ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID = 1790;
    exports$1.ER_UNKNOWN_EXPLAIN_FORMAT = 1791;
    exports$1.ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION = 1792;
    exports$1.ER_TOO_LONG_TABLE_PARTITION_COMMENT = 1793;
    exports$1.ER_REPLICA_CONFIGURATION = 1794;
    exports$1.ER_INNODB_FT_LIMIT = 1795;
    exports$1.ER_INNODB_NO_FT_TEMP_TABLE = 1796;
    exports$1.ER_INNODB_FT_WRONG_DOCID_COLUMN = 1797;
    exports$1.ER_INNODB_FT_WRONG_DOCID_INDEX = 1798;
    exports$1.ER_INNODB_ONLINE_LOG_TOO_BIG = 1799;
    exports$1.ER_UNKNOWN_ALTER_ALGORITHM = 1800;
    exports$1.ER_UNKNOWN_ALTER_LOCK = 1801;
    exports$1.ER_MTA_CHANGE_SOURCE_CANT_RUN_WITH_GAPS = 1802;
    exports$1.ER_MTA_RECOVERY_FAILURE = 1803;
    exports$1.ER_MTA_RESET_WORKERS = 1804;
    exports$1.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2 = 1805;
    exports$1.ER_REPLICA_SILENT_RETRY_TRANSACTION = 1806;
    exports$1.ER_DISCARD_FK_CHECKS_RUNNING = 1807;
    exports$1.ER_TABLE_SCHEMA_MISMATCH = 1808;
    exports$1.ER_TABLE_IN_SYSTEM_TABLESPACE = 1809;
    exports$1.ER_IO_READ_ERROR = 1810;
    exports$1.ER_IO_WRITE_ERROR = 1811;
    exports$1.ER_TABLESPACE_MISSING = 1812;
    exports$1.ER_TABLESPACE_EXISTS = 1813;
    exports$1.ER_TABLESPACE_DISCARDED = 1814;
    exports$1.ER_INTERNAL_ERROR = 1815;
    exports$1.ER_INNODB_IMPORT_ERROR = 1816;
    exports$1.ER_INNODB_INDEX_CORRUPT = 1817;
    exports$1.ER_INVALID_YEAR_COLUMN_LENGTH = 1818;
    exports$1.ER_NOT_VALID_PASSWORD = 1819;
    exports$1.ER_MUST_CHANGE_PASSWORD = 1820;
    exports$1.ER_FK_NO_INDEX_CHILD = 1821;
    exports$1.ER_FK_NO_INDEX_PARENT = 1822;
    exports$1.ER_FK_FAIL_ADD_SYSTEM = 1823;
    exports$1.ER_FK_CANNOT_OPEN_PARENT = 1824;
    exports$1.ER_FK_INCORRECT_OPTION = 1825;
    exports$1.ER_FK_DUP_NAME = 1826;
    exports$1.ER_PASSWORD_FORMAT = 1827;
    exports$1.ER_FK_COLUMN_CANNOT_DROP = 1828;
    exports$1.ER_FK_COLUMN_CANNOT_DROP_CHILD = 1829;
    exports$1.ER_FK_COLUMN_NOT_NULL = 1830;
    exports$1.ER_DUP_INDEX = 1831;
    exports$1.ER_FK_COLUMN_CANNOT_CHANGE = 1832;
    exports$1.ER_FK_COLUMN_CANNOT_CHANGE_CHILD = 1833;
    exports$1.ER_UNUSED5 = 1834;
    exports$1.ER_MALFORMED_PACKET = 1835;
    exports$1.ER_READ_ONLY_MODE = 1836;
    exports$1.ER_GTID_NEXT_TYPE_UNDEFINED_GTID = 1837;
    exports$1.ER_VARIABLE_NOT_SETTABLE_IN_SP = 1838;
    exports$1.ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF = 1839;
    exports$1.ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY = 1840;
    exports$1.ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY = 1841;
    exports$1.ER_GTID_PURGED_WAS_CHANGED = 1842;
    exports$1.ER_GTID_EXECUTED_WAS_CHANGED = 1843;
    exports$1.ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES = 1844;
    exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED = 1845;
    exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON = 1846;
    exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY = 1847;
    exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION = 1848;
    exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME = 1849;
    exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE = 1850;
    exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK = 1851;
    exports$1.ER_UNUSED6 = 1852;
    exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK = 1853;
    exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC = 1854;
    exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS = 1855;
    exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS = 1856;
    exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS = 1857;
    exports$1.ER_SQL_REPLICA_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE = 1858;
    exports$1.ER_DUP_UNKNOWN_IN_INDEX = 1859;
    exports$1.ER_IDENT_CAUSES_TOO_LONG_PATH = 1860;
    exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL = 1861;
    exports$1.ER_MUST_CHANGE_PASSWORD_LOGIN = 1862;
    exports$1.ER_ROW_IN_WRONG_PARTITION = 1863;
    exports$1.ER_MTA_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX = 1864;
    exports$1.ER_INNODB_NO_FT_USES_PARSER = 1865;
    exports$1.ER_BINLOG_LOGICAL_CORRUPTION = 1866;
    exports$1.ER_WARN_PURGE_LOG_IN_USE = 1867;
    exports$1.ER_WARN_PURGE_LOG_IS_ACTIVE = 1868;
    exports$1.ER_AUTO_INCREMENT_CONFLICT = 1869;
    exports$1.WARN_ON_BLOCKHOLE_IN_RBR = 1870;
    exports$1.ER_REPLICA_CM_INIT_REPOSITORY = 1871;
    exports$1.ER_REPLICA_AM_INIT_REPOSITORY = 1872;
    exports$1.ER_ACCESS_DENIED_CHANGE_USER_ERROR = 1873;
    exports$1.ER_INNODB_READ_ONLY = 1874;
    exports$1.ER_STOP_REPLICA_SQL_THREAD_TIMEOUT = 1875;
    exports$1.ER_STOP_REPLICA_IO_THREAD_TIMEOUT = 1876;
    exports$1.ER_TABLE_CORRUPT = 1877;
    exports$1.ER_TEMP_FILE_WRITE_FAILURE = 1878;
    exports$1.ER_INNODB_FT_AUX_NOT_HEX_ID = 1879;
    exports$1.ER_OLD_TEMPORALS_UPGRADED = 1880;
    exports$1.ER_INNODB_FORCED_RECOVERY = 1881;
    exports$1.ER_AES_INVALID_IV = 1882;
    exports$1.ER_PLUGIN_CANNOT_BE_UNINSTALLED = 1883;
    exports$1.ER_GTID_UNSAFE_BINLOG_SPLITTABLE_STATEMENT_AND_ASSIGNED_GTID = 1884;
    exports$1.ER_REPLICA_HAS_MORE_GTIDS_THAN_SOURCE = 1885;
    exports$1.ER_MISSING_KEY = 1886;
    exports$1.WARN_NAMED_PIPE_ACCESS_EVERYONE = 1887;
    exports$1.ER_FILE_CORRUPT = 3e3;
    exports$1.ER_ERROR_ON_SOURCE = 3001;
    exports$1.ER_INCONSISTENT_ERROR = 3002;
    exports$1.ER_STORAGE_ENGINE_NOT_LOADED = 3003;
    exports$1.ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER = 3004;
    exports$1.ER_WARN_LEGACY_SYNTAX_CONVERTED = 3005;
    exports$1.ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN = 3006;
    exports$1.ER_CANNOT_DISCARD_TEMPORARY_TABLE = 3007;
    exports$1.ER_FK_DEPTH_EXCEEDED = 3008;
    exports$1.ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2 = 3009;
    exports$1.ER_WARN_TRIGGER_DOESNT_HAVE_CREATED = 3010;
    exports$1.ER_REFERENCED_TRG_DOES_NOT_EXIST = 3011;
    exports$1.ER_EXPLAIN_NOT_SUPPORTED = 3012;
    exports$1.ER_INVALID_FIELD_SIZE = 3013;
    exports$1.ER_MISSING_HA_CREATE_OPTION = 3014;
    exports$1.ER_ENGINE_OUT_OF_MEMORY = 3015;
    exports$1.ER_PASSWORD_EXPIRE_ANONYMOUS_USER = 3016;
    exports$1.ER_REPLICA_SQL_THREAD_MUST_STOP = 3017;
    exports$1.ER_NO_FT_MATERIALIZED_SUBQUERY = 3018;
    exports$1.ER_INNODB_UNDO_LOG_FULL = 3019;
    exports$1.ER_INVALID_ARGUMENT_FOR_LOGARITHM = 3020;
    exports$1.ER_REPLICA_CHANNEL_IO_THREAD_MUST_STOP = 3021;
    exports$1.ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO = 3022;
    exports$1.ER_WARN_ONLY_SOURCE_LOG_FILE_NO_POS = 3023;
    exports$1.ER_QUERY_TIMEOUT = 3024;
    exports$1.ER_NON_RO_SELECT_DISABLE_TIMER = 3025;
    exports$1.ER_DUP_LIST_ENTRY = 3026;
    exports$1.ER_SQL_MODE_NO_EFFECT = 3027;
    exports$1.ER_AGGREGATE_ORDER_FOR_UNION = 3028;
    exports$1.ER_AGGREGATE_ORDER_NON_AGG_QUERY = 3029;
    exports$1.ER_REPLICA_WORKER_STOPPED_PREVIOUS_THD_ERROR = 3030;
    exports$1.ER_DONT_SUPPORT_REPLICA_PRESERVE_COMMIT_ORDER = 3031;
    exports$1.ER_SERVER_OFFLINE_MODE = 3032;
    exports$1.ER_GIS_DIFFERENT_SRIDS = 3033;
    exports$1.ER_GIS_UNSUPPORTED_ARGUMENT = 3034;
    exports$1.ER_GIS_UNKNOWN_ERROR = 3035;
    exports$1.ER_GIS_UNKNOWN_EXCEPTION = 3036;
    exports$1.ER_GIS_INVALID_DATA = 3037;
    exports$1.ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION = 3038;
    exports$1.ER_BOOST_GEOMETRY_CENTROID_EXCEPTION = 3039;
    exports$1.ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION = 3040;
    exports$1.ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION = 3041;
    exports$1.ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION = 3042;
    exports$1.ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION = 3043;
    exports$1.ER_STD_BAD_ALLOC_ERROR = 3044;
    exports$1.ER_STD_DOMAIN_ERROR = 3045;
    exports$1.ER_STD_LENGTH_ERROR = 3046;
    exports$1.ER_STD_INVALID_ARGUMENT = 3047;
    exports$1.ER_STD_OUT_OF_RANGE_ERROR = 3048;
    exports$1.ER_STD_OVERFLOW_ERROR = 3049;
    exports$1.ER_STD_RANGE_ERROR = 3050;
    exports$1.ER_STD_UNDERFLOW_ERROR = 3051;
    exports$1.ER_STD_LOGIC_ERROR = 3052;
    exports$1.ER_STD_RUNTIME_ERROR = 3053;
    exports$1.ER_STD_UNKNOWN_EXCEPTION = 3054;
    exports$1.ER_GIS_DATA_WRONG_ENDIANESS = 3055;
    exports$1.ER_CHANGE_SOURCE_PASSWORD_LENGTH = 3056;
    exports$1.ER_USER_LOCK_WRONG_NAME = 3057;
    exports$1.ER_USER_LOCK_DEADLOCK = 3058;
    exports$1.ER_REPLACE_INACCESSIBLE_ROWS = 3059;
    exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS = 3060;
    exports$1.ER_ILLEGAL_USER_VAR = 3061;
    exports$1.ER_GTID_MODE_OFF = 3062;
    exports$1.ER_UNSUPPORTED_BY_REPLICATION_THREAD = 3063;
    exports$1.ER_INCORRECT_TYPE = 3064;
    exports$1.ER_FIELD_IN_ORDER_NOT_SELECT = 3065;
    exports$1.ER_AGGREGATE_IN_ORDER_NOT_SELECT = 3066;
    exports$1.ER_INVALID_RPL_WILD_TABLE_FILTER_PATTERN = 3067;
    exports$1.ER_NET_OK_PACKET_TOO_LARGE = 3068;
    exports$1.ER_INVALID_JSON_DATA = 3069;
    exports$1.ER_INVALID_GEOJSON_MISSING_MEMBER = 3070;
    exports$1.ER_INVALID_GEOJSON_WRONG_TYPE = 3071;
    exports$1.ER_INVALID_GEOJSON_UNSPECIFIED = 3072;
    exports$1.ER_DIMENSION_UNSUPPORTED = 3073;
    exports$1.ER_REPLICA_CHANNEL_DOES_NOT_EXIST = 3074;
    exports$1.ER_SLAVE_MULTIPLE_CHANNELS_HOST_PORT = 3075;
    exports$1.ER_REPLICA_CHANNEL_NAME_INVALID_OR_TOO_LONG = 3076;
    exports$1.ER_REPLICA_NEW_CHANNEL_WRONG_REPOSITORY = 3077;
    exports$1.ER_SLAVE_CHANNEL_DELETE = 3078;
    exports$1.ER_REPLICA_MULTIPLE_CHANNELS_CMD = 3079;
    exports$1.ER_REPLICA_MAX_CHANNELS_EXCEEDED = 3080;
    exports$1.ER_REPLICA_CHANNEL_MUST_STOP = 3081;
    exports$1.ER_REPLICA_CHANNEL_NOT_RUNNING = 3082;
    exports$1.ER_REPLICA_CHANNEL_WAS_RUNNING = 3083;
    exports$1.ER_REPLICA_CHANNEL_WAS_NOT_RUNNING = 3084;
    exports$1.ER_REPLICA_CHANNEL_SQL_THREAD_MUST_STOP = 3085;
    exports$1.ER_REPLICA_CHANNEL_SQL_SKIP_COUNTER = 3086;
    exports$1.ER_WRONG_FIELD_WITH_GROUP_V2 = 3087;
    exports$1.ER_MIX_OF_GROUP_FUNC_AND_FIELDS_V2 = 3088;
    exports$1.ER_WARN_DEPRECATED_SYSVAR_UPDATE = 3089;
    exports$1.ER_WARN_DEPRECATED_SQLMODE = 3090;
    exports$1.ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID = 3091;
    exports$1.ER_GROUP_REPLICATION_CONFIGURATION = 3092;
    exports$1.ER_GROUP_REPLICATION_RUNNING = 3093;
    exports$1.ER_GROUP_REPLICATION_APPLIER_INIT_ERROR = 3094;
    exports$1.ER_GROUP_REPLICATION_STOP_APPLIER_THREAD_TIMEOUT = 3095;
    exports$1.ER_GROUP_REPLICATION_COMMUNICATION_LAYER_SESSION_ERROR = 3096;
    exports$1.ER_GROUP_REPLICATION_COMMUNICATION_LAYER_JOIN_ERROR = 3097;
    exports$1.ER_BEFORE_DML_VALIDATION_ERROR = 3098;
    exports$1.ER_PREVENTS_VARIABLE_WITHOUT_RBR = 3099;
    exports$1.ER_RUN_HOOK_ERROR = 3100;
    exports$1.ER_TRANSACTION_ROLLBACK_DURING_COMMIT = 3101;
    exports$1.ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED = 3102;
    exports$1.ER_UNSUPPORTED_ALTER_INPLACE_ON_VIRTUAL_COLUMN = 3103;
    exports$1.ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN = 3104;
    exports$1.ER_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN = 3105;
    exports$1.ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN = 3106;
    exports$1.ER_GENERATED_COLUMN_NON_PRIOR = 3107;
    exports$1.ER_DEPENDENT_BY_GENERATED_COLUMN = 3108;
    exports$1.ER_GENERATED_COLUMN_REF_AUTO_INC = 3109;
    exports$1.ER_FEATURE_NOT_AVAILABLE = 3110;
    exports$1.ER_CANT_SET_GTID_MODE = 3111;
    exports$1.ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF = 3112;
    exports$1.ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION = 3113;
    exports$1.ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON = 3114;
    exports$1.ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF = 3115;
    exports$1.ER_CANT_ENFORCE_GTID_CONSISTENCY_WITH_ONGOING_GTID_VIOLATING_TX = 3116;
    exports$1.ER_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TX = 3117;
    exports$1.ER_ACCOUNT_HAS_BEEN_LOCKED = 3118;
    exports$1.ER_WRONG_TABLESPACE_NAME = 3119;
    exports$1.ER_TABLESPACE_IS_NOT_EMPTY = 3120;
    exports$1.ER_WRONG_FILE_NAME = 3121;
    exports$1.ER_BOOST_GEOMETRY_INCONSISTENT_TURNS_EXCEPTION = 3122;
    exports$1.ER_WARN_OPTIMIZER_HINT_SYNTAX_ERROR = 3123;
    exports$1.ER_WARN_BAD_MAX_EXECUTION_TIME = 3124;
    exports$1.ER_WARN_UNSUPPORTED_MAX_EXECUTION_TIME = 3125;
    exports$1.ER_WARN_CONFLICTING_HINT = 3126;
    exports$1.ER_WARN_UNKNOWN_QB_NAME = 3127;
    exports$1.ER_UNRESOLVED_HINT_NAME = 3128;
    exports$1.ER_WARN_ON_MODIFYING_GTID_EXECUTED_TABLE = 3129;
    exports$1.ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED = 3130;
    exports$1.ER_LOCKING_SERVICE_WRONG_NAME = 3131;
    exports$1.ER_LOCKING_SERVICE_DEADLOCK = 3132;
    exports$1.ER_LOCKING_SERVICE_TIMEOUT = 3133;
    exports$1.ER_GIS_MAX_POINTS_IN_GEOMETRY_OVERFLOWED = 3134;
    exports$1.ER_SQL_MODE_MERGED = 3135;
    exports$1.ER_VTOKEN_PLUGIN_TOKEN_MISMATCH = 3136;
    exports$1.ER_VTOKEN_PLUGIN_TOKEN_NOT_FOUND = 3137;
    exports$1.ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID = 3138;
    exports$1.ER_REPLICA_CHANNEL_OPERATION_NOT_ALLOWED = 3139;
    exports$1.ER_INVALID_JSON_TEXT = 3140;
    exports$1.ER_INVALID_JSON_TEXT_IN_PARAM = 3141;
    exports$1.ER_INVALID_JSON_BINARY_DATA = 3142;
    exports$1.ER_INVALID_JSON_PATH = 3143;
    exports$1.ER_INVALID_JSON_CHARSET = 3144;
    exports$1.ER_INVALID_JSON_CHARSET_IN_FUNCTION = 3145;
    exports$1.ER_INVALID_TYPE_FOR_JSON = 3146;
    exports$1.ER_INVALID_CAST_TO_JSON = 3147;
    exports$1.ER_INVALID_JSON_PATH_CHARSET = 3148;
    exports$1.ER_INVALID_JSON_PATH_WILDCARD = 3149;
    exports$1.ER_JSON_VALUE_TOO_BIG = 3150;
    exports$1.ER_JSON_KEY_TOO_BIG = 3151;
    exports$1.ER_JSON_USED_AS_KEY = 3152;
    exports$1.ER_JSON_VACUOUS_PATH = 3153;
    exports$1.ER_JSON_BAD_ONE_OR_ALL_ARG = 3154;
    exports$1.ER_NUMERIC_JSON_VALUE_OUT_OF_RANGE = 3155;
    exports$1.ER_INVALID_JSON_VALUE_FOR_CAST = 3156;
    exports$1.ER_JSON_DOCUMENT_TOO_DEEP = 3157;
    exports$1.ER_JSON_DOCUMENT_NULL_KEY = 3158;
    exports$1.ER_SECURE_TRANSPORT_REQUIRED = 3159;
    exports$1.ER_NO_SECURE_TRANSPORTS_CONFIGURED = 3160;
    exports$1.ER_DISABLED_STORAGE_ENGINE = 3161;
    exports$1.ER_USER_DOES_NOT_EXIST = 3162;
    exports$1.ER_USER_ALREADY_EXISTS = 3163;
    exports$1.ER_AUDIT_API_ABORT = 3164;
    exports$1.ER_INVALID_JSON_PATH_ARRAY_CELL = 3165;
    exports$1.ER_BUFPOOL_RESIZE_INPROGRESS = 3166;
    exports$1.ER_FEATURE_DISABLED_SEE_DOC = 3167;
    exports$1.ER_SERVER_ISNT_AVAILABLE = 3168;
    exports$1.ER_SESSION_WAS_KILLED = 3169;
    exports$1.ER_CAPACITY_EXCEEDED = 3170;
    exports$1.ER_CAPACITY_EXCEEDED_IN_RANGE_OPTIMIZER = 3171;
    exports$1.ER_TABLE_NEEDS_UPG_PART = 3172;
    exports$1.ER_CANT_WAIT_FOR_EXECUTED_GTID_SET_WHILE_OWNING_A_GTID = 3173;
    exports$1.ER_CANNOT_ADD_FOREIGN_BASE_COL_VIRTUAL = 3174;
    exports$1.ER_CANNOT_CREATE_VIRTUAL_INDEX_CONSTRAINT = 3175;
    exports$1.ER_ERROR_ON_MODIFYING_GTID_EXECUTED_TABLE = 3176;
    exports$1.ER_LOCK_REFUSED_BY_ENGINE = 3177;
    exports$1.ER_UNSUPPORTED_ALTER_ONLINE_ON_VIRTUAL_COLUMN = 3178;
    exports$1.ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE = 3179;
    exports$1.ER_MASTER_KEY_ROTATION_ERROR_BY_SE = 3180;
    exports$1.ER_MASTER_KEY_ROTATION_BINLOG_FAILED = 3181;
    exports$1.ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE = 3182;
    exports$1.ER_TABLESPACE_CANNOT_ENCRYPT = 3183;
    exports$1.ER_INVALID_ENCRYPTION_OPTION = 3184;
    exports$1.ER_CANNOT_FIND_KEY_IN_KEYRING = 3185;
    exports$1.ER_CAPACITY_EXCEEDED_IN_PARSER = 3186;
    exports$1.ER_UNSUPPORTED_ALTER_ENCRYPTION_INPLACE = 3187;
    exports$1.ER_KEYRING_UDF_KEYRING_SERVICE_ERROR = 3188;
    exports$1.ER_USER_COLUMN_OLD_LENGTH = 3189;
    exports$1.ER_CANT_RESET_SOURCE = 3190;
    exports$1.ER_GROUP_REPLICATION_MAX_GROUP_SIZE = 3191;
    exports$1.ER_CANNOT_ADD_FOREIGN_BASE_COL_STORED = 3192;
    exports$1.ER_TABLE_REFERENCED = 3193;
    exports$1.ER_PARTITION_ENGINE_DEPRECATED_FOR_TABLE = 3194;
    exports$1.ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID_ZERO = 3195;
    exports$1.ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID = 3196;
    exports$1.ER_XA_RETRY = 3197;
    exports$1.ER_KEYRING_AWS_UDF_AWS_KMS_ERROR = 3198;
    exports$1.ER_BINLOG_UNSAFE_XA = 3199;
    exports$1.ER_UDF_ERROR = 3200;
    exports$1.ER_KEYRING_MIGRATION_FAILURE = 3201;
    exports$1.ER_KEYRING_ACCESS_DENIED_ERROR = 3202;
    exports$1.ER_KEYRING_MIGRATION_STATUS = 3203;
    exports$1.ER_PLUGIN_FAILED_TO_OPEN_TABLES = 3204;
    exports$1.ER_PLUGIN_FAILED_TO_OPEN_TABLE = 3205;
    exports$1.ER_AUDIT_LOG_NO_KEYRING_PLUGIN_INSTALLED = 3206;
    exports$1.ER_AUDIT_LOG_ENCRYPTION_PASSWORD_HAS_NOT_BEEN_SET = 3207;
    exports$1.ER_AUDIT_LOG_COULD_NOT_CREATE_AES_KEY = 3208;
    exports$1.ER_AUDIT_LOG_ENCRYPTION_PASSWORD_CANNOT_BE_FETCHED = 3209;
    exports$1.ER_AUDIT_LOG_JSON_FILTERING_NOT_ENABLED = 3210;
    exports$1.ER_AUDIT_LOG_UDF_INSUFFICIENT_PRIVILEGE = 3211;
    exports$1.ER_AUDIT_LOG_SUPER_PRIVILEGE_REQUIRED = 3212;
    exports$1.ER_COULD_NOT_REINITIALIZE_AUDIT_LOG_FILTERS = 3213;
    exports$1.ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_TYPE = 3214;
    exports$1.ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_COUNT = 3215;
    exports$1.ER_AUDIT_LOG_HAS_NOT_BEEN_INSTALLED = 3216;
    exports$1.ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_TYPE = 3217;
    exports$1.ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_VALUE = 3218;
    exports$1.ER_AUDIT_LOG_JSON_FILTER_PARSING_ERROR = 3219;
    exports$1.ER_AUDIT_LOG_JSON_FILTER_NAME_CANNOT_BE_EMPTY = 3220;
    exports$1.ER_AUDIT_LOG_JSON_USER_NAME_CANNOT_BE_EMPTY = 3221;
    exports$1.ER_AUDIT_LOG_JSON_FILTER_DOES_NOT_EXISTS = 3222;
    exports$1.ER_AUDIT_LOG_USER_FIRST_CHARACTER_MUST_BE_ALPHANUMERIC = 3223;
    exports$1.ER_AUDIT_LOG_USER_NAME_INVALID_CHARACTER = 3224;
    exports$1.ER_AUDIT_LOG_HOST_NAME_INVALID_CHARACTER = 3225;
    exports$1.WARN_DEPRECATED_MAXDB_SQL_MODE_FOR_TIMESTAMP = 3226;
    exports$1.ER_XA_REPLICATION_FILTERS = 3227;
    exports$1.ER_CANT_OPEN_ERROR_LOG = 3228;
    exports$1.ER_GROUPING_ON_TIMESTAMP_IN_DST = 3229;
    exports$1.ER_CANT_START_SERVER_NAMED_PIPE = 3230;
    exports$1.ER_WRITE_SET_EXCEEDS_LIMIT = 3231;
    exports$1.ER_DEPRECATED_TLS_VERSION_SESSION_57 = 3232;
    exports$1.ER_WARN_DEPRECATED_TLS_VERSION_57 = 3233;
    exports$1.ER_WARN_WRONG_NATIVE_TABLE_STRUCTURE = 3234;
    exports$1.ER_AES_INVALID_KDF_NAME = 3235;
    exports$1.ER_AES_INVALID_KDF_ITERATIONS = 3236;
    exports$1.WARN_AES_KEY_SIZE = 3237;
    exports$1.ER_AES_INVALID_KDF_OPTION_SIZE = 3238;
    exports$1.ER_UNSUPPORT_COMPRESSED_TEMPORARY_TABLE = 3500;
    exports$1.ER_ACL_OPERATION_FAILED = 3501;
    exports$1.ER_UNSUPPORTED_INDEX_ALGORITHM = 3502;
    exports$1.ER_NO_SUCH_DB = 3503;
    exports$1.ER_TOO_BIG_ENUM = 3504;
    exports$1.ER_TOO_LONG_SET_ENUM_VALUE = 3505;
    exports$1.ER_INVALID_DD_OBJECT = 3506;
    exports$1.ER_UPDATING_DD_TABLE = 3507;
    exports$1.ER_INVALID_DD_OBJECT_ID = 3508;
    exports$1.ER_INVALID_DD_OBJECT_NAME = 3509;
    exports$1.ER_TABLESPACE_MISSING_WITH_NAME = 3510;
    exports$1.ER_TOO_LONG_ROUTINE_COMMENT = 3511;
    exports$1.ER_SP_LOAD_FAILED = 3512;
    exports$1.ER_INVALID_BITWISE_OPERANDS_SIZE = 3513;
    exports$1.ER_INVALID_BITWISE_AGGREGATE_OPERANDS_SIZE = 3514;
    exports$1.ER_WARN_UNSUPPORTED_HINT = 3515;
    exports$1.ER_UNEXPECTED_GEOMETRY_TYPE = 3516;
    exports$1.ER_SRS_PARSE_ERROR = 3517;
    exports$1.ER_SRS_PROJ_PARAMETER_MISSING = 3518;
    exports$1.ER_WARN_SRS_NOT_FOUND = 3519;
    exports$1.ER_SRS_NOT_CARTESIAN = 3520;
    exports$1.ER_SRS_NOT_CARTESIAN_UNDEFINED = 3521;
    exports$1.ER_PK_INDEX_CANT_BE_INVISIBLE = 3522;
    exports$1.ER_UNKNOWN_AUTHID = 3523;
    exports$1.ER_FAILED_ROLE_GRANT = 3524;
    exports$1.ER_OPEN_ROLE_TABLES = 3525;
    exports$1.ER_FAILED_DEFAULT_ROLES = 3526;
    exports$1.ER_COMPONENTS_NO_SCHEME = 3527;
    exports$1.ER_COMPONENTS_NO_SCHEME_SERVICE = 3528;
    exports$1.ER_COMPONENTS_CANT_LOAD = 3529;
    exports$1.ER_ROLE_NOT_GRANTED = 3530;
    exports$1.ER_FAILED_REVOKE_ROLE = 3531;
    exports$1.ER_RENAME_ROLE = 3532;
    exports$1.ER_COMPONENTS_CANT_ACQUIRE_SERVICE_IMPLEMENTATION = 3533;
    exports$1.ER_COMPONENTS_CANT_SATISFY_DEPENDENCY = 3534;
    exports$1.ER_COMPONENTS_LOAD_CANT_REGISTER_SERVICE_IMPLEMENTATION = 3535;
    exports$1.ER_COMPONENTS_LOAD_CANT_INITIALIZE = 3536;
    exports$1.ER_COMPONENTS_UNLOAD_NOT_LOADED = 3537;
    exports$1.ER_COMPONENTS_UNLOAD_CANT_DEINITIALIZE = 3538;
    exports$1.ER_COMPONENTS_CANT_RELEASE_SERVICE = 3539;
    exports$1.ER_COMPONENTS_UNLOAD_CANT_UNREGISTER_SERVICE = 3540;
    exports$1.ER_COMPONENTS_CANT_UNLOAD = 3541;
    exports$1.ER_WARN_UNLOAD_THE_NOT_PERSISTED = 3542;
    exports$1.ER_COMPONENT_TABLE_INCORRECT = 3543;
    exports$1.ER_COMPONENT_MANIPULATE_ROW_FAILED = 3544;
    exports$1.ER_COMPONENTS_UNLOAD_DUPLICATE_IN_GROUP = 3545;
    exports$1.ER_CANT_SET_GTID_PURGED_DUE_SETS_CONSTRAINTS = 3546;
    exports$1.ER_CANNOT_LOCK_USER_MANAGEMENT_CACHES = 3547;
    exports$1.ER_SRS_NOT_FOUND = 3548;
    exports$1.ER_VARIABLE_NOT_PERSISTED = 3549;
    exports$1.ER_IS_QUERY_INVALID_CLAUSE = 3550;
    exports$1.ER_UNABLE_TO_STORE_STATISTICS = 3551;
    exports$1.ER_NO_SYSTEM_SCHEMA_ACCESS = 3552;
    exports$1.ER_NO_SYSTEM_TABLESPACE_ACCESS = 3553;
    exports$1.ER_NO_SYSTEM_TABLE_ACCESS = 3554;
    exports$1.ER_NO_SYSTEM_TABLE_ACCESS_FOR_DICTIONARY_TABLE = 3555;
    exports$1.ER_NO_SYSTEM_TABLE_ACCESS_FOR_SYSTEM_TABLE = 3556;
    exports$1.ER_NO_SYSTEM_TABLE_ACCESS_FOR_TABLE = 3557;
    exports$1.ER_INVALID_OPTION_KEY = 3558;
    exports$1.ER_INVALID_OPTION_VALUE = 3559;
    exports$1.ER_INVALID_OPTION_KEY_VALUE_PAIR = 3560;
    exports$1.ER_INVALID_OPTION_START_CHARACTER = 3561;
    exports$1.ER_INVALID_OPTION_END_CHARACTER = 3562;
    exports$1.ER_INVALID_OPTION_CHARACTERS = 3563;
    exports$1.ER_DUPLICATE_OPTION_KEY = 3564;
    exports$1.ER_WARN_SRS_NOT_FOUND_AXIS_ORDER = 3565;
    exports$1.ER_NO_ACCESS_TO_NATIVE_FCT = 3566;
    exports$1.ER_RESET_SOURCE_TO_VALUE_OUT_OF_RANGE = 3567;
    exports$1.ER_UNRESOLVED_TABLE_LOCK = 3568;
    exports$1.ER_DUPLICATE_TABLE_LOCK = 3569;
    exports$1.ER_BINLOG_UNSAFE_SKIP_LOCKED = 3570;
    exports$1.ER_BINLOG_UNSAFE_NOWAIT = 3571;
    exports$1.ER_LOCK_NOWAIT = 3572;
    exports$1.ER_CTE_RECURSIVE_REQUIRES_UNION = 3573;
    exports$1.ER_CTE_RECURSIVE_REQUIRES_NONRECURSIVE_FIRST = 3574;
    exports$1.ER_CTE_RECURSIVE_FORBIDS_AGGREGATION = 3575;
    exports$1.ER_CTE_RECURSIVE_FORBIDDEN_JOIN_ORDER = 3576;
    exports$1.ER_CTE_RECURSIVE_REQUIRES_SINGLE_REFERENCE = 3577;
    exports$1.ER_SWITCH_TMP_ENGINE = 3578;
    exports$1.ER_WINDOW_NO_SUCH_WINDOW = 3579;
    exports$1.ER_WINDOW_CIRCULARITY_IN_WINDOW_GRAPH = 3580;
    exports$1.ER_WINDOW_NO_CHILD_PARTITIONING = 3581;
    exports$1.ER_WINDOW_NO_INHERIT_FRAME = 3582;
    exports$1.ER_WINDOW_NO_REDEFINE_ORDER_BY = 3583;
    exports$1.ER_WINDOW_FRAME_START_ILLEGAL = 3584;
    exports$1.ER_WINDOW_FRAME_END_ILLEGAL = 3585;
    exports$1.ER_WINDOW_FRAME_ILLEGAL = 3586;
    exports$1.ER_WINDOW_RANGE_FRAME_ORDER_TYPE = 3587;
    exports$1.ER_WINDOW_RANGE_FRAME_TEMPORAL_TYPE = 3588;
    exports$1.ER_WINDOW_RANGE_FRAME_NUMERIC_TYPE = 3589;
    exports$1.ER_WINDOW_RANGE_BOUND_NOT_CONSTANT = 3590;
    exports$1.ER_WINDOW_DUPLICATE_NAME = 3591;
    exports$1.ER_WINDOW_ILLEGAL_ORDER_BY = 3592;
    exports$1.ER_WINDOW_INVALID_WINDOW_FUNC_USE = 3593;
    exports$1.ER_WINDOW_INVALID_WINDOW_FUNC_ALIAS_USE = 3594;
    exports$1.ER_WINDOW_NESTED_WINDOW_FUNC_USE_IN_WINDOW_SPEC = 3595;
    exports$1.ER_WINDOW_ROWS_INTERVAL_USE = 3596;
    exports$1.ER_WINDOW_NO_GROUP_ORDER = 3597;
    exports$1.ER_WINDOW_EXPLAIN_JSON = 3598;
    exports$1.ER_WINDOW_FUNCTION_IGNORES_FRAME = 3599;
    exports$1.ER_WL9236_NOW = 3600;
    exports$1.ER_INVALID_NO_OF_ARGS = 3601;
    exports$1.ER_FIELD_IN_GROUPING_NOT_GROUP_BY = 3602;
    exports$1.ER_TOO_LONG_TABLESPACE_COMMENT = 3603;
    exports$1.ER_ENGINE_CANT_DROP_TABLE = 3604;
    exports$1.ER_ENGINE_CANT_DROP_MISSING_TABLE = 3605;
    exports$1.ER_TABLESPACE_DUP_FILENAME = 3606;
    exports$1.ER_DB_DROP_RMDIR2 = 3607;
    exports$1.ER_IMP_NO_FILES_MATCHED = 3608;
    exports$1.ER_IMP_SCHEMA_DOES_NOT_EXIST = 3609;
    exports$1.ER_IMP_TABLE_ALREADY_EXISTS = 3610;
    exports$1.ER_IMP_INCOMPATIBLE_MYSQLD_VERSION = 3611;
    exports$1.ER_IMP_INCOMPATIBLE_DD_VERSION = 3612;
    exports$1.ER_IMP_INCOMPATIBLE_SDI_VERSION = 3613;
    exports$1.ER_WARN_INVALID_HINT = 3614;
    exports$1.ER_VAR_DOES_NOT_EXIST = 3615;
    exports$1.ER_LONGITUDE_OUT_OF_RANGE = 3616;
    exports$1.ER_LATITUDE_OUT_OF_RANGE = 3617;
    exports$1.ER_NOT_IMPLEMENTED_FOR_GEOGRAPHIC_SRS = 3618;
    exports$1.ER_ILLEGAL_PRIVILEGE_LEVEL = 3619;
    exports$1.ER_NO_SYSTEM_VIEW_ACCESS = 3620;
    exports$1.ER_COMPONENT_FILTER_FLABBERGASTED = 3621;
    exports$1.ER_PART_EXPR_TOO_LONG = 3622;
    exports$1.ER_UDF_DROP_DYNAMICALLY_REGISTERED = 3623;
    exports$1.ER_UNABLE_TO_STORE_COLUMN_STATISTICS = 3624;
    exports$1.ER_UNABLE_TO_UPDATE_COLUMN_STATISTICS = 3625;
    exports$1.ER_UNABLE_TO_DROP_COLUMN_STATISTICS = 3626;
    exports$1.ER_UNABLE_TO_BUILD_HISTOGRAM = 3627;
    exports$1.ER_MANDATORY_ROLE = 3628;
    exports$1.ER_MISSING_TABLESPACE_FILE = 3629;
    exports$1.ER_PERSIST_ONLY_ACCESS_DENIED_ERROR = 3630;
    exports$1.ER_CMD_NEED_SUPER = 3631;
    exports$1.ER_PATH_IN_DATADIR = 3632;
    exports$1.ER_CLONE_DDL_IN_PROGRESS = 3633;
    exports$1.ER_CLONE_TOO_MANY_CONCURRENT_CLONES = 3634;
    exports$1.ER_APPLIER_LOG_EVENT_VALIDATION_ERROR = 3635;
    exports$1.ER_CTE_MAX_RECURSION_DEPTH = 3636;
    exports$1.ER_NOT_HINT_UPDATABLE_VARIABLE = 3637;
    exports$1.ER_CREDENTIALS_CONTRADICT_TO_HISTORY = 3638;
    exports$1.ER_WARNING_PASSWORD_HISTORY_CLAUSES_VOID = 3639;
    exports$1.ER_CLIENT_DOES_NOT_SUPPORT = 3640;
    exports$1.ER_I_S_SKIPPED_TABLESPACE = 3641;
    exports$1.ER_TABLESPACE_ENGINE_MISMATCH = 3642;
    exports$1.ER_WRONG_SRID_FOR_COLUMN = 3643;
    exports$1.ER_CANNOT_ALTER_SRID_DUE_TO_INDEX = 3644;
    exports$1.ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED = 3645;
    exports$1.ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED = 3646;
    exports$1.ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES = 3647;
    exports$1.ER_COULD_NOT_APPLY_JSON_DIFF = 3648;
    exports$1.ER_CORRUPTED_JSON_DIFF = 3649;
    exports$1.ER_RESOURCE_GROUP_EXISTS = 3650;
    exports$1.ER_RESOURCE_GROUP_NOT_EXISTS = 3651;
    exports$1.ER_INVALID_VCPU_ID = 3652;
    exports$1.ER_INVALID_VCPU_RANGE = 3653;
    exports$1.ER_INVALID_THREAD_PRIORITY = 3654;
    exports$1.ER_DISALLOWED_OPERATION = 3655;
    exports$1.ER_RESOURCE_GROUP_BUSY = 3656;
    exports$1.ER_RESOURCE_GROUP_DISABLED = 3657;
    exports$1.ER_FEATURE_UNSUPPORTED = 3658;
    exports$1.ER_ATTRIBUTE_IGNORED = 3659;
    exports$1.ER_INVALID_THREAD_ID = 3660;
    exports$1.ER_RESOURCE_GROUP_BIND_FAILED = 3661;
    exports$1.ER_INVALID_USE_OF_FORCE_OPTION = 3662;
    exports$1.ER_GROUP_REPLICATION_COMMAND_FAILURE = 3663;
    exports$1.ER_SDI_OPERATION_FAILED = 3664;
    exports$1.ER_MISSING_JSON_TABLE_VALUE = 3665;
    exports$1.ER_WRONG_JSON_TABLE_VALUE = 3666;
    exports$1.ER_TF_MUST_HAVE_ALIAS = 3667;
    exports$1.ER_TF_FORBIDDEN_JOIN_TYPE = 3668;
    exports$1.ER_JT_VALUE_OUT_OF_RANGE = 3669;
    exports$1.ER_JT_MAX_NESTED_PATH = 3670;
    exports$1.ER_PASSWORD_EXPIRATION_NOT_SUPPORTED_BY_AUTH_METHOD = 3671;
    exports$1.ER_INVALID_GEOJSON_CRS_NOT_TOP_LEVEL = 3672;
    exports$1.ER_BAD_NULL_ERROR_NOT_IGNORED = 3673;
    exports$1.WARN_USELESS_SPATIAL_INDEX = 3674;
    exports$1.ER_DISK_FULL_NOWAIT = 3675;
    exports$1.ER_PARSE_ERROR_IN_DIGEST_FN = 3676;
    exports$1.ER_UNDISCLOSED_PARSE_ERROR_IN_DIGEST_FN = 3677;
    exports$1.ER_SCHEMA_DIR_EXISTS = 3678;
    exports$1.ER_SCHEMA_DIR_MISSING = 3679;
    exports$1.ER_SCHEMA_DIR_CREATE_FAILED = 3680;
    exports$1.ER_SCHEMA_DIR_UNKNOWN = 3681;
    exports$1.ER_ONLY_IMPLEMENTED_FOR_SRID_0_AND_4326 = 3682;
    exports$1.ER_BINLOG_EXPIRE_LOG_DAYS_AND_SECS_USED_TOGETHER = 3683;
    exports$1.ER_REGEXP_BUFFER_OVERFLOW = 3684;
    exports$1.ER_REGEXP_ILLEGAL_ARGUMENT = 3685;
    exports$1.ER_REGEXP_INDEX_OUTOFBOUNDS_ERROR = 3686;
    exports$1.ER_REGEXP_INTERNAL_ERROR = 3687;
    exports$1.ER_REGEXP_RULE_SYNTAX = 3688;
    exports$1.ER_REGEXP_BAD_ESCAPE_SEQUENCE = 3689;
    exports$1.ER_REGEXP_UNIMPLEMENTED = 3690;
    exports$1.ER_REGEXP_MISMATCHED_PAREN = 3691;
    exports$1.ER_REGEXP_BAD_INTERVAL = 3692;
    exports$1.ER_REGEXP_MAX_LT_MIN = 3693;
    exports$1.ER_REGEXP_INVALID_BACK_REF = 3694;
    exports$1.ER_REGEXP_LOOK_BEHIND_LIMIT = 3695;
    exports$1.ER_REGEXP_MISSING_CLOSE_BRACKET = 3696;
    exports$1.ER_REGEXP_INVALID_RANGE = 3697;
    exports$1.ER_REGEXP_STACK_OVERFLOW = 3698;
    exports$1.ER_REGEXP_TIME_OUT = 3699;
    exports$1.ER_REGEXP_PATTERN_TOO_BIG = 3700;
    exports$1.ER_CANT_SET_ERROR_LOG_SERVICE = 3701;
    exports$1.ER_EMPTY_PIPELINE_FOR_ERROR_LOG_SERVICE = 3702;
    exports$1.ER_COMPONENT_FILTER_DIAGNOSTICS = 3703;
    exports$1.ER_NOT_IMPLEMENTED_FOR_CARTESIAN_SRS = 3704;
    exports$1.ER_NOT_IMPLEMENTED_FOR_PROJECTED_SRS = 3705;
    exports$1.ER_NONPOSITIVE_RADIUS = 3706;
    exports$1.ER_RESTART_SERVER_FAILED = 3707;
    exports$1.ER_SRS_MISSING_MANDATORY_ATTRIBUTE = 3708;
    exports$1.ER_SRS_MULTIPLE_ATTRIBUTE_DEFINITIONS = 3709;
    exports$1.ER_SRS_NAME_CANT_BE_EMPTY_OR_WHITESPACE = 3710;
    exports$1.ER_SRS_ORGANIZATION_CANT_BE_EMPTY_OR_WHITESPACE = 3711;
    exports$1.ER_SRS_ID_ALREADY_EXISTS = 3712;
    exports$1.ER_WARN_SRS_ID_ALREADY_EXISTS = 3713;
    exports$1.ER_CANT_MODIFY_SRID_0 = 3714;
    exports$1.ER_WARN_RESERVED_SRID_RANGE = 3715;
    exports$1.ER_CANT_MODIFY_SRS_USED_BY_COLUMN = 3716;
    exports$1.ER_SRS_INVALID_CHARACTER_IN_ATTRIBUTE = 3717;
    exports$1.ER_SRS_ATTRIBUTE_STRING_TOO_LONG = 3718;
    exports$1.ER_DEPRECATED_UTF8_ALIAS = 3719;
    exports$1.ER_DEPRECATED_NATIONAL = 3720;
    exports$1.ER_INVALID_DEFAULT_UTF8MB4_COLLATION = 3721;
    exports$1.ER_UNABLE_TO_COLLECT_LOG_STATUS = 3722;
    exports$1.ER_RESERVED_TABLESPACE_NAME = 3723;
    exports$1.ER_UNABLE_TO_SET_OPTION = 3724;
    exports$1.ER_REPLICA_POSSIBLY_DIVERGED_AFTER_DDL = 3725;
    exports$1.ER_SRS_NOT_GEOGRAPHIC = 3726;
    exports$1.ER_POLYGON_TOO_LARGE = 3727;
    exports$1.ER_SPATIAL_UNIQUE_INDEX = 3728;
    exports$1.ER_INDEX_TYPE_NOT_SUPPORTED_FOR_SPATIAL_INDEX = 3729;
    exports$1.ER_FK_CANNOT_DROP_PARENT = 3730;
    exports$1.ER_GEOMETRY_PARAM_LONGITUDE_OUT_OF_RANGE = 3731;
    exports$1.ER_GEOMETRY_PARAM_LATITUDE_OUT_OF_RANGE = 3732;
    exports$1.ER_FK_CANNOT_USE_VIRTUAL_COLUMN = 3733;
    exports$1.ER_FK_NO_COLUMN_PARENT = 3734;
    exports$1.ER_CANT_SET_ERROR_SUPPRESSION_LIST = 3735;
    exports$1.ER_SRS_GEOGCS_INVALID_AXES = 3736;
    exports$1.ER_SRS_INVALID_SEMI_MAJOR_AXIS = 3737;
    exports$1.ER_SRS_INVALID_INVERSE_FLATTENING = 3738;
    exports$1.ER_SRS_INVALID_ANGULAR_UNIT = 3739;
    exports$1.ER_SRS_INVALID_PRIME_MERIDIAN = 3740;
    exports$1.ER_TRANSFORM_SOURCE_SRS_NOT_SUPPORTED = 3741;
    exports$1.ER_TRANSFORM_TARGET_SRS_NOT_SUPPORTED = 3742;
    exports$1.ER_TRANSFORM_SOURCE_SRS_MISSING_TOWGS84 = 3743;
    exports$1.ER_TRANSFORM_TARGET_SRS_MISSING_TOWGS84 = 3744;
    exports$1.ER_TEMP_TABLE_PREVENTS_SWITCH_SESSION_BINLOG_FORMAT = 3745;
    exports$1.ER_TEMP_TABLE_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT = 3746;
    exports$1.ER_RUNNING_APPLIER_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT = 3747;
    exports$1.ER_CLIENT_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRX_IN_SBR = 3748;
    exports$1.ER_XA_CANT_CREATE_MDL_BACKUP = 3749;
    exports$1.ER_TABLE_WITHOUT_PK = 3750;
    exports$1.ER_WARN_DATA_TRUNCATED_FUNCTIONAL_INDEX = 3751;
    exports$1.ER_WARN_DATA_OUT_OF_RANGE_FUNCTIONAL_INDEX = 3752;
    exports$1.ER_FUNCTIONAL_INDEX_ON_JSON_OR_GEOMETRY_FUNCTION = 3753;
    exports$1.ER_FUNCTIONAL_INDEX_REF_AUTO_INCREMENT = 3754;
    exports$1.ER_CANNOT_DROP_COLUMN_FUNCTIONAL_INDEX = 3755;
    exports$1.ER_FUNCTIONAL_INDEX_PRIMARY_KEY = 3756;
    exports$1.ER_FUNCTIONAL_INDEX_ON_LOB = 3757;
    exports$1.ER_FUNCTIONAL_INDEX_FUNCTION_IS_NOT_ALLOWED = 3758;
    exports$1.ER_FULLTEXT_FUNCTIONAL_INDEX = 3759;
    exports$1.ER_SPATIAL_FUNCTIONAL_INDEX = 3760;
    exports$1.ER_WRONG_KEY_COLUMN_FUNCTIONAL_INDEX = 3761;
    exports$1.ER_FUNCTIONAL_INDEX_ON_FIELD = 3762;
    exports$1.ER_GENERATED_COLUMN_NAMED_FUNCTION_IS_NOT_ALLOWED = 3763;
    exports$1.ER_GENERATED_COLUMN_ROW_VALUE = 3764;
    exports$1.ER_GENERATED_COLUMN_VARIABLES = 3765;
    exports$1.ER_DEPENDENT_BY_DEFAULT_GENERATED_VALUE = 3766;
    exports$1.ER_DEFAULT_VAL_GENERATED_NON_PRIOR = 3767;
    exports$1.ER_DEFAULT_VAL_GENERATED_REF_AUTO_INC = 3768;
    exports$1.ER_DEFAULT_VAL_GENERATED_FUNCTION_IS_NOT_ALLOWED = 3769;
    exports$1.ER_DEFAULT_VAL_GENERATED_NAMED_FUNCTION_IS_NOT_ALLOWED = 3770;
    exports$1.ER_DEFAULT_VAL_GENERATED_ROW_VALUE = 3771;
    exports$1.ER_DEFAULT_VAL_GENERATED_VARIABLES = 3772;
    exports$1.ER_DEFAULT_AS_VAL_GENERATED = 3773;
    exports$1.ER_UNSUPPORTED_ACTION_ON_DEFAULT_VAL_GENERATED = 3774;
    exports$1.ER_GTID_UNSAFE_ALTER_ADD_COL_WITH_DEFAULT_EXPRESSION = 3775;
    exports$1.ER_FK_CANNOT_CHANGE_ENGINE = 3776;
    exports$1.ER_WARN_DEPRECATED_USER_SET_EXPR = 3777;
    exports$1.ER_WARN_DEPRECATED_UTF8MB3_COLLATION = 3778;
    exports$1.ER_WARN_DEPRECATED_NESTED_COMMENT_SYNTAX = 3779;
    exports$1.ER_FK_INCOMPATIBLE_COLUMNS = 3780;
    exports$1.ER_GR_HOLD_WAIT_TIMEOUT = 3781;
    exports$1.ER_GR_HOLD_KILLED = 3782;
    exports$1.ER_GR_HOLD_MEMBER_STATUS_ERROR = 3783;
    exports$1.ER_RPL_ENCRYPTION_FAILED_TO_FETCH_KEY = 3784;
    exports$1.ER_RPL_ENCRYPTION_KEY_NOT_FOUND = 3785;
    exports$1.ER_RPL_ENCRYPTION_KEYRING_INVALID_KEY = 3786;
    exports$1.ER_RPL_ENCRYPTION_HEADER_ERROR = 3787;
    exports$1.ER_RPL_ENCRYPTION_FAILED_TO_ROTATE_LOGS = 3788;
    exports$1.ER_RPL_ENCRYPTION_KEY_EXISTS_UNEXPECTED = 3789;
    exports$1.ER_RPL_ENCRYPTION_FAILED_TO_GENERATE_KEY = 3790;
    exports$1.ER_RPL_ENCRYPTION_FAILED_TO_STORE_KEY = 3791;
    exports$1.ER_RPL_ENCRYPTION_FAILED_TO_REMOVE_KEY = 3792;
    exports$1.ER_RPL_ENCRYPTION_UNABLE_TO_CHANGE_OPTION = 3793;
    exports$1.ER_RPL_ENCRYPTION_MASTER_KEY_RECOVERY_FAILED = 3794;
    exports$1.ER_SLOW_LOG_MODE_IGNORED_WHEN_NOT_LOGGING_TO_FILE = 3795;
    exports$1.ER_GRP_TRX_CONSISTENCY_NOT_ALLOWED = 3796;
    exports$1.ER_GRP_TRX_CONSISTENCY_BEFORE = 3797;
    exports$1.ER_GRP_TRX_CONSISTENCY_AFTER_ON_TRX_BEGIN = 3798;
    exports$1.ER_GRP_TRX_CONSISTENCY_BEGIN_NOT_ALLOWED = 3799;
    exports$1.ER_FUNCTIONAL_INDEX_ROW_VALUE_IS_NOT_ALLOWED = 3800;
    exports$1.ER_RPL_ENCRYPTION_FAILED_TO_ENCRYPT = 3801;
    exports$1.ER_PAGE_TRACKING_NOT_STARTED = 3802;
    exports$1.ER_PAGE_TRACKING_RANGE_NOT_TRACKED = 3803;
    exports$1.ER_PAGE_TRACKING_CANNOT_PURGE = 3804;
    exports$1.ER_RPL_ENCRYPTION_CANNOT_ROTATE_BINLOG_MASTER_KEY = 3805;
    exports$1.ER_BINLOG_MASTER_KEY_RECOVERY_OUT_OF_COMBINATION = 3806;
    exports$1.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_OPERATE_KEY = 3807;
    exports$1.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_ROTATE_LOGS = 3808;
    exports$1.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_REENCRYPT_LOG = 3809;
    exports$1.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_UNUSED_KEYS = 3810;
    exports$1.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_AUX_KEY = 3811;
    exports$1.ER_NON_BOOLEAN_EXPR_FOR_CHECK_CONSTRAINT = 3812;
    exports$1.ER_COLUMN_CHECK_CONSTRAINT_REFERENCES_OTHER_COLUMN = 3813;
    exports$1.ER_CHECK_CONSTRAINT_NAMED_FUNCTION_IS_NOT_ALLOWED = 3814;
    exports$1.ER_CHECK_CONSTRAINT_FUNCTION_IS_NOT_ALLOWED = 3815;
    exports$1.ER_CHECK_CONSTRAINT_VARIABLES = 3816;
    exports$1.ER_CHECK_CONSTRAINT_ROW_VALUE = 3817;
    exports$1.ER_CHECK_CONSTRAINT_REFERS_AUTO_INCREMENT_COLUMN = 3818;
    exports$1.ER_CHECK_CONSTRAINT_VIOLATED = 3819;
    exports$1.ER_CHECK_CONSTRAINT_REFERS_UNKNOWN_COLUMN = 3820;
    exports$1.ER_CHECK_CONSTRAINT_NOT_FOUND = 3821;
    exports$1.ER_CHECK_CONSTRAINT_DUP_NAME = 3822;
    exports$1.ER_CHECK_CONSTRAINT_CLAUSE_USING_FK_REFER_ACTION_COLUMN = 3823;
    exports$1.WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB = 3824;
    exports$1.ER_INVALID_ENCRYPTION_REQUEST = 3825;
    exports$1.ER_CANNOT_SET_TABLE_ENCRYPTION = 3826;
    exports$1.ER_CANNOT_SET_DATABASE_ENCRYPTION = 3827;
    exports$1.ER_CANNOT_SET_TABLESPACE_ENCRYPTION = 3828;
    exports$1.ER_TABLESPACE_CANNOT_BE_ENCRYPTED = 3829;
    exports$1.ER_TABLESPACE_CANNOT_BE_DECRYPTED = 3830;
    exports$1.ER_TABLESPACE_TYPE_UNKNOWN = 3831;
    exports$1.ER_TARGET_TABLESPACE_UNENCRYPTED = 3832;
    exports$1.ER_CANNOT_USE_ENCRYPTION_CLAUSE = 3833;
    exports$1.ER_INVALID_MULTIPLE_CLAUSES = 3834;
    exports$1.ER_UNSUPPORTED_USE_OF_GRANT_AS = 3835;
    exports$1.ER_UKNOWN_AUTH_ID_OR_ACCESS_DENIED_FOR_GRANT_AS = 3836;
    exports$1.ER_DEPENDENT_BY_FUNCTIONAL_INDEX = 3837;
    exports$1.ER_PLUGIN_NOT_EARLY = 3838;
    exports$1.ER_INNODB_REDO_LOG_ARCHIVE_START_SUBDIR_PATH = 3839;
    exports$1.ER_INNODB_REDO_LOG_ARCHIVE_START_TIMEOUT = 3840;
    exports$1.ER_INNODB_REDO_LOG_ARCHIVE_DIRS_INVALID = 3841;
    exports$1.ER_INNODB_REDO_LOG_ARCHIVE_LABEL_NOT_FOUND = 3842;
    exports$1.ER_INNODB_REDO_LOG_ARCHIVE_DIR_EMPTY = 3843;
    exports$1.ER_INNODB_REDO_LOG_ARCHIVE_NO_SUCH_DIR = 3844;
    exports$1.ER_INNODB_REDO_LOG_ARCHIVE_DIR_CLASH = 3845;
    exports$1.ER_INNODB_REDO_LOG_ARCHIVE_DIR_PERMISSIONS = 3846;
    exports$1.ER_INNODB_REDO_LOG_ARCHIVE_FILE_CREATE = 3847;
    exports$1.ER_INNODB_REDO_LOG_ARCHIVE_ACTIVE = 3848;
    exports$1.ER_INNODB_REDO_LOG_ARCHIVE_INACTIVE = 3849;
    exports$1.ER_INNODB_REDO_LOG_ARCHIVE_FAILED = 3850;
    exports$1.ER_INNODB_REDO_LOG_ARCHIVE_SESSION = 3851;
    exports$1.ER_STD_REGEX_ERROR = 3852;
    exports$1.ER_INVALID_JSON_TYPE = 3853;
    exports$1.ER_CANNOT_CONVERT_STRING = 3854;
    exports$1.ER_DEPENDENT_BY_PARTITION_FUNC = 3855;
    exports$1.ER_WARN_DEPRECATED_FLOAT_AUTO_INCREMENT = 3856;
    exports$1.ER_RPL_CANT_STOP_REPLICA_WHILE_LOCKED_BACKUP = 3857;
    exports$1.ER_WARN_DEPRECATED_FLOAT_DIGITS = 3858;
    exports$1.ER_WARN_DEPRECATED_FLOAT_UNSIGNED = 3859;
    exports$1.ER_WARN_DEPRECATED_INTEGER_DISPLAY_WIDTH = 3860;
    exports$1.ER_WARN_DEPRECATED_ZEROFILL = 3861;
    exports$1.ER_CLONE_DONOR = 3862;
    exports$1.ER_CLONE_PROTOCOL = 3863;
    exports$1.ER_CLONE_DONOR_VERSION = 3864;
    exports$1.ER_CLONE_OS = 3865;
    exports$1.ER_CLONE_PLATFORM = 3866;
    exports$1.ER_CLONE_CHARSET = 3867;
    exports$1.ER_CLONE_CONFIG = 3868;
    exports$1.ER_CLONE_SYS_CONFIG = 3869;
    exports$1.ER_CLONE_PLUGIN_MATCH = 3870;
    exports$1.ER_CLONE_LOOPBACK = 3871;
    exports$1.ER_CLONE_ENCRYPTION = 3872;
    exports$1.ER_CLONE_DISK_SPACE = 3873;
    exports$1.ER_CLONE_IN_PROGRESS = 3874;
    exports$1.ER_CLONE_DISALLOWED = 3875;
    exports$1.ER_CANNOT_GRANT_ROLES_TO_ANONYMOUS_USER = 3876;
    exports$1.ER_SECONDARY_ENGINE_PLUGIN = 3877;
    exports$1.ER_SECOND_PASSWORD_CANNOT_BE_EMPTY = 3878;
    exports$1.ER_DB_ACCESS_DENIED = 3879;
    exports$1.ER_DA_AUTH_ID_WITH_SYSTEM_USER_PRIV_IN_MANDATORY_ROLES = 3880;
    exports$1.ER_DA_RPL_GTID_TABLE_CANNOT_OPEN = 3881;
    exports$1.ER_GEOMETRY_IN_UNKNOWN_LENGTH_UNIT = 3882;
    exports$1.ER_DA_PLUGIN_INSTALL_ERROR = 3883;
    exports$1.ER_NO_SESSION_TEMP = 3884;
    exports$1.ER_DA_UNKNOWN_ERROR_NUMBER = 3885;
    exports$1.ER_COLUMN_CHANGE_SIZE = 3886;
    exports$1.ER_REGEXP_INVALID_CAPTURE_GROUP_NAME = 3887;
    exports$1.ER_DA_SSL_LIBRARY_ERROR = 3888;
    exports$1.ER_SECONDARY_ENGINE = 3889;
    exports$1.ER_SECONDARY_ENGINE_DDL = 3890;
    exports$1.ER_INCORRECT_CURRENT_PASSWORD = 3891;
    exports$1.ER_MISSING_CURRENT_PASSWORD = 3892;
    exports$1.ER_CURRENT_PASSWORD_NOT_REQUIRED = 3893;
    exports$1.ER_PASSWORD_CANNOT_BE_RETAINED_ON_PLUGIN_CHANGE = 3894;
    exports$1.ER_CURRENT_PASSWORD_CANNOT_BE_RETAINED = 3895;
    exports$1.ER_PARTIAL_REVOKES_EXIST = 3896;
    exports$1.ER_CANNOT_GRANT_SYSTEM_PRIV_TO_MANDATORY_ROLE = 3897;
    exports$1.ER_XA_REPLICATION_FILTERS = 3898;
    exports$1.ER_UNSUPPORTED_SQL_MODE = 3899;
    exports$1.ER_REGEXP_INVALID_FLAG = 3900;
    exports$1.ER_PARTIAL_REVOKE_AND_DB_GRANT_BOTH_EXISTS = 3901;
    exports$1.ER_UNIT_NOT_FOUND = 3902;
    exports$1.ER_INVALID_JSON_VALUE_FOR_FUNC_INDEX = 3903;
    exports$1.ER_JSON_VALUE_OUT_OF_RANGE_FOR_FUNC_INDEX = 3904;
    exports$1.ER_EXCEEDED_MV_KEYS_NUM = 3905;
    exports$1.ER_EXCEEDED_MV_KEYS_SPACE = 3906;
    exports$1.ER_FUNCTIONAL_INDEX_DATA_IS_TOO_LONG = 3907;
    exports$1.ER_WRONG_MVI_VALUE = 3908;
    exports$1.ER_WARN_FUNC_INDEX_NOT_APPLICABLE = 3909;
    exports$1.ER_GRP_RPL_UDF_ERROR = 3910;
    exports$1.ER_UPDATE_GTID_PURGED_WITH_GR = 3911;
    exports$1.ER_GROUPING_ON_TIMESTAMP_IN_DST = 3912;
    exports$1.ER_TABLE_NAME_CAUSES_TOO_LONG_PATH = 3913;
    exports$1.ER_AUDIT_LOG_INSUFFICIENT_PRIVILEGE = 3914;
    exports$1.ER_AUDIT_LOG_PASSWORD_HAS_BEEN_COPIED = 3915;
    exports$1.ER_DA_GRP_RPL_STARTED_AUTO_REJOIN = 3916;
    exports$1.ER_SYSVAR_CHANGE_DURING_QUERY = 3917;
    exports$1.ER_GLOBSTAT_CHANGE_DURING_QUERY = 3918;
    exports$1.ER_GRP_RPL_MESSAGE_SERVICE_INIT_FAILURE = 3919;
    exports$1.ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_CLIENT = 3920;
    exports$1.ER_CHANGE_SOURCE_WRONG_COMPRESSION_LEVEL_CLIENT = 3921;
    exports$1.ER_WRONG_COMPRESSION_ALGORITHM_CLIENT = 3922;
    exports$1.ER_WRONG_COMPRESSION_LEVEL_CLIENT = 3923;
    exports$1.ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_LIST_CLIENT = 3924;
    exports$1.ER_CLIENT_PRIVILEGE_CHECKS_USER_CANNOT_BE_ANONYMOUS = 3925;
    exports$1.ER_CLIENT_PRIVILEGE_CHECKS_USER_DOES_NOT_EXIST = 3926;
    exports$1.ER_CLIENT_PRIVILEGE_CHECKS_USER_CORRUPT = 3927;
    exports$1.ER_CLIENT_PRIVILEGE_CHECKS_USER_NEEDS_RPL_APPLIER_PRIV = 3928;
    exports$1.ER_WARN_DA_PRIVILEGE_NOT_REGISTERED = 3929;
    exports$1.ER_CLIENT_KEYRING_UDF_KEY_INVALID = 3930;
    exports$1.ER_CLIENT_KEYRING_UDF_KEY_TYPE_INVALID = 3931;
    exports$1.ER_CLIENT_KEYRING_UDF_KEY_TOO_LONG = 3932;
    exports$1.ER_CLIENT_KEYRING_UDF_KEY_TYPE_TOO_LONG = 3933;
    exports$1.ER_JSON_SCHEMA_VALIDATION_ERROR_WITH_DETAILED_REPORT = 3934;
    exports$1.ER_DA_UDF_INVALID_CHARSET_SPECIFIED = 3935;
    exports$1.ER_DA_UDF_INVALID_CHARSET = 3936;
    exports$1.ER_DA_UDF_INVALID_COLLATION = 3937;
    exports$1.ER_DA_UDF_INVALID_EXTENSION_ARGUMENT_TYPE = 3938;
    exports$1.ER_MULTIPLE_CONSTRAINTS_WITH_SAME_NAME = 3939;
    exports$1.ER_CONSTRAINT_NOT_FOUND = 3940;
    exports$1.ER_ALTER_CONSTRAINT_ENFORCEMENT_NOT_SUPPORTED = 3941;
    exports$1.ER_TABLE_VALUE_CONSTRUCTOR_MUST_HAVE_COLUMNS = 3942;
    exports$1.ER_TABLE_VALUE_CONSTRUCTOR_CANNOT_HAVE_DEFAULT = 3943;
    exports$1.ER_CLIENT_QUERY_FAILURE_INVALID_NON_ROW_FORMAT = 3944;
    exports$1.ER_REQUIRE_ROW_FORMAT_INVALID_VALUE = 3945;
    exports$1.ER_FAILED_TO_DETERMINE_IF_ROLE_IS_MANDATORY = 3946;
    exports$1.ER_FAILED_TO_FETCH_MANDATORY_ROLE_LIST = 3947;
    exports$1.ER_CLIENT_LOCAL_FILES_DISABLED = 3948;
    exports$1.ER_IMP_INCOMPATIBLE_CFG_VERSION = 3949;
    exports$1.ER_DA_OOM = 3950;
    exports$1.ER_DA_UDF_INVALID_ARGUMENT_TO_SET_CHARSET = 3951;
    exports$1.ER_DA_UDF_INVALID_RETURN_TYPE_TO_SET_CHARSET = 3952;
    exports$1.ER_MULTIPLE_INTO_CLAUSES = 3953;
    exports$1.ER_MISPLACED_INTO = 3954;
    exports$1.ER_USER_ACCESS_DENIED_FOR_USER_ACCOUNT_BLOCKED_BY_PASSWORD_LOCK = 3955;
    exports$1.ER_WARN_DEPRECATED_YEAR_UNSIGNED = 3956;
    exports$1.ER_CLONE_NETWORK_PACKET = 3957;
    exports$1.ER_SDI_OPERATION_FAILED_MISSING_RECORD = 3958;
    exports$1.ER_DEPENDENT_BY_CHECK_CONSTRAINT = 3959;
    exports$1.ER_GRP_OPERATION_NOT_ALLOWED_GR_MUST_STOP = 3960;
    exports$1.ER_WARN_DEPRECATED_JSON_TABLE_ON_ERROR_ON_EMPTY = 3961;
    exports$1.ER_WARN_DEPRECATED_INNER_INTO = 3962;
    exports$1.ER_WARN_DEPRECATED_VALUES_FUNCTION_ALWAYS_NULL = 3963;
    exports$1.ER_WARN_DEPRECATED_SQL_CALC_FOUND_ROWS = 3964;
    exports$1.ER_WARN_DEPRECATED_FOUND_ROWS = 3965;
    exports$1.ER_MISSING_JSON_VALUE = 3966;
    exports$1.ER_MULTIPLE_JSON_VALUES = 3967;
    exports$1.ER_HOSTNAME_TOO_LONG = 3968;
    exports$1.ER_WARN_CLIENT_DEPRECATED_PARTITION_PREFIX_KEY = 3969;
    exports$1.ER_GROUP_REPLICATION_USER_EMPTY_MSG = 3970;
    exports$1.ER_GROUP_REPLICATION_USER_MANDATORY_MSG = 3971;
    exports$1.ER_GROUP_REPLICATION_PASSWORD_LENGTH = 3972;
    exports$1.ER_SUBQUERY_TRANSFORM_REJECTED = 3973;
    exports$1.ER_DA_GRP_RPL_RECOVERY_ENDPOINT_FORMAT = 3974;
    exports$1.ER_DA_GRP_RPL_RECOVERY_ENDPOINT_INVALID = 3975;
    exports$1.ER_WRONG_VALUE_FOR_VAR_PLUS_ACTIONABLE_PART = 3976;
    exports$1.ER_STATEMENT_NOT_ALLOWED_AFTER_START_TRANSACTION = 3977;
    exports$1.ER_FOREIGN_KEY_WITH_ATOMIC_CREATE_SELECT = 3978;
    exports$1.ER_NOT_ALLOWED_WITH_START_TRANSACTION = 3979;
    exports$1.ER_INVALID_JSON_ATTRIBUTE = 3980;
    exports$1.ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED = 3981;
    exports$1.ER_INVALID_USER_ATTRIBUTE_JSON = 3982;
    exports$1.ER_INNODB_REDO_DISABLED = 3983;
    exports$1.ER_INNODB_REDO_ARCHIVING_ENABLED = 3984;
    exports$1.ER_MDL_OUT_OF_RESOURCES = 3985;
    exports$1.ER_IMPLICIT_COMPARISON_FOR_JSON = 3986;
    exports$1.ER_FUNCTION_DOES_NOT_SUPPORT_CHARACTER_SET = 3987;
    exports$1.ER_IMPOSSIBLE_STRING_CONVERSION = 3988;
    exports$1.ER_SCHEMA_READ_ONLY = 3989;
    exports$1.ER_RPL_ASYNC_RECONNECT_GTID_MODE_OFF = 3990;
    exports$1.ER_RPL_ASYNC_RECONNECT_AUTO_POSITION_OFF = 3991;
    exports$1.ER_DISABLE_GTID_MODE_REQUIRES_ASYNC_RECONNECT_OFF = 3992;
    exports$1.ER_DISABLE_AUTO_POSITION_REQUIRES_ASYNC_RECONNECT_OFF = 3993;
    exports$1.ER_INVALID_PARAMETER_USE = 3994;
    exports$1.ER_CHARACTER_SET_MISMATCH = 3995;
    exports$1.ER_WARN_VAR_VALUE_CHANGE_NOT_SUPPORTED = 3996;
    exports$1.ER_INVALID_TIME_ZONE_INTERVAL = 3997;
    exports$1.ER_INVALID_CAST = 3998;
    exports$1.ER_HYPERGRAPH_NOT_SUPPORTED_YET = 3999;
    exports$1.ER_WARN_HYPERGRAPH_EXPERIMENTAL = 4e3;
    exports$1.ER_DA_NO_ERROR_LOG_PARSER_CONFIGURED = 4001;
    exports$1.ER_DA_ERROR_LOG_TABLE_DISABLED = 4002;
    exports$1.ER_DA_ERROR_LOG_MULTIPLE_FILTERS = 4003;
    exports$1.ER_DA_CANT_OPEN_ERROR_LOG = 4004;
    exports$1.ER_USER_REFERENCED_AS_DEFINER = 4005;
    exports$1.ER_CANNOT_USER_REFERENCED_AS_DEFINER = 4006;
    exports$1.ER_REGEX_NUMBER_TOO_BIG = 4007;
    exports$1.ER_SPVAR_NONINTEGER_TYPE = 4008;
    exports$1.WARN_UNSUPPORTED_ACL_TABLES_READ = 4009;
    exports$1.ER_BINLOG_UNSAFE_ACL_TABLE_READ_IN_DML_DDL = 4010;
    exports$1.ER_STOP_REPLICA_MONITOR_IO_THREAD_TIMEOUT = 4011;
    exports$1.ER_STARTING_REPLICA_MONITOR_IO_THREAD = 4012;
    exports$1.ER_CANT_USE_ANONYMOUS_TO_GTID_WITH_GTID_MODE_NOT_ON = 4013;
    exports$1.ER_CANT_COMBINE_ANONYMOUS_TO_GTID_AND_AUTOPOSITION = 4014;
    exports$1.ER_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_REQUIRES_GTID_MODE_ON = 4015;
    exports$1.ER_SQL_REPLICA_SKIP_COUNTER_USED_WITH_GTID_MODE_ON = 4016;
    exports$1.ER_USING_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_AS_LOCAL_OR_UUID = 4017;
    exports$1.ER_CANT_SET_ANONYMOUS_TO_GTID_AND_WAIT_UNTIL_SQL_THD_AFTER_GTIDS = 4018;
    exports$1.ER_CANT_SET_SQL_AFTER_OR_BEFORE_GTIDS_WITH_ANONYMOUS_TO_GTID = 4019;
    exports$1.ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_GROUP_NAME = 4020;
    exports$1.ER_CANT_USE_SAME_UUID_AS_GROUP_NAME = 4021;
    exports$1.ER_GRP_RPL_RECOVERY_CHANNEL_STILL_RUNNING = 4022;
    exports$1.ER_INNODB_INVALID_AUTOEXTEND_SIZE_VALUE = 4023;
    exports$1.ER_INNODB_INCOMPATIBLE_WITH_TABLESPACE = 4024;
    exports$1.ER_INNODB_AUTOEXTEND_SIZE_OUT_OF_RANGE = 4025;
    exports$1.ER_CANNOT_USE_AUTOEXTEND_SIZE_CLAUSE = 4026;
    exports$1.ER_ROLE_GRANTED_TO_ITSELF = 4027;
    exports$1.ER_TABLE_MUST_HAVE_A_VISIBLE_COLUMN = 4028;
    exports$1.ER_INNODB_COMPRESSION_FAILURE = 4029;
    exports$1.ER_WARN_ASYNC_CONN_FAILOVER_NETWORK_NAMESPACE = 4030;
    exports$1.ER_CLIENT_INTERACTION_TIMEOUT = 4031;
    exports$1.ER_INVALID_CAST_TO_GEOMETRY = 4032;
    exports$1.ER_INVALID_CAST_POLYGON_RING_DIRECTION = 4033;
    exports$1.ER_GIS_DIFFERENT_SRIDS_AGGREGATION = 4034;
    exports$1.ER_RELOAD_KEYRING_FAILURE = 4035;
    exports$1.ER_SDI_GET_KEYS_INVALID_TABLESPACE = 4036;
    exports$1.ER_CHANGE_RPL_SRC_WRONG_COMPRESSION_ALGORITHM_SIZE = 4037;
    exports$1.ER_WARN_DEPRECATED_TLS_VERSION_FOR_CHANNEL_CLI = 4038;
    exports$1.ER_CANT_USE_SAME_UUID_AS_VIEW_CHANGE_UUID = 4039;
    exports$1.ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_VIEW_CHANGE_UUID = 4040;
    exports$1.ER_GRP_RPL_VIEW_CHANGE_UUID_FAIL_GET_VARIABLE = 4041;
    exports$1.ER_WARN_ADUIT_LOG_MAX_SIZE_AND_PRUNE_SECONDS = 4042;
    exports$1.ER_WARN_ADUIT_LOG_MAX_SIZE_CLOSE_TO_ROTATE_ON_SIZE = 4043;
    exports$1.ER_KERBEROS_CREATE_USER = 4044;
    exports$1.ER_INSTALL_PLUGIN_CONFLICT_CLIENT = 4045;
    exports$1.ER_DA_ERROR_LOG_COMPONENT_FLUSH_FAILED = 4046;
    exports$1.ER_WARN_SQL_AFTER_MTS_GAPS_GAP_NOT_CALCULATED = 4047;
    exports$1.ER_INVALID_ASSIGNMENT_TARGET = 4048;
    exports$1.ER_OPERATION_NOT_ALLOWED_ON_GR_SECONDARY = 4049;
    exports$1.ER_GRP_RPL_FAILOVER_CHANNEL_STATUS_PROPAGATION = 4050;
    exports$1.ER_WARN_AUDIT_LOG_FORMAT_UNIX_TIMESTAMP_ONLY_WHEN_JSON = 4051;
    exports$1.ER_INVALID_MFA_PLUGIN_SPECIFIED = 4052;
    exports$1.ER_IDENTIFIED_BY_UNSUPPORTED = 4053;
    exports$1.ER_INVALID_PLUGIN_FOR_REGISTRATION = 4054;
    exports$1.ER_PLUGIN_REQUIRES_REGISTRATION = 4055;
    exports$1.ER_MFA_METHOD_EXISTS = 4056;
    exports$1.ER_MFA_METHOD_NOT_EXISTS = 4057;
    exports$1.ER_AUTHENTICATION_POLICY_MISMATCH = 4058;
    exports$1.ER_PLUGIN_REGISTRATION_DONE = 4059;
    exports$1.ER_INVALID_USER_FOR_REGISTRATION = 4060;
    exports$1.ER_USER_REGISTRATION_FAILED = 4061;
    exports$1.ER_MFA_METHODS_INVALID_ORDER = 4062;
    exports$1.ER_MFA_METHODS_IDENTICAL = 4063;
    exports$1.ER_INVALID_MFA_OPERATIONS_FOR_PASSWORDLESS_USER = 4064;
    exports$1.ER_CHANGE_REPLICATION_SOURCE_NO_OPTIONS_FOR_GTID_ONLY = 4065;
    exports$1.ER_CHANGE_REP_SOURCE_CANT_DISABLE_REQ_ROW_FORMAT_WITH_GTID_ONLY = 4066;
    exports$1.ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POSITION_WITH_GTID_ONLY = 4067;
    exports$1.ER_CHANGE_REP_SOURCE_CANT_DISABLE_GTID_ONLY_WITHOUT_POSITIONS = 4068;
    exports$1.ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POS_WITHOUT_POSITIONS = 4069;
    exports$1.ER_CHANGE_REP_SOURCE_GR_CHANNEL_WITH_GTID_MODE_NOT_ON = 4070;
    exports$1.ER_CANT_USE_GTID_ONLY_WITH_GTID_MODE_NOT_ON = 4071;
    exports$1.ER_WARN_C_DISABLE_GTID_ONLY_WITH_SOURCE_AUTO_POS_INVALID_POS = 4072;
    exports$1.ER_DA_SSL_FIPS_MODE_ERROR = 4073;
    exports$1.ER_VALUE_OUT_OF_RANGE = 4074;
    exports$1.ER_FULLTEXT_WITH_ROLLUP = 4075;
    exports$1.ER_REGEXP_MISSING_RESOURCE = 4076;
    exports$1.ER_WARN_REGEXP_USING_DEFAULT = 4077;
    exports$1.ER_REGEXP_MISSING_FILE = 4078;
    exports$1.ER_WARN_DEPRECATED_COLLATION = 4079;
    exports$1.ER_CONCURRENT_PROCEDURE_USAGE = 4080;
    exports$1.ER_DA_GLOBAL_CONN_LIMIT = 4081;
    exports$1.ER_DA_CONN_LIMIT = 4082;
    exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE_INSTANT = 4083;
    exports$1.ER_WARN_SF_UDF_NAME_COLLISION = 4084;
    exports$1.ER_CANNOT_PURGE_BINLOG_WITH_BACKUP_LOCK = 4085;
    exports$1.ER_TOO_MANY_WINDOWS = 4086;
    exports$1.ER_MYSQLBACKUP_CLIENT_MSG = 4087;
    exports$1.ER_COMMENT_CONTAINS_INVALID_STRING = 4088;
    exports$1.ER_DEFINITION_CONTAINS_INVALID_STRING = 4089;
    exports$1.ER_CANT_EXECUTE_COMMAND_WITH_ASSIGNED_GTID_NEXT = 4090;
    exports$1.ER_XA_TEMP_TABLE = 4091;
    exports$1.ER_INNODB_MAX_ROW_VERSION = 4092;
    exports$1.ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_SIZE = 4093;
    exports$1.ER_OPERATION_NOT_ALLOWED_WHILE_PRIMARY_CHANGE_IS_RUNNING = 4094;
    exports$1.ER_WARN_DEPRECATED_DATETIME_DELIMITER = 4095;
    exports$1.ER_WARN_DEPRECATED_SUPERFLUOUS_DELIMITER = 4096;
    exports$1.ER_CANNOT_PERSIST_SENSITIVE_VARIABLES = 4097;
    exports$1.ER_WARN_CANNOT_SECURELY_PERSIST_SENSITIVE_VARIABLES = 4098;
    exports$1.ER_WARN_TRG_ALREADY_EXISTS = 4099;
    exports$1.ER_IF_NOT_EXISTS_UNSUPPORTED_TRG_EXISTS_ON_DIFFERENT_TABLE = 4100;
    exports$1.ER_IF_NOT_EXISTS_UNSUPPORTED_UDF_NATIVE_FCT_NAME_COLLISION = 4101;
    exports$1.ER_SET_PASSWORD_AUTH_PLUGIN_ERROR = 4102;
    exports$1.ER_REDUCED_DBLWR_FILE_CORRUPTED = 4103;
    exports$1.ER_REDUCED_DBLWR_PAGE_FOUND = 4104;
    exports$1.ER_SRS_INVALID_LATITUDE_OF_ORIGIN = 4105;
    exports$1.ER_SRS_INVALID_LONGITUDE_OF_ORIGIN = 4106;
    exports$1.ER_SRS_UNUSED_PROJ_PARAMETER_PRESENT = 4107;
    exports$1.ER_GIPK_COLUMN_EXISTS = 4108;
    exports$1.ER_GIPK_FAILED_AUTOINC_COLUMN_EXISTS = 4109;
    exports$1.ER_GIPK_COLUMN_ALTER_NOT_ALLOWED = 4110;
    exports$1.ER_DROP_PK_COLUMN_TO_DROP_GIPK = 4111;
    exports$1.ER_CREATE_SELECT_WITH_GIPK_DISALLOWED_IN_SBR = 4112;
    exports$1.ER_DA_EXPIRE_LOGS_DAYS_IGNORED = 4113;
    exports$1.ER_CTE_RECURSIVE_NOT_UNION = 4114;
    exports$1.ER_COMMAND_BACKEND_FAILED_TO_FETCH_SECURITY_CTX = 4115;
    exports$1.ER_COMMAND_SERVICE_BACKEND_FAILED = 4116;
    exports$1.ER_CLIENT_FILE_PRIVILEGE_FOR_REPLICATION_CHECKS = 4117;
    exports$1.ER_GROUP_REPLICATION_FORCE_MEMBERS_COMMAND_FAILURE = 4118;
    exports$1.ER_WARN_DEPRECATED_IDENT = 4119;
    exports$1.ER_INTERSECT_ALL_MAX_DUPLICATES_EXCEEDED = 4120;
    exports$1.ER_TP_QUERY_THRS_PER_GRP_EXCEEDS_TXN_THR_LIMIT = 4121;
    exports$1.ER_BAD_TIMESTAMP_FORMAT = 4122;
    exports$1.ER_SHAPE_PRIDICTION_UDF = 4123;
    exports$1.ER_SRS_INVALID_HEIGHT = 4124;
    exports$1.ER_SRS_INVALID_SCALING = 4125;
    exports$1.ER_SRS_INVALID_ZONE_WIDTH = 4126;
    exports$1.ER_SRS_INVALID_LATITUDE_POLAR_STERE_VAR_A = 4127;
    exports$1.ER_WARN_DEPRECATED_CLIENT_NO_SCHEMA_OPTION = 4128;
    exports$1.ER_TABLE_NOT_EMPTY = 4129;
    exports$1.ER_TABLE_NO_PRIMARY_KEY = 4130;
    exports$1.ER_TABLE_IN_SHARED_TABLESPACE = 4131;
    exports$1.ER_INDEX_OTHER_THAN_PK = 4132;
    exports$1.ER_LOAD_BULK_DATA_UNSORTED = 4133;
    exports$1.ER_BULK_EXECUTOR_ERROR = 4134;
    exports$1.ER_BULK_READER_LIBCURL_INIT_FAILED = 4135;
    exports$1.ER_BULK_READER_LIBCURL_ERROR = 4136;
    exports$1.ER_BULK_READER_SERVER_ERROR = 4137;
    exports$1.ER_BULK_READER_COMMUNICATION_ERROR = 4138;
    exports$1.ER_BULK_LOAD_DATA_FAILED = 4139;
    exports$1.ER_BULK_LOADER_COLUMN_TOO_BIG_FOR_LEFTOVER_BUFFER = 4140;
    exports$1.ER_BULK_LOADER_COMPONENT_ERROR = 4141;
    exports$1.ER_BULK_LOADER_FILE_CONTAINS_LESS_LINES_THAN_IGNORE_CLAUSE = 4142;
    exports$1.ER_BULK_PARSER_MISSING_ENCLOSED_BY = 4143;
    exports$1.ER_BULK_PARSER_ROW_BUFFER_MAX_TOTAL_COLS_EXCEEDED = 4144;
    exports$1.ER_BULK_PARSER_COPY_BUFFER_SIZE_EXCEEDED = 4145;
    exports$1.ER_BULK_PARSER_UNEXPECTED_END_OF_INPUT = 4146;
    exports$1.ER_BULK_PARSER_UNEXPECTED_ROW_TERMINATOR = 4147;
    exports$1.ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_ENDING_ENCLOSED_BY = 4148;
    exports$1.ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_NULL_ESCAPE = 4149;
    exports$1.ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_COLUMN_TERMINATOR = 4150;
    exports$1.ER_BULK_PARSER_INCOMPLETE_ESCAPE_SEQUENCE = 4151;
    exports$1.ER_LOAD_BULK_DATA_FAILED = 4152;
    exports$1.ER_LOAD_BULK_DATA_WRONG_VALUE_FOR_FIELD = 4153;
    exports$1.ER_LOAD_BULK_DATA_WARN_NULL_TO_NOTNULL = 4154;
    exports$1.ER_REQUIRE_TABLE_PRIMARY_KEY_CHECK_GENERATE_WITH_GR = 4155;
    exports$1.ER_CANT_CHANGE_SYS_VAR_IN_READ_ONLY_MODE = 4156;
    exports$1.ER_INNODB_INSTANT_ADD_DROP_NOT_SUPPORTED_MAX_SIZE = 4157;
    exports$1.ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_FIELDS = 4158;
    exports$1.ER_CANT_SET_PERSISTED = 4159;
    exports$1.ER_INSTALL_COMPONENT_SET_NULL_VALUE = 4160;
    exports$1.ER_INSTALL_COMPONENT_SET_UNUSED_VALUE = 4161;
    exports$1.ER_WARN_DEPRECATED_USER_DEFINED_COLLATIONS = 4162;
    exports$1[1] = "EE_CANTCREATEFILE";
    exports$1[2] = "EE_READ";
    exports$1[3] = "EE_WRITE";
    exports$1[4] = "EE_BADCLOSE";
    exports$1[5] = "EE_OUTOFMEMORY";
    exports$1[6] = "EE_DELETE";
    exports$1[7] = "EE_LINK";
    exports$1[9] = "EE_EOFERR";
    exports$1[10] = "EE_CANTLOCK";
    exports$1[11] = "EE_CANTUNLOCK";
    exports$1[12] = "EE_DIR";
    exports$1[13] = "EE_STAT";
    exports$1[14] = "EE_CANT_CHSIZE";
    exports$1[15] = "EE_CANT_OPEN_STREAM";
    exports$1[16] = "EE_GETWD";
    exports$1[17] = "EE_SETWD";
    exports$1[18] = "EE_LINK_WARNING";
    exports$1[19] = "EE_OPEN_WARNING";
    exports$1[20] = "EE_DISK_FULL";
    exports$1[21] = "EE_CANT_MKDIR";
    exports$1[22] = "EE_UNKNOWN_CHARSET";
    exports$1[23] = "EE_OUT_OF_FILERESOURCES";
    exports$1[24] = "EE_CANT_READLINK";
    exports$1[25] = "EE_CANT_SYMLINK";
    exports$1[26] = "EE_REALPATH";
    exports$1[27] = "EE_SYNC";
    exports$1[28] = "EE_UNKNOWN_COLLATION";
    exports$1[29] = "EE_FILENOTFOUND";
    exports$1[30] = "EE_FILE_NOT_CLOSED";
    exports$1[31] = "EE_CHANGE_OWNERSHIP";
    exports$1[32] = "EE_CHANGE_PERMISSIONS";
    exports$1[33] = "EE_CANT_SEEK";
    exports$1[34] = "EE_CAPACITY_EXCEEDED";
    exports$1[35] = "EE_DISK_FULL_WITH_RETRY_MSG";
    exports$1[36] = "EE_FAILED_TO_CREATE_TIMER";
    exports$1[37] = "EE_FAILED_TO_DELETE_TIMER";
    exports$1[38] = "EE_FAILED_TO_CREATE_TIMER_QUEUE";
    exports$1[39] = "EE_FAILED_TO_START_TIMER_NOTIFY_THREAD";
    exports$1[40] = "EE_FAILED_TO_CREATE_TIMER_NOTIFY_THREAD_INTERRUPT_EVENT";
    exports$1[41] = "EE_EXITING_TIMER_NOTIFY_THREAD";
    exports$1[42] = "EE_WIN_LIBRARY_LOAD_FAILED";
    exports$1[43] = "EE_WIN_RUN_TIME_ERROR_CHECK";
    exports$1[44] = "EE_FAILED_TO_DETERMINE_LARGE_PAGE_SIZE";
    exports$1[45] = "EE_FAILED_TO_KILL_ALL_THREADS";
    exports$1[46] = "EE_FAILED_TO_CREATE_IO_COMPLETION_PORT";
    exports$1[47] = "EE_FAILED_TO_OPEN_DEFAULTS_FILE";
    exports$1[48] = "EE_FAILED_TO_HANDLE_DEFAULTS_FILE";
    exports$1[49] = "EE_WRONG_DIRECTIVE_IN_CONFIG_FILE";
    exports$1[50] = "EE_SKIPPING_DIRECTIVE_DUE_TO_MAX_INCLUDE_RECURSION";
    exports$1[51] = "EE_INCORRECT_GRP_DEFINITION_IN_CONFIG_FILE";
    exports$1[52] = "EE_OPTION_WITHOUT_GRP_IN_CONFIG_FILE";
    exports$1[53] = "EE_CONFIG_FILE_PERMISSION_ERROR";
    exports$1[54] = "EE_IGNORE_WORLD_WRITABLE_CONFIG_FILE";
    exports$1[55] = "EE_USING_DISABLED_OPTION";
    exports$1[56] = "EE_USING_DISABLED_SHORT_OPTION";
    exports$1[57] = "EE_USING_PASSWORD_ON_CLI_IS_INSECURE";
    exports$1[58] = "EE_UNKNOWN_SUFFIX_FOR_VARIABLE";
    exports$1[59] = "EE_SSL_ERROR_FROM_FILE";
    exports$1[60] = "EE_SSL_ERROR";
    exports$1[61] = "EE_NET_SEND_ERROR_IN_BOOTSTRAP";
    exports$1[62] = "EE_PACKETS_OUT_OF_ORDER";
    exports$1[63] = "EE_UNKNOWN_PROTOCOL_OPTION";
    exports$1[64] = "EE_FAILED_TO_LOCATE_SERVER_PUBLIC_KEY";
    exports$1[65] = "EE_PUBLIC_KEY_NOT_IN_PEM_FORMAT";
    exports$1[66] = "EE_DEBUG_INFO";
    exports$1[67] = "EE_UNKNOWN_VARIABLE";
    exports$1[68] = "EE_UNKNOWN_OPTION";
    exports$1[69] = "EE_UNKNOWN_SHORT_OPTION";
    exports$1[70] = "EE_OPTION_WITHOUT_ARGUMENT";
    exports$1[71] = "EE_OPTION_REQUIRES_ARGUMENT";
    exports$1[72] = "EE_SHORT_OPTION_REQUIRES_ARGUMENT";
    exports$1[73] = "EE_OPTION_IGNORED_DUE_TO_INVALID_VALUE";
    exports$1[74] = "EE_OPTION_WITH_EMPTY_VALUE";
    exports$1[75] = "EE_FAILED_TO_ASSIGN_MAX_VALUE_TO_OPTION";
    exports$1[76] = "EE_INCORRECT_BOOLEAN_VALUE_FOR_OPTION";
    exports$1[77] = "EE_FAILED_TO_SET_OPTION_VALUE";
    exports$1[78] = "EE_INCORRECT_INT_VALUE_FOR_OPTION";
    exports$1[79] = "EE_INCORRECT_UINT_VALUE_FOR_OPTION";
    exports$1[80] = "EE_ADJUSTED_SIGNED_VALUE_FOR_OPTION";
    exports$1[81] = "EE_ADJUSTED_UNSIGNED_VALUE_FOR_OPTION";
    exports$1[82] = "EE_ADJUSTED_ULONGLONG_VALUE_FOR_OPTION";
    exports$1[83] = "EE_ADJUSTED_DOUBLE_VALUE_FOR_OPTION";
    exports$1[84] = "EE_INVALID_DECIMAL_VALUE_FOR_OPTION";
    exports$1[85] = "EE_COLLATION_PARSER_ERROR";
    exports$1[86] = "EE_FAILED_TO_RESET_BEFORE_PRIMARY_IGNORABLE_CHAR";
    exports$1[87] = "EE_FAILED_TO_RESET_BEFORE_TERTIARY_IGNORABLE_CHAR";
    exports$1[88] = "EE_SHIFT_CHAR_OUT_OF_RANGE";
    exports$1[89] = "EE_RESET_CHAR_OUT_OF_RANGE";
    exports$1[90] = "EE_UNKNOWN_LDML_TAG";
    exports$1[91] = "EE_FAILED_TO_RESET_BEFORE_SECONDARY_IGNORABLE_CHAR";
    exports$1[92] = "EE_FAILED_PROCESSING_DIRECTIVE";
    exports$1[93] = "EE_PTHREAD_KILL_FAILED";
    exports$1[120] = "HA_ERR_KEY_NOT_FOUND";
    exports$1[121] = "HA_ERR_FOUND_DUPP_KEY";
    exports$1[122] = "HA_ERR_INTERNAL_ERROR";
    exports$1[123] = "HA_ERR_RECORD_CHANGED";
    exports$1[124] = "HA_ERR_WRONG_INDEX";
    exports$1[125] = "HA_ERR_ROLLED_BACK";
    exports$1[126] = "HA_ERR_CRASHED";
    exports$1[127] = "HA_ERR_WRONG_IN_RECORD";
    exports$1[128] = "HA_ERR_OUT_OF_MEM";
    exports$1[130] = "HA_ERR_NOT_A_TABLE";
    exports$1[131] = "HA_ERR_WRONG_COMMAND";
    exports$1[132] = "HA_ERR_OLD_FILE";
    exports$1[133] = "HA_ERR_NO_ACTIVE_RECORD";
    exports$1[134] = "HA_ERR_RECORD_DELETED";
    exports$1[135] = "HA_ERR_RECORD_FILE_FULL";
    exports$1[136] = "HA_ERR_INDEX_FILE_FULL";
    exports$1[137] = "HA_ERR_END_OF_FILE";
    exports$1[138] = "HA_ERR_UNSUPPORTED";
    exports$1[139] = "HA_ERR_TOO_BIG_ROW";
    exports$1[140] = "HA_WRONG_CREATE_OPTION";
    exports$1[141] = "HA_ERR_FOUND_DUPP_UNIQUE";
    exports$1[142] = "HA_ERR_UNKNOWN_CHARSET";
    exports$1[143] = "HA_ERR_WRONG_MRG_TABLE_DEF";
    exports$1[144] = "HA_ERR_CRASHED_ON_REPAIR";
    exports$1[145] = "HA_ERR_CRASHED_ON_USAGE";
    exports$1[146] = "HA_ERR_LOCK_WAIT_TIMEOUT";
    exports$1[147] = "HA_ERR_LOCK_TABLE_FULL";
    exports$1[148] = "HA_ERR_READ_ONLY_TRANSACTION";
    exports$1[149] = "HA_ERR_LOCK_DEADLOCK";
    exports$1[150] = "HA_ERR_CANNOT_ADD_FOREIGN";
    exports$1[151] = "HA_ERR_NO_REFERENCED_ROW";
    exports$1[152] = "HA_ERR_ROW_IS_REFERENCED";
    exports$1[153] = "HA_ERR_NO_SAVEPOINT";
    exports$1[154] = "HA_ERR_NON_UNIQUE_BLOCK_SIZE";
    exports$1[155] = "HA_ERR_NO_SUCH_TABLE";
    exports$1[156] = "HA_ERR_TABLE_EXIST";
    exports$1[157] = "HA_ERR_NO_CONNECTION";
    exports$1[158] = "HA_ERR_NULL_IN_SPATIAL";
    exports$1[159] = "HA_ERR_TABLE_DEF_CHANGED";
    exports$1[160] = "HA_ERR_NO_PARTITION_FOUND";
    exports$1[161] = "HA_ERR_RBR_LOGGING_FAILED";
    exports$1[162] = "HA_ERR_DROP_INDEX_FK";
    exports$1[163] = "HA_ERR_FOREIGN_DUPLICATE_KEY";
    exports$1[164] = "HA_ERR_TABLE_NEEDS_UPGRADE";
    exports$1[165] = "HA_ERR_TABLE_READONLY";
    exports$1[166] = "HA_ERR_AUTOINC_READ_FAILED";
    exports$1[167] = "HA_ERR_AUTOINC_ERANGE";
    exports$1[168] = "HA_ERR_GENERIC";
    exports$1[169] = "HA_ERR_RECORD_IS_THE_SAME";
    exports$1[170] = "HA_ERR_LOGGING_IMPOSSIBLE";
    exports$1[171] = "HA_ERR_CORRUPT_EVENT";
    exports$1[172] = "HA_ERR_NEW_FILE";
    exports$1[173] = "HA_ERR_ROWS_EVENT_APPLY";
    exports$1[174] = "HA_ERR_INITIALIZATION";
    exports$1[175] = "HA_ERR_FILE_TOO_SHORT";
    exports$1[176] = "HA_ERR_WRONG_CRC";
    exports$1[177] = "HA_ERR_TOO_MANY_CONCURRENT_TRXS";
    exports$1[178] = "HA_ERR_NOT_IN_LOCK_PARTITIONS";
    exports$1[179] = "HA_ERR_INDEX_COL_TOO_LONG";
    exports$1[180] = "HA_ERR_INDEX_CORRUPT";
    exports$1[181] = "HA_ERR_UNDO_REC_TOO_BIG";
    exports$1[182] = "HA_FTS_INVALID_DOCID";
    exports$1[183] = "HA_ERR_TABLE_IN_FK_CHECK";
    exports$1[184] = "HA_ERR_TABLESPACE_EXISTS";
    exports$1[185] = "HA_ERR_TOO_MANY_FIELDS";
    exports$1[186] = "HA_ERR_ROW_IN_WRONG_PARTITION";
    exports$1[187] = "HA_ERR_INNODB_READ_ONLY";
    exports$1[188] = "HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT";
    exports$1[189] = "HA_ERR_TEMP_FILE_WRITE_FAILURE";
    exports$1[190] = "HA_ERR_INNODB_FORCED_RECOVERY";
    exports$1[191] = "HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE";
    exports$1[192] = "HA_ERR_FK_DEPTH_EXCEEDED";
    exports$1[193] = "HA_MISSING_CREATE_OPTION";
    exports$1[194] = "HA_ERR_SE_OUT_OF_MEMORY";
    exports$1[195] = "HA_ERR_TABLE_CORRUPT";
    exports$1[196] = "HA_ERR_QUERY_INTERRUPTED";
    exports$1[197] = "HA_ERR_TABLESPACE_MISSING";
    exports$1[198] = "HA_ERR_TABLESPACE_IS_NOT_EMPTY";
    exports$1[199] = "HA_ERR_WRONG_FILE_NAME";
    exports$1[200] = "HA_ERR_NOT_ALLOWED_COMMAND";
    exports$1[201] = "HA_ERR_COMPUTE_FAILED";
    exports$1[202] = "HA_ERR_ROW_FORMAT_CHANGED";
    exports$1[203] = "HA_ERR_NO_WAIT_LOCK";
    exports$1[204] = "HA_ERR_DISK_FULL_NOWAIT";
    exports$1[205] = "HA_ERR_NO_SESSION_TEMP";
    exports$1[206] = "HA_ERR_WRONG_TABLE_NAME";
    exports$1[207] = "HA_ERR_TOO_LONG_PATH";
    exports$1[208] = "HA_ERR_SAMPLING_INIT_FAILED";
    exports$1[209] = "HA_ERR_FTS_TOO_MANY_NESTED_EXP";
    exports$1[1e3] = "ER_HASHCHK";
    exports$1[1001] = "ER_NISAMCHK";
    exports$1[1002] = "ER_NO";
    exports$1[1003] = "ER_YES";
    exports$1[1004] = "ER_CANT_CREATE_FILE";
    exports$1[1005] = "ER_CANT_CREATE_TABLE";
    exports$1[1006] = "ER_CANT_CREATE_DB";
    exports$1[1007] = "ER_DB_CREATE_EXISTS";
    exports$1[1008] = "ER_DB_DROP_EXISTS";
    exports$1[1009] = "ER_DB_DROP_DELETE";
    exports$1[1010] = "ER_DB_DROP_RMDIR";
    exports$1[1011] = "ER_CANT_DELETE_FILE";
    exports$1[1012] = "ER_CANT_FIND_SYSTEM_REC";
    exports$1[1013] = "ER_CANT_GET_STAT";
    exports$1[1014] = "ER_CANT_GET_WD";
    exports$1[1015] = "ER_CANT_LOCK";
    exports$1[1016] = "ER_CANT_OPEN_FILE";
    exports$1[1017] = "ER_FILE_NOT_FOUND";
    exports$1[1018] = "ER_CANT_READ_DIR";
    exports$1[1019] = "ER_CANT_SET_WD";
    exports$1[1020] = "ER_CHECKREAD";
    exports$1[1021] = "ER_DISK_FULL";
    exports$1[1022] = "ER_DUP_KEY";
    exports$1[1023] = "ER_ERROR_ON_CLOSE";
    exports$1[1024] = "ER_ERROR_ON_READ";
    exports$1[1025] = "ER_ERROR_ON_RENAME";
    exports$1[1026] = "ER_ERROR_ON_WRITE";
    exports$1[1027] = "ER_FILE_USED";
    exports$1[1028] = "ER_FILSORT_ABORT";
    exports$1[1029] = "ER_FORM_NOT_FOUND";
    exports$1[1030] = "ER_GET_ERRNO";
    exports$1[1031] = "ER_ILLEGAL_HA";
    exports$1[1032] = "ER_KEY_NOT_FOUND";
    exports$1[1033] = "ER_NOT_FORM_FILE";
    exports$1[1034] = "ER_NOT_KEYFILE";
    exports$1[1035] = "ER_OLD_KEYFILE";
    exports$1[1036] = "ER_OPEN_AS_READONLY";
    exports$1[1037] = "ER_OUTOFMEMORY";
    exports$1[1038] = "ER_OUT_OF_SORTMEMORY";
    exports$1[1039] = "ER_UNEXPECTED_EOF";
    exports$1[1040] = "ER_CON_COUNT_ERROR";
    exports$1[1041] = "ER_OUT_OF_RESOURCES";
    exports$1[1042] = "ER_BAD_HOST_ERROR";
    exports$1[1043] = "ER_HANDSHAKE_ERROR";
    exports$1[1044] = "ER_DBACCESS_DENIED_ERROR";
    exports$1[1045] = "ER_ACCESS_DENIED_ERROR";
    exports$1[1046] = "ER_NO_DB_ERROR";
    exports$1[1047] = "ER_UNKNOWN_COM_ERROR";
    exports$1[1048] = "ER_BAD_NULL_ERROR";
    exports$1[1049] = "ER_BAD_DB_ERROR";
    exports$1[1050] = "ER_TABLE_EXISTS_ERROR";
    exports$1[1051] = "ER_BAD_TABLE_ERROR";
    exports$1[1052] = "ER_NON_UNIQ_ERROR";
    exports$1[1053] = "ER_SERVER_SHUTDOWN";
    exports$1[1054] = "ER_BAD_FIELD_ERROR";
    exports$1[1055] = "ER_WRONG_FIELD_WITH_GROUP";
    exports$1[1056] = "ER_WRONG_GROUP_FIELD";
    exports$1[1057] = "ER_WRONG_SUM_SELECT";
    exports$1[1058] = "ER_WRONG_VALUE_COUNT";
    exports$1[1059] = "ER_TOO_LONG_IDENT";
    exports$1[1060] = "ER_DUP_FIELDNAME";
    exports$1[1061] = "ER_DUP_KEYNAME";
    exports$1[1062] = "ER_DUP_ENTRY";
    exports$1[1063] = "ER_WRONG_FIELD_SPEC";
    exports$1[1064] = "ER_PARSE_ERROR";
    exports$1[1065] = "ER_EMPTY_QUERY";
    exports$1[1066] = "ER_NONUNIQ_TABLE";
    exports$1[1067] = "ER_INVALID_DEFAULT";
    exports$1[1068] = "ER_MULTIPLE_PRI_KEY";
    exports$1[1069] = "ER_TOO_MANY_KEYS";
    exports$1[1070] = "ER_TOO_MANY_KEY_PARTS";
    exports$1[1071] = "ER_TOO_LONG_KEY";
    exports$1[1072] = "ER_KEY_COLUMN_DOES_NOT_EXITS";
    exports$1[1073] = "ER_BLOB_USED_AS_KEY";
    exports$1[1074] = "ER_TOO_BIG_FIELDLENGTH";
    exports$1[1075] = "ER_WRONG_AUTO_KEY";
    exports$1[1076] = "ER_READY";
    exports$1[1077] = "ER_NORMAL_SHUTDOWN";
    exports$1[1078] = "ER_GOT_SIGNAL";
    exports$1[1079] = "ER_SHUTDOWN_COMPLETE";
    exports$1[1080] = "ER_FORCING_CLOSE";
    exports$1[1081] = "ER_IPSOCK_ERROR";
    exports$1[1082] = "ER_NO_SUCH_INDEX";
    exports$1[1083] = "ER_WRONG_FIELD_TERMINATORS";
    exports$1[1084] = "ER_BLOBS_AND_NO_TERMINATED";
    exports$1[1085] = "ER_TEXTFILE_NOT_READABLE";
    exports$1[1086] = "ER_FILE_EXISTS_ERROR";
    exports$1[1087] = "ER_LOAD_INFO";
    exports$1[1088] = "ER_ALTER_INFO";
    exports$1[1089] = "ER_WRONG_SUB_KEY";
    exports$1[1090] = "ER_CANT_REMOVE_ALL_FIELDS";
    exports$1[1091] = "ER_CANT_DROP_FIELD_OR_KEY";
    exports$1[1092] = "ER_INSERT_INFO";
    exports$1[1093] = "ER_UPDATE_TABLE_USED";
    exports$1[1094] = "ER_NO_SUCH_THREAD";
    exports$1[1095] = "ER_KILL_DENIED_ERROR";
    exports$1[1096] = "ER_NO_TABLES_USED";
    exports$1[1097] = "ER_TOO_BIG_SET";
    exports$1[1098] = "ER_NO_UNIQUE_LOGFILE";
    exports$1[1099] = "ER_TABLE_NOT_LOCKED_FOR_WRITE";
    exports$1[1100] = "ER_TABLE_NOT_LOCKED";
    exports$1[1101] = "ER_BLOB_CANT_HAVE_DEFAULT";
    exports$1[1102] = "ER_WRONG_DB_NAME";
    exports$1[1103] = "ER_WRONG_TABLE_NAME";
    exports$1[1104] = "ER_TOO_BIG_SELECT";
    exports$1[1105] = "ER_UNKNOWN_ERROR";
    exports$1[1106] = "ER_UNKNOWN_PROCEDURE";
    exports$1[1107] = "ER_WRONG_PARAMCOUNT_TO_PROCEDURE";
    exports$1[1108] = "ER_WRONG_PARAMETERS_TO_PROCEDURE";
    exports$1[1109] = "ER_UNKNOWN_TABLE";
    exports$1[1110] = "ER_FIELD_SPECIFIED_TWICE";
    exports$1[1111] = "ER_INVALID_GROUP_FUNC_USE";
    exports$1[1112] = "ER_UNSUPPORTED_EXTENSION";
    exports$1[1113] = "ER_TABLE_MUST_HAVE_COLUMNS";
    exports$1[1114] = "ER_RECORD_FILE_FULL";
    exports$1[1115] = "ER_UNKNOWN_CHARACTER_SET";
    exports$1[1116] = "ER_TOO_MANY_TABLES";
    exports$1[1117] = "ER_TOO_MANY_FIELDS";
    exports$1[1118] = "ER_TOO_BIG_ROWSIZE";
    exports$1[1119] = "ER_STACK_OVERRUN";
    exports$1[1120] = "ER_WRONG_OUTER_JOIN";
    exports$1[1121] = "ER_NULL_COLUMN_IN_INDEX";
    exports$1[1122] = "ER_CANT_FIND_UDF";
    exports$1[1123] = "ER_CANT_INITIALIZE_UDF";
    exports$1[1124] = "ER_UDF_NO_PATHS";
    exports$1[1125] = "ER_UDF_EXISTS";
    exports$1[1126] = "ER_CANT_OPEN_LIBRARY";
    exports$1[1127] = "ER_CANT_FIND_DL_ENTRY";
    exports$1[1128] = "ER_FUNCTION_NOT_DEFINED";
    exports$1[1129] = "ER_HOST_IS_BLOCKED";
    exports$1[1130] = "ER_HOST_NOT_PRIVILEGED";
    exports$1[1131] = "ER_PASSWORD_ANONYMOUS_USER";
    exports$1[1132] = "ER_PASSWORD_NOT_ALLOWED";
    exports$1[1133] = "ER_PASSWORD_NO_MATCH";
    exports$1[1134] = "ER_UPDATE_INFO";
    exports$1[1135] = "ER_CANT_CREATE_THREAD";
    exports$1[1136] = "ER_WRONG_VALUE_COUNT_ON_ROW";
    exports$1[1137] = "ER_CANT_REOPEN_TABLE";
    exports$1[1138] = "ER_INVALID_USE_OF_NULL";
    exports$1[1139] = "ER_REGEXP_ERROR";
    exports$1[1140] = "ER_MIX_OF_GROUP_FUNC_AND_FIELDS";
    exports$1[1141] = "ER_NONEXISTING_GRANT";
    exports$1[1142] = "ER_TABLEACCESS_DENIED_ERROR";
    exports$1[1143] = "ER_COLUMNACCESS_DENIED_ERROR";
    exports$1[1144] = "ER_ILLEGAL_GRANT_FOR_TABLE";
    exports$1[1145] = "ER_GRANT_WRONG_HOST_OR_USER";
    exports$1[1146] = "ER_NO_SUCH_TABLE";
    exports$1[1147] = "ER_NONEXISTING_TABLE_GRANT";
    exports$1[1148] = "ER_NOT_ALLOWED_COMMAND";
    exports$1[1149] = "ER_SYNTAX_ERROR";
    exports$1[1150] = "ER_UNUSED1";
    exports$1[1151] = "ER_UNUSED2";
    exports$1[1152] = "ER_ABORTING_CONNECTION";
    exports$1[1153] = "ER_NET_PACKET_TOO_LARGE";
    exports$1[1154] = "ER_NET_READ_ERROR_FROM_PIPE";
    exports$1[1155] = "ER_NET_FCNTL_ERROR";
    exports$1[1156] = "ER_NET_PACKETS_OUT_OF_ORDER";
    exports$1[1157] = "ER_NET_UNCOMPRESS_ERROR";
    exports$1[1158] = "ER_NET_READ_ERROR";
    exports$1[1159] = "ER_NET_READ_INTERRUPTED";
    exports$1[1160] = "ER_NET_ERROR_ON_WRITE";
    exports$1[1161] = "ER_NET_WRITE_INTERRUPTED";
    exports$1[1162] = "ER_TOO_LONG_STRING";
    exports$1[1163] = "ER_TABLE_CANT_HANDLE_BLOB";
    exports$1[1164] = "ER_TABLE_CANT_HANDLE_AUTO_INCREMENT";
    exports$1[1165] = "ER_UNUSED3";
    exports$1[1166] = "ER_WRONG_COLUMN_NAME";
    exports$1[1167] = "ER_WRONG_KEY_COLUMN";
    exports$1[1168] = "ER_WRONG_MRG_TABLE";
    exports$1[1169] = "ER_DUP_UNIQUE";
    exports$1[1170] = "ER_BLOB_KEY_WITHOUT_LENGTH";
    exports$1[1171] = "ER_PRIMARY_CANT_HAVE_NULL";
    exports$1[1172] = "ER_TOO_MANY_ROWS";
    exports$1[1173] = "ER_REQUIRES_PRIMARY_KEY";
    exports$1[1174] = "ER_NO_RAID_COMPILED";
    exports$1[1175] = "ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE";
    exports$1[1176] = "ER_KEY_DOES_NOT_EXITS";
    exports$1[1177] = "ER_CHECK_NO_SUCH_TABLE";
    exports$1[1178] = "ER_CHECK_NOT_IMPLEMENTED";
    exports$1[1179] = "ER_CANT_DO_THIS_DURING_AN_TRANSACTION";
    exports$1[1180] = "ER_ERROR_DURING_COMMIT";
    exports$1[1181] = "ER_ERROR_DURING_ROLLBACK";
    exports$1[1182] = "ER_ERROR_DURING_FLUSH_LOGS";
    exports$1[1183] = "ER_ERROR_DURING_CHECKPOINT";
    exports$1[1184] = "ER_NEW_ABORTING_CONNECTION";
    exports$1[1185] = "ER_DUMP_NOT_IMPLEMENTED";
    exports$1[1186] = "ER_FLUSH_MASTER_BINLOG_CLOSED";
    exports$1[1187] = "ER_INDEX_REBUILD";
    exports$1[1188] = "ER_SOURCE";
    exports$1[1189] = "ER_SOURCE_NET_READ";
    exports$1[1190] = "ER_SOURCE_NET_WRITE";
    exports$1[1191] = "ER_FT_MATCHING_KEY_NOT_FOUND";
    exports$1[1192] = "ER_LOCK_OR_ACTIVE_TRANSACTION";
    exports$1[1193] = "ER_UNKNOWN_SYSTEM_VARIABLE";
    exports$1[1194] = "ER_CRASHED_ON_USAGE";
    exports$1[1195] = "ER_CRASHED_ON_REPAIR";
    exports$1[1196] = "ER_WARNING_NOT_COMPLETE_ROLLBACK";
    exports$1[1197] = "ER_TRANS_CACHE_FULL";
    exports$1[1198] = "ER_SLAVE_MUST_STOP";
    exports$1[1199] = "ER_REPLICA_NOT_RUNNING";
    exports$1[1200] = "ER_BAD_REPLICA";
    exports$1[1201] = "ER_CONNECTION_METADATA";
    exports$1[1202] = "ER_REPLICA_THREAD";
    exports$1[1203] = "ER_TOO_MANY_USER_CONNECTIONS";
    exports$1[1204] = "ER_SET_CONSTANTS_ONLY";
    exports$1[1205] = "ER_LOCK_WAIT_TIMEOUT";
    exports$1[1206] = "ER_LOCK_TABLE_FULL";
    exports$1[1207] = "ER_READ_ONLY_TRANSACTION";
    exports$1[1208] = "ER_DROP_DB_WITH_READ_LOCK";
    exports$1[1209] = "ER_CREATE_DB_WITH_READ_LOCK";
    exports$1[1210] = "ER_WRONG_ARGUMENTS";
    exports$1[1211] = "ER_NO_PERMISSION_TO_CREATE_USER";
    exports$1[1212] = "ER_UNION_TABLES_IN_DIFFERENT_DIR";
    exports$1[1213] = "ER_LOCK_DEADLOCK";
    exports$1[1214] = "ER_TABLE_CANT_HANDLE_FT";
    exports$1[1215] = "ER_CANNOT_ADD_FOREIGN";
    exports$1[1216] = "ER_NO_REFERENCED_ROW";
    exports$1[1217] = "ER_ROW_IS_REFERENCED";
    exports$1[1218] = "ER_CONNECT_TO_SOURCE";
    exports$1[1219] = "ER_QUERY_ON_MASTER";
    exports$1[1220] = "ER_ERROR_WHEN_EXECUTING_COMMAND";
    exports$1[1221] = "ER_WRONG_USAGE";
    exports$1[1222] = "ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT";
    exports$1[1223] = "ER_CANT_UPDATE_WITH_READLOCK";
    exports$1[1224] = "ER_MIXING_NOT_ALLOWED";
    exports$1[1225] = "ER_DUP_ARGUMENT";
    exports$1[1226] = "ER_USER_LIMIT_REACHED";
    exports$1[1227] = "ER_SPECIFIC_ACCESS_DENIED_ERROR";
    exports$1[1228] = "ER_LOCAL_VARIABLE";
    exports$1[1229] = "ER_GLOBAL_VARIABLE";
    exports$1[1230] = "ER_NO_DEFAULT";
    exports$1[1231] = "ER_WRONG_VALUE_FOR_VAR";
    exports$1[1232] = "ER_WRONG_TYPE_FOR_VAR";
    exports$1[1233] = "ER_VAR_CANT_BE_READ";
    exports$1[1234] = "ER_CANT_USE_OPTION_HERE";
    exports$1[1235] = "ER_NOT_SUPPORTED_YET";
    exports$1[1236] = "ER_SOURCE_FATAL_ERROR_READING_BINLOG";
    exports$1[1237] = "ER_REPLICA_IGNORED_TABLE";
    exports$1[1238] = "ER_INCORRECT_GLOBAL_LOCAL_VAR";
    exports$1[1239] = "ER_WRONG_FK_DEF";
    exports$1[1240] = "ER_KEY_REF_DO_NOT_MATCH_TABLE_REF";
    exports$1[1241] = "ER_OPERAND_COLUMNS";
    exports$1[1242] = "ER_SUBQUERY_NO_1_ROW";
    exports$1[1243] = "ER_UNKNOWN_STMT_HANDLER";
    exports$1[1244] = "ER_CORRUPT_HELP_DB";
    exports$1[1245] = "ER_CYCLIC_REFERENCE";
    exports$1[1246] = "ER_AUTO_CONVERT";
    exports$1[1247] = "ER_ILLEGAL_REFERENCE";
    exports$1[1248] = "ER_DERIVED_MUST_HAVE_ALIAS";
    exports$1[1249] = "ER_SELECT_REDUCED";
    exports$1[1250] = "ER_TABLENAME_NOT_ALLOWED_HERE";
    exports$1[1251] = "ER_NOT_SUPPORTED_AUTH_MODE";
    exports$1[1252] = "ER_SPATIAL_CANT_HAVE_NULL";
    exports$1[1253] = "ER_COLLATION_CHARSET_MISMATCH";
    exports$1[1254] = "ER_SLAVE_WAS_RUNNING";
    exports$1[1255] = "ER_SLAVE_WAS_NOT_RUNNING";
    exports$1[1256] = "ER_TOO_BIG_FOR_UNCOMPRESS";
    exports$1[1257] = "ER_ZLIB_Z_MEM_ERROR";
    exports$1[1258] = "ER_ZLIB_Z_BUF_ERROR";
    exports$1[1259] = "ER_ZLIB_Z_DATA_ERROR";
    exports$1[1260] = "ER_CUT_VALUE_GROUP_CONCAT";
    exports$1[1261] = "ER_WARN_TOO_FEW_RECORDS";
    exports$1[1262] = "ER_WARN_TOO_MANY_RECORDS";
    exports$1[1263] = "ER_WARN_NULL_TO_NOTNULL";
    exports$1[1264] = "ER_WARN_DATA_OUT_OF_RANGE";
    exports$1[1265] = "WARN_DATA_TRUNCATED";
    exports$1[1266] = "ER_WARN_USING_OTHER_HANDLER";
    exports$1[1267] = "ER_CANT_AGGREGATE_2COLLATIONS";
    exports$1[1268] = "ER_DROP_USER";
    exports$1[1269] = "ER_REVOKE_GRANTS";
    exports$1[1270] = "ER_CANT_AGGREGATE_3COLLATIONS";
    exports$1[1271] = "ER_CANT_AGGREGATE_NCOLLATIONS";
    exports$1[1272] = "ER_VARIABLE_IS_NOT_STRUCT";
    exports$1[1273] = "ER_UNKNOWN_COLLATION";
    exports$1[1274] = "ER_REPLICA_IGNORED_SSL_PARAMS";
    exports$1[1275] = "ER_SERVER_IS_IN_SECURE_AUTH_MODE";
    exports$1[1276] = "ER_WARN_FIELD_RESOLVED";
    exports$1[1277] = "ER_BAD_REPLICA_UNTIL_COND";
    exports$1[1278] = "ER_MISSING_SKIP_REPLICA";
    exports$1[1279] = "ER_UNTIL_COND_IGNORED";
    exports$1[1280] = "ER_WRONG_NAME_FOR_INDEX";
    exports$1[1281] = "ER_WRONG_NAME_FOR_CATALOG";
    exports$1[1282] = "ER_WARN_QC_RESIZE";
    exports$1[1283] = "ER_BAD_FT_COLUMN";
    exports$1[1284] = "ER_UNKNOWN_KEY_CACHE";
    exports$1[1285] = "ER_WARN_HOSTNAME_WONT_WORK";
    exports$1[1286] = "ER_UNKNOWN_STORAGE_ENGINE";
    exports$1[1287] = "ER_WARN_DEPRECATED_SYNTAX";
    exports$1[1288] = "ER_NON_UPDATABLE_TABLE";
    exports$1[1289] = "ER_FEATURE_DISABLED";
    exports$1[1290] = "ER_OPTION_PREVENTS_STATEMENT";
    exports$1[1291] = "ER_DUPLICATED_VALUE_IN_TYPE";
    exports$1[1292] = "ER_TRUNCATED_WRONG_VALUE";
    exports$1[1293] = "ER_TOO_MUCH_AUTO_TIMESTAMP_COLS";
    exports$1[1294] = "ER_INVALID_ON_UPDATE";
    exports$1[1295] = "ER_UNSUPPORTED_PS";
    exports$1[1296] = "ER_GET_ERRMSG";
    exports$1[1297] = "ER_GET_TEMPORARY_ERRMSG";
    exports$1[1298] = "ER_UNKNOWN_TIME_ZONE";
    exports$1[1299] = "ER_WARN_INVALID_TIMESTAMP";
    exports$1[1300] = "ER_INVALID_CHARACTER_STRING";
    exports$1[1301] = "ER_WARN_ALLOWED_PACKET_OVERFLOWED";
    exports$1[1302] = "ER_CONFLICTING_DECLARATIONS";
    exports$1[1303] = "ER_SP_NO_RECURSIVE_CREATE";
    exports$1[1304] = "ER_SP_ALREADY_EXISTS";
    exports$1[1305] = "ER_SP_DOES_NOT_EXIST";
    exports$1[1306] = "ER_SP_DROP_FAILED";
    exports$1[1307] = "ER_SP_STORE_FAILED";
    exports$1[1308] = "ER_SP_LILABEL_MISMATCH";
    exports$1[1309] = "ER_SP_LABEL_REDEFINE";
    exports$1[1310] = "ER_SP_LABEL_MISMATCH";
    exports$1[1311] = "ER_SP_UNINIT_VAR";
    exports$1[1312] = "ER_SP_BADSELECT";
    exports$1[1313] = "ER_SP_BADRETURN";
    exports$1[1314] = "ER_SP_BADSTATEMENT";
    exports$1[1315] = "ER_UPDATE_LOG_DEPRECATED_IGNORED";
    exports$1[1316] = "ER_UPDATE_LOG_DEPRECATED_TRANSLATED";
    exports$1[1317] = "ER_QUERY_INTERRUPTED";
    exports$1[1318] = "ER_SP_WRONG_NO_OF_ARGS";
    exports$1[1319] = "ER_SP_COND_MISMATCH";
    exports$1[1320] = "ER_SP_NORETURN";
    exports$1[1321] = "ER_SP_NORETURNEND";
    exports$1[1322] = "ER_SP_BAD_CURSOR_QUERY";
    exports$1[1323] = "ER_SP_BAD_CURSOR_SELECT";
    exports$1[1324] = "ER_SP_CURSOR_MISMATCH";
    exports$1[1325] = "ER_SP_CURSOR_ALREADY_OPEN";
    exports$1[1326] = "ER_SP_CURSOR_NOT_OPEN";
    exports$1[1327] = "ER_SP_UNDECLARED_VAR";
    exports$1[1328] = "ER_SP_WRONG_NO_OF_FETCH_ARGS";
    exports$1[1329] = "ER_SP_FETCH_NO_DATA";
    exports$1[1330] = "ER_SP_DUP_PARAM";
    exports$1[1331] = "ER_SP_DUP_VAR";
    exports$1[1332] = "ER_SP_DUP_COND";
    exports$1[1333] = "ER_SP_DUP_CURS";
    exports$1[1334] = "ER_SP_CANT_ALTER";
    exports$1[1335] = "ER_SP_SUBSELECT_NYI";
    exports$1[1336] = "ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG";
    exports$1[1337] = "ER_SP_VARCOND_AFTER_CURSHNDLR";
    exports$1[1338] = "ER_SP_CURSOR_AFTER_HANDLER";
    exports$1[1339] = "ER_SP_CASE_NOT_FOUND";
    exports$1[1340] = "ER_FPARSER_TOO_BIG_FILE";
    exports$1[1341] = "ER_FPARSER_BAD_HEADER";
    exports$1[1342] = "ER_FPARSER_EOF_IN_COMMENT";
    exports$1[1343] = "ER_FPARSER_ERROR_IN_PARAMETER";
    exports$1[1344] = "ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER";
    exports$1[1345] = "ER_VIEW_NO_EXPLAIN";
    exports$1[1346] = "ER_FRM_UNKNOWN_TYPE";
    exports$1[1347] = "ER_WRONG_OBJECT";
    exports$1[1348] = "ER_NONUPDATEABLE_COLUMN";
    exports$1[1349] = "ER_VIEW_SELECT_DERIVED";
    exports$1[1350] = "ER_VIEW_SELECT_CLAUSE";
    exports$1[1351] = "ER_VIEW_SELECT_VARIABLE";
    exports$1[1352] = "ER_VIEW_SELECT_TMPTABLE";
    exports$1[1353] = "ER_VIEW_WRONG_LIST";
    exports$1[1354] = "ER_WARN_VIEW_MERGE";
    exports$1[1355] = "ER_WARN_VIEW_WITHOUT_KEY";
    exports$1[1356] = "ER_VIEW_INVALID";
    exports$1[1357] = "ER_SP_NO_DROP_SP";
    exports$1[1358] = "ER_SP_GOTO_IN_HNDLR";
    exports$1[1359] = "ER_TRG_ALREADY_EXISTS";
    exports$1[1360] = "ER_TRG_DOES_NOT_EXIST";
    exports$1[1361] = "ER_TRG_ON_VIEW_OR_TEMP_TABLE";
    exports$1[1362] = "ER_TRG_CANT_CHANGE_ROW";
    exports$1[1363] = "ER_TRG_NO_SUCH_ROW_IN_TRG";
    exports$1[1364] = "ER_NO_DEFAULT_FOR_FIELD";
    exports$1[1365] = "ER_DIVISION_BY_ZERO";
    exports$1[1366] = "ER_TRUNCATED_WRONG_VALUE_FOR_FIELD";
    exports$1[1367] = "ER_ILLEGAL_VALUE_FOR_TYPE";
    exports$1[1368] = "ER_VIEW_NONUPD_CHECK";
    exports$1[1369] = "ER_VIEW_CHECK_FAILED";
    exports$1[1370] = "ER_PROCACCESS_DENIED_ERROR";
    exports$1[1371] = "ER_RELAY_LOG_FAIL";
    exports$1[1372] = "ER_PASSWD_LENGTH";
    exports$1[1373] = "ER_UNKNOWN_TARGET_BINLOG";
    exports$1[1374] = "ER_IO_ERR_LOG_INDEX_READ";
    exports$1[1375] = "ER_BINLOG_PURGE_PROHIBITED";
    exports$1[1376] = "ER_FSEEK_FAIL";
    exports$1[1377] = "ER_BINLOG_PURGE_FATAL_ERR";
    exports$1[1378] = "ER_LOG_IN_USE";
    exports$1[1379] = "ER_LOG_PURGE_UNKNOWN_ERR";
    exports$1[1380] = "ER_RELAY_LOG_INIT";
    exports$1[1381] = "ER_NO_BINARY_LOGGING";
    exports$1[1382] = "ER_RESERVED_SYNTAX";
    exports$1[1383] = "ER_WSAS_FAILED";
    exports$1[1384] = "ER_DIFF_GROUPS_PROC";
    exports$1[1385] = "ER_NO_GROUP_FOR_PROC";
    exports$1[1386] = "ER_ORDER_WITH_PROC";
    exports$1[1387] = "ER_LOGGING_PROHIBIT_CHANGING_OF";
    exports$1[1388] = "ER_NO_FILE_MAPPING";
    exports$1[1389] = "ER_WRONG_MAGIC";
    exports$1[1390] = "ER_PS_MANY_PARAM";
    exports$1[1391] = "ER_KEY_PART_0";
    exports$1[1392] = "ER_VIEW_CHECKSUM";
    exports$1[1393] = "ER_VIEW_MULTIUPDATE";
    exports$1[1394] = "ER_VIEW_NO_INSERT_FIELD_LIST";
    exports$1[1395] = "ER_VIEW_DELETE_MERGE_VIEW";
    exports$1[1396] = "ER_CANNOT_USER";
    exports$1[1397] = "ER_XAER_NOTA";
    exports$1[1398] = "ER_XAER_INVAL";
    exports$1[1399] = "ER_XAER_RMFAIL";
    exports$1[1400] = "ER_XAER_OUTSIDE";
    exports$1[1401] = "ER_XAER_RMERR";
    exports$1[1402] = "ER_XA_RBROLLBACK";
    exports$1[1403] = "ER_NONEXISTING_PROC_GRANT";
    exports$1[1404] = "ER_PROC_AUTO_GRANT_FAIL";
    exports$1[1405] = "ER_PROC_AUTO_REVOKE_FAIL";
    exports$1[1406] = "ER_DATA_TOO_LONG";
    exports$1[1407] = "ER_SP_BAD_SQLSTATE";
    exports$1[1408] = "ER_STARTUP";
    exports$1[1409] = "ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR";
    exports$1[1410] = "ER_CANT_CREATE_USER_WITH_GRANT";
    exports$1[1411] = "ER_WRONG_VALUE_FOR_TYPE";
    exports$1[1412] = "ER_TABLE_DEF_CHANGED";
    exports$1[1413] = "ER_SP_DUP_HANDLER";
    exports$1[1414] = "ER_SP_NOT_VAR_ARG";
    exports$1[1415] = "ER_SP_NO_RETSET";
    exports$1[1416] = "ER_CANT_CREATE_GEOMETRY_OBJECT";
    exports$1[1417] = "ER_FAILED_ROUTINE_BREAK_BINLOG";
    exports$1[1418] = "ER_BINLOG_UNSAFE_ROUTINE";
    exports$1[1419] = "ER_BINLOG_CREATE_ROUTINE_NEED_SUPER";
    exports$1[1420] = "ER_EXEC_STMT_WITH_OPEN_CURSOR";
    exports$1[1421] = "ER_STMT_HAS_NO_OPEN_CURSOR";
    exports$1[1422] = "ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG";
    exports$1[1423] = "ER_NO_DEFAULT_FOR_VIEW_FIELD";
    exports$1[1424] = "ER_SP_NO_RECURSION";
    exports$1[1425] = "ER_TOO_BIG_SCALE";
    exports$1[1426] = "ER_TOO_BIG_PRECISION";
    exports$1[1427] = "ER_M_BIGGER_THAN_D";
    exports$1[1428] = "ER_WRONG_LOCK_OF_SYSTEM_TABLE";
    exports$1[1429] = "ER_CONNECT_TO_FOREIGN_DATA_SOURCE";
    exports$1[1430] = "ER_QUERY_ON_FOREIGN_DATA_SOURCE";
    exports$1[1431] = "ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST";
    exports$1[1432] = "ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE";
    exports$1[1433] = "ER_FOREIGN_DATA_STRING_INVALID";
    exports$1[1434] = "ER_CANT_CREATE_FEDERATED_TABLE";
    exports$1[1435] = "ER_TRG_IN_WRONG_SCHEMA";
    exports$1[1436] = "ER_STACK_OVERRUN_NEED_MORE";
    exports$1[1437] = "ER_TOO_LONG_BODY";
    exports$1[1438] = "ER_WARN_CANT_DROP_DEFAULT_KEYCACHE";
    exports$1[1439] = "ER_TOO_BIG_DISPLAYWIDTH";
    exports$1[1440] = "ER_XAER_DUPID";
    exports$1[1441] = "ER_DATETIME_FUNCTION_OVERFLOW";
    exports$1[1442] = "ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG";
    exports$1[1443] = "ER_VIEW_PREVENT_UPDATE";
    exports$1[1444] = "ER_PS_NO_RECURSION";
    exports$1[1445] = "ER_SP_CANT_SET_AUTOCOMMIT";
    exports$1[1446] = "ER_MALFORMED_DEFINER";
    exports$1[1447] = "ER_VIEW_FRM_NO_USER";
    exports$1[1448] = "ER_VIEW_OTHER_USER";
    exports$1[1449] = "ER_NO_SUCH_USER";
    exports$1[1450] = "ER_FORBID_SCHEMA_CHANGE";
    exports$1[1451] = "ER_ROW_IS_REFERENCED_2";
    exports$1[1452] = "ER_NO_REFERENCED_ROW_2";
    exports$1[1453] = "ER_SP_BAD_VAR_SHADOW";
    exports$1[1454] = "ER_TRG_NO_DEFINER";
    exports$1[1455] = "ER_OLD_FILE_FORMAT";
    exports$1[1456] = "ER_SP_RECURSION_LIMIT";
    exports$1[1457] = "ER_SP_PROC_TABLE_CORRUPT";
    exports$1[1458] = "ER_SP_WRONG_NAME";
    exports$1[1459] = "ER_TABLE_NEEDS_UPGRADE";
    exports$1[1460] = "ER_SP_NO_AGGREGATE";
    exports$1[1461] = "ER_MAX_PREPARED_STMT_COUNT_REACHED";
    exports$1[1462] = "ER_VIEW_RECURSIVE";
    exports$1[1463] = "ER_NON_GROUPING_FIELD_USED";
    exports$1[1464] = "ER_TABLE_CANT_HANDLE_SPKEYS";
    exports$1[1465] = "ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA";
    exports$1[1466] = "ER_REMOVED_SPACES";
    exports$1[1467] = "ER_AUTOINC_READ_FAILED";
    exports$1[1468] = "ER_USERNAME";
    exports$1[1469] = "ER_HOSTNAME";
    exports$1[1470] = "ER_WRONG_STRING_LENGTH";
    exports$1[1471] = "ER_NON_INSERTABLE_TABLE";
    exports$1[1472] = "ER_ADMIN_WRONG_MRG_TABLE";
    exports$1[1473] = "ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT";
    exports$1[1474] = "ER_NAME_BECOMES_EMPTY";
    exports$1[1475] = "ER_AMBIGUOUS_FIELD_TERM";
    exports$1[1476] = "ER_FOREIGN_SERVER_EXISTS";
    exports$1[1477] = "ER_FOREIGN_SERVER_DOESNT_EXIST";
    exports$1[1478] = "ER_ILLEGAL_HA_CREATE_OPTION";
    exports$1[1479] = "ER_PARTITION_REQUIRES_VALUES_ERROR";
    exports$1[1480] = "ER_PARTITION_WRONG_VALUES_ERROR";
    exports$1[1481] = "ER_PARTITION_MAXVALUE_ERROR";
    exports$1[1482] = "ER_PARTITION_SUBPARTITION_ERROR";
    exports$1[1483] = "ER_PARTITION_SUBPART_MIX_ERROR";
    exports$1[1484] = "ER_PARTITION_WRONG_NO_PART_ERROR";
    exports$1[1485] = "ER_PARTITION_WRONG_NO_SUBPART_ERROR";
    exports$1[1486] = "ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR";
    exports$1[1487] = "ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR";
    exports$1[1488] = "ER_FIELD_NOT_FOUND_PART_ERROR";
    exports$1[1489] = "ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR";
    exports$1[1490] = "ER_INCONSISTENT_PARTITION_INFO_ERROR";
    exports$1[1491] = "ER_PARTITION_FUNC_NOT_ALLOWED_ERROR";
    exports$1[1492] = "ER_PARTITIONS_MUST_BE_DEFINED_ERROR";
    exports$1[1493] = "ER_RANGE_NOT_INCREASING_ERROR";
    exports$1[1494] = "ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR";
    exports$1[1495] = "ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR";
    exports$1[1496] = "ER_PARTITION_ENTRY_ERROR";
    exports$1[1497] = "ER_MIX_HANDLER_ERROR";
    exports$1[1498] = "ER_PARTITION_NOT_DEFINED_ERROR";
    exports$1[1499] = "ER_TOO_MANY_PARTITIONS_ERROR";
    exports$1[1500] = "ER_SUBPARTITION_ERROR";
    exports$1[1501] = "ER_CANT_CREATE_HANDLER_FILE";
    exports$1[1502] = "ER_BLOB_FIELD_IN_PART_FUNC_ERROR";
    exports$1[1503] = "ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF";
    exports$1[1504] = "ER_NO_PARTS_ERROR";
    exports$1[1505] = "ER_PARTITION_MGMT_ON_NONPARTITIONED";
    exports$1[1506] = "ER_FOREIGN_KEY_ON_PARTITIONED";
    exports$1[1507] = "ER_DROP_PARTITION_NON_EXISTENT";
    exports$1[1508] = "ER_DROP_LAST_PARTITION";
    exports$1[1509] = "ER_COALESCE_ONLY_ON_HASH_PARTITION";
    exports$1[1510] = "ER_REORG_HASH_ONLY_ON_SAME_NO";
    exports$1[1511] = "ER_REORG_NO_PARAM_ERROR";
    exports$1[1512] = "ER_ONLY_ON_RANGE_LIST_PARTITION";
    exports$1[1513] = "ER_ADD_PARTITION_SUBPART_ERROR";
    exports$1[1514] = "ER_ADD_PARTITION_NO_NEW_PARTITION";
    exports$1[1515] = "ER_COALESCE_PARTITION_NO_PARTITION";
    exports$1[1516] = "ER_REORG_PARTITION_NOT_EXIST";
    exports$1[1517] = "ER_SAME_NAME_PARTITION";
    exports$1[1518] = "ER_NO_BINLOG_ERROR";
    exports$1[1519] = "ER_CONSECUTIVE_REORG_PARTITIONS";
    exports$1[1520] = "ER_REORG_OUTSIDE_RANGE";
    exports$1[1521] = "ER_PARTITION_FUNCTION_FAILURE";
    exports$1[1522] = "ER_PART_STATE_ERROR";
    exports$1[1523] = "ER_LIMITED_PART_RANGE";
    exports$1[1524] = "ER_PLUGIN_IS_NOT_LOADED";
    exports$1[1525] = "ER_WRONG_VALUE";
    exports$1[1526] = "ER_NO_PARTITION_FOR_GIVEN_VALUE";
    exports$1[1527] = "ER_FILEGROUP_OPTION_ONLY_ONCE";
    exports$1[1528] = "ER_CREATE_FILEGROUP_FAILED";
    exports$1[1529] = "ER_DROP_FILEGROUP_FAILED";
    exports$1[1530] = "ER_TABLESPACE_AUTO_EXTEND_ERROR";
    exports$1[1531] = "ER_WRONG_SIZE_NUMBER";
    exports$1[1532] = "ER_SIZE_OVERFLOW_ERROR";
    exports$1[1533] = "ER_ALTER_FILEGROUP_FAILED";
    exports$1[1534] = "ER_BINLOG_ROW_LOGGING_FAILED";
    exports$1[1535] = "ER_BINLOG_ROW_WRONG_TABLE_DEF";
    exports$1[1536] = "ER_BINLOG_ROW_RBR_TO_SBR";
    exports$1[1537] = "ER_EVENT_ALREADY_EXISTS";
    exports$1[1538] = "ER_EVENT_STORE_FAILED";
    exports$1[1539] = "ER_EVENT_DOES_NOT_EXIST";
    exports$1[1540] = "ER_EVENT_CANT_ALTER";
    exports$1[1541] = "ER_EVENT_DROP_FAILED";
    exports$1[1542] = "ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG";
    exports$1[1543] = "ER_EVENT_ENDS_BEFORE_STARTS";
    exports$1[1544] = "ER_EVENT_EXEC_TIME_IN_THE_PAST";
    exports$1[1545] = "ER_EVENT_OPEN_TABLE_FAILED";
    exports$1[1546] = "ER_EVENT_NEITHER_M_EXPR_NOR_M_AT";
    exports$1[1547] = "ER_COL_COUNT_DOESNT_MATCH_CORRUPTED";
    exports$1[1548] = "ER_CANNOT_LOAD_FROM_TABLE";
    exports$1[1549] = "ER_EVENT_CANNOT_DELETE";
    exports$1[1550] = "ER_EVENT_COMPILE_ERROR";
    exports$1[1551] = "ER_EVENT_SAME_NAME";
    exports$1[1552] = "ER_EVENT_DATA_TOO_LONG";
    exports$1[1553] = "ER_DROP_INDEX_FK";
    exports$1[1554] = "ER_WARN_DEPRECATED_SYNTAX_WITH_VER";
    exports$1[1555] = "ER_CANT_WRITE_LOCK_LOG_TABLE";
    exports$1[1556] = "ER_CANT_LOCK_LOG_TABLE";
    exports$1[1557] = "ER_FOREIGN_DUPLICATE_KEY";
    exports$1[1558] = "ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE";
    exports$1[1559] = "ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR";
    exports$1[1560] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT";
    exports$1[1561] = "ER_NDB_CANT_SWITCH_BINLOG_FORMAT";
    exports$1[1562] = "ER_PARTITION_NO_TEMPORARY";
    exports$1[1563] = "ER_PARTITION_CONST_DOMAIN_ERROR";
    exports$1[1564] = "ER_PARTITION_FUNCTION_IS_NOT_ALLOWED";
    exports$1[1565] = "ER_DDL_LOG_ERROR";
    exports$1[1566] = "ER_NULL_IN_VALUES_LESS_THAN";
    exports$1[1567] = "ER_WRONG_PARTITION_NAME";
    exports$1[1568] = "ER_CANT_CHANGE_TX_CHARACTERISTICS";
    exports$1[1569] = "ER_DUP_ENTRY_AUTOINCREMENT_CASE";
    exports$1[1570] = "ER_EVENT_MODIFY_QUEUE_ERROR";
    exports$1[1571] = "ER_EVENT_SET_VAR_ERROR";
    exports$1[1572] = "ER_PARTITION_MERGE_ERROR";
    exports$1[1573] = "ER_CANT_ACTIVATE_LOG";
    exports$1[1574] = "ER_RBR_NOT_AVAILABLE";
    exports$1[1575] = "ER_BASE64_DECODE_ERROR";
    exports$1[1576] = "ER_EVENT_RECURSION_FORBIDDEN";
    exports$1[1577] = "ER_EVENTS_DB_ERROR";
    exports$1[1578] = "ER_ONLY_INTEGERS_ALLOWED";
    exports$1[1579] = "ER_UNSUPORTED_LOG_ENGINE";
    exports$1[1580] = "ER_BAD_LOG_STATEMENT";
    exports$1[1581] = "ER_CANT_RENAME_LOG_TABLE";
    exports$1[1582] = "ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT";
    exports$1[1583] = "ER_WRONG_PARAMETERS_TO_NATIVE_FCT";
    exports$1[1584] = "ER_WRONG_PARAMETERS_TO_STORED_FCT";
    exports$1[1585] = "ER_NATIVE_FCT_NAME_COLLISION";
    exports$1[1586] = "ER_DUP_ENTRY_WITH_KEY_NAME";
    exports$1[1587] = "ER_BINLOG_PURGE_EMFILE";
    exports$1[1588] = "ER_EVENT_CANNOT_CREATE_IN_THE_PAST";
    exports$1[1589] = "ER_EVENT_CANNOT_ALTER_IN_THE_PAST";
    exports$1[1590] = "ER_SLAVE_INCIDENT";
    exports$1[1591] = "ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT";
    exports$1[1592] = "ER_BINLOG_UNSAFE_STATEMENT";
    exports$1[1593] = "ER_BINLOG_FATAL_ERROR";
    exports$1[1594] = "ER_SLAVE_RELAY_LOG_READ_FAILURE";
    exports$1[1595] = "ER_SLAVE_RELAY_LOG_WRITE_FAILURE";
    exports$1[1596] = "ER_SLAVE_CREATE_EVENT_FAILURE";
    exports$1[1597] = "ER_SLAVE_MASTER_COM_FAILURE";
    exports$1[1598] = "ER_BINLOG_LOGGING_IMPOSSIBLE";
    exports$1[1599] = "ER_VIEW_NO_CREATION_CTX";
    exports$1[1600] = "ER_VIEW_INVALID_CREATION_CTX";
    exports$1[1601] = "ER_SR_INVALID_CREATION_CTX";
    exports$1[1602] = "ER_TRG_CORRUPTED_FILE";
    exports$1[1603] = "ER_TRG_NO_CREATION_CTX";
    exports$1[1604] = "ER_TRG_INVALID_CREATION_CTX";
    exports$1[1605] = "ER_EVENT_INVALID_CREATION_CTX";
    exports$1[1606] = "ER_TRG_CANT_OPEN_TABLE";
    exports$1[1607] = "ER_CANT_CREATE_SROUTINE";
    exports$1[1608] = "ER_NEVER_USED";
    exports$1[1609] = "ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT";
    exports$1[1610] = "ER_REPLICA_CORRUPT_EVENT";
    exports$1[1611] = "ER_LOAD_DATA_INVALID_COLUMN";
    exports$1[1612] = "ER_LOG_PURGE_NO_FILE";
    exports$1[1613] = "ER_XA_RBTIMEOUT";
    exports$1[1614] = "ER_XA_RBDEADLOCK";
    exports$1[1615] = "ER_NEED_REPREPARE";
    exports$1[1616] = "ER_DELAYED_NOT_SUPPORTED";
    exports$1[1617] = "WARN_NO_CONNECTION_METADATA";
    exports$1[1618] = "WARN_OPTION_IGNORED";
    exports$1[1619] = "ER_PLUGIN_DELETE_BUILTIN";
    exports$1[1620] = "WARN_PLUGIN_BUSY";
    exports$1[1621] = "ER_VARIABLE_IS_READONLY";
    exports$1[1622] = "ER_WARN_ENGINE_TRANSACTION_ROLLBACK";
    exports$1[1623] = "ER_SLAVE_HEARTBEAT_FAILURE";
    exports$1[1624] = "ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE";
    exports$1[1625] = "ER_NDB_REPLICATION_SCHEMA_ERROR";
    exports$1[1626] = "ER_CONFLICT_FN_PARSE_ERROR";
    exports$1[1627] = "ER_EXCEPTIONS_WRITE_ERROR";
    exports$1[1628] = "ER_TOO_LONG_TABLE_COMMENT";
    exports$1[1629] = "ER_TOO_LONG_FIELD_COMMENT";
    exports$1[1630] = "ER_FUNC_INEXISTENT_NAME_COLLISION";
    exports$1[1631] = "ER_DATABASE_NAME";
    exports$1[1632] = "ER_TABLE_NAME";
    exports$1[1633] = "ER_PARTITION_NAME";
    exports$1[1634] = "ER_SUBPARTITION_NAME";
    exports$1[1635] = "ER_TEMPORARY_NAME";
    exports$1[1636] = "ER_RENAMED_NAME";
    exports$1[1637] = "ER_TOO_MANY_CONCURRENT_TRXS";
    exports$1[1638] = "WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED";
    exports$1[1639] = "ER_DEBUG_SYNC_TIMEOUT";
    exports$1[1640] = "ER_DEBUG_SYNC_HIT_LIMIT";
    exports$1[1641] = "ER_DUP_SIGNAL_SET";
    exports$1[1642] = "ER_SIGNAL_WARN";
    exports$1[1643] = "ER_SIGNAL_NOT_FOUND";
    exports$1[1644] = "ER_SIGNAL_EXCEPTION";
    exports$1[1645] = "ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER";
    exports$1[1646] = "ER_SIGNAL_BAD_CONDITION_TYPE";
    exports$1[1647] = "WARN_COND_ITEM_TRUNCATED";
    exports$1[1648] = "ER_COND_ITEM_TOO_LONG";
    exports$1[1649] = "ER_UNKNOWN_LOCALE";
    exports$1[1650] = "ER_REPLICA_IGNORE_SERVER_IDS";
    exports$1[1651] = "ER_QUERY_CACHE_DISABLED";
    exports$1[1652] = "ER_SAME_NAME_PARTITION_FIELD";
    exports$1[1653] = "ER_PARTITION_COLUMN_LIST_ERROR";
    exports$1[1654] = "ER_WRONG_TYPE_COLUMN_VALUE_ERROR";
    exports$1[1655] = "ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR";
    exports$1[1656] = "ER_MAXVALUE_IN_VALUES_IN";
    exports$1[1657] = "ER_TOO_MANY_VALUES_ERROR";
    exports$1[1658] = "ER_ROW_SINGLE_PARTITION_FIELD_ERROR";
    exports$1[1659] = "ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD";
    exports$1[1660] = "ER_PARTITION_FIELDS_TOO_LONG";
    exports$1[1661] = "ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE";
    exports$1[1662] = "ER_BINLOG_ROW_MODE_AND_STMT_ENGINE";
    exports$1[1663] = "ER_BINLOG_UNSAFE_AND_STMT_ENGINE";
    exports$1[1664] = "ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE";
    exports$1[1665] = "ER_BINLOG_STMT_MODE_AND_ROW_ENGINE";
    exports$1[1666] = "ER_BINLOG_ROW_INJECTION_AND_STMT_MODE";
    exports$1[1667] = "ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE";
    exports$1[1668] = "ER_BINLOG_UNSAFE_LIMIT";
    exports$1[1669] = "ER_UNUSED4";
    exports$1[1670] = "ER_BINLOG_UNSAFE_SYSTEM_TABLE";
    exports$1[1671] = "ER_BINLOG_UNSAFE_AUTOINC_COLUMNS";
    exports$1[1672] = "ER_BINLOG_UNSAFE_UDF";
    exports$1[1673] = "ER_BINLOG_UNSAFE_SYSTEM_VARIABLE";
    exports$1[1674] = "ER_BINLOG_UNSAFE_SYSTEM_FUNCTION";
    exports$1[1675] = "ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS";
    exports$1[1676] = "ER_MESSAGE_AND_STATEMENT";
    exports$1[1677] = "ER_SLAVE_CONVERSION_FAILED";
    exports$1[1678] = "ER_REPLICA_CANT_CREATE_CONVERSION";
    exports$1[1679] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT";
    exports$1[1680] = "ER_PATH_LENGTH";
    exports$1[1681] = "ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT";
    exports$1[1682] = "ER_WRONG_NATIVE_TABLE_STRUCTURE";
    exports$1[1683] = "ER_WRONG_PERFSCHEMA_USAGE";
    exports$1[1684] = "ER_WARN_I_S_SKIPPED_TABLE";
    exports$1[1685] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT";
    exports$1[1686] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT";
    exports$1[1687] = "ER_SPATIAL_MUST_HAVE_GEOM_COL";
    exports$1[1688] = "ER_TOO_LONG_INDEX_COMMENT";
    exports$1[1689] = "ER_LOCK_ABORTED";
    exports$1[1690] = "ER_DATA_OUT_OF_RANGE";
    exports$1[1691] = "ER_WRONG_SPVAR_TYPE_IN_LIMIT";
    exports$1[1692] = "ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE";
    exports$1[1693] = "ER_BINLOG_UNSAFE_MIXED_STATEMENT";
    exports$1[1694] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN";
    exports$1[1695] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN";
    exports$1[1696] = "ER_FAILED_READ_FROM_PAR_FILE";
    exports$1[1697] = "ER_VALUES_IS_NOT_INT_TYPE_ERROR";
    exports$1[1698] = "ER_ACCESS_DENIED_NO_PASSWORD_ERROR";
    exports$1[1699] = "ER_SET_PASSWORD_AUTH_PLUGIN";
    exports$1[1700] = "ER_GRANT_PLUGIN_USER_EXISTS";
    exports$1[1701] = "ER_TRUNCATE_ILLEGAL_FK";
    exports$1[1702] = "ER_PLUGIN_IS_PERMANENT";
    exports$1[1703] = "ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN";
    exports$1[1704] = "ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX";
    exports$1[1705] = "ER_STMT_CACHE_FULL";
    exports$1[1706] = "ER_MULTI_UPDATE_KEY_CONFLICT";
    exports$1[1707] = "ER_TABLE_NEEDS_REBUILD";
    exports$1[1708] = "WARN_OPTION_BELOW_LIMIT";
    exports$1[1709] = "ER_INDEX_COLUMN_TOO_LONG";
    exports$1[1710] = "ER_ERROR_IN_TRIGGER_BODY";
    exports$1[1711] = "ER_ERROR_IN_UNKNOWN_TRIGGER_BODY";
    exports$1[1712] = "ER_INDEX_CORRUPT";
    exports$1[1713] = "ER_UNDO_RECORD_TOO_BIG";
    exports$1[1714] = "ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT";
    exports$1[1715] = "ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE";
    exports$1[1716] = "ER_BINLOG_UNSAFE_REPLACE_SELECT";
    exports$1[1717] = "ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT";
    exports$1[1718] = "ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT";
    exports$1[1719] = "ER_BINLOG_UNSAFE_UPDATE_IGNORE";
    exports$1[1720] = "ER_PLUGIN_NO_UNINSTALL";
    exports$1[1721] = "ER_PLUGIN_NO_INSTALL";
    exports$1[1722] = "ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT";
    exports$1[1723] = "ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC";
    exports$1[1724] = "ER_BINLOG_UNSAFE_INSERT_TWO_KEYS";
    exports$1[1725] = "ER_TABLE_IN_FK_CHECK";
    exports$1[1726] = "ER_UNSUPPORTED_ENGINE";
    exports$1[1727] = "ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST";
    exports$1[1728] = "ER_CANNOT_LOAD_FROM_TABLE_V2";
    exports$1[1729] = "ER_SOURCE_DELAY_VALUE_OUT_OF_RANGE";
    exports$1[1730] = "ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT";
    exports$1[1731] = "ER_PARTITION_EXCHANGE_DIFFERENT_OPTION";
    exports$1[1732] = "ER_PARTITION_EXCHANGE_PART_TABLE";
    exports$1[1733] = "ER_PARTITION_EXCHANGE_TEMP_TABLE";
    exports$1[1734] = "ER_PARTITION_INSTEAD_OF_SUBPARTITION";
    exports$1[1735] = "ER_UNKNOWN_PARTITION";
    exports$1[1736] = "ER_TABLES_DIFFERENT_METADATA";
    exports$1[1737] = "ER_ROW_DOES_NOT_MATCH_PARTITION";
    exports$1[1738] = "ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX";
    exports$1[1739] = "ER_WARN_INDEX_NOT_APPLICABLE";
    exports$1[1740] = "ER_PARTITION_EXCHANGE_FOREIGN_KEY";
    exports$1[1741] = "ER_NO_SUCH_KEY_VALUE";
    exports$1[1742] = "ER_RPL_INFO_DATA_TOO_LONG";
    exports$1[1743] = "ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE";
    exports$1[1744] = "ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE";
    exports$1[1745] = "ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX";
    exports$1[1746] = "ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT";
    exports$1[1747] = "ER_PARTITION_CLAUSE_ON_NONPARTITIONED";
    exports$1[1748] = "ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET";
    exports$1[1749] = "ER_NO_SUCH_PARTITION";
    exports$1[1750] = "ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE";
    exports$1[1751] = "ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE";
    exports$1[1752] = "ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE";
    exports$1[1753] = "ER_MTA_FEATURE_IS_NOT_SUPPORTED";
    exports$1[1754] = "ER_MTA_UPDATED_DBS_GREATER_MAX";
    exports$1[1755] = "ER_MTA_CANT_PARALLEL";
    exports$1[1756] = "ER_MTA_INCONSISTENT_DATA";
    exports$1[1757] = "ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING";
    exports$1[1758] = "ER_DA_INVALID_CONDITION_NUMBER";
    exports$1[1759] = "ER_INSECURE_PLAIN_TEXT";
    exports$1[1760] = "ER_INSECURE_CHANGE_SOURCE";
    exports$1[1761] = "ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO";
    exports$1[1762] = "ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO";
    exports$1[1763] = "ER_SQLTHREAD_WITH_SECURE_REPLICA";
    exports$1[1764] = "ER_TABLE_HAS_NO_FT";
    exports$1[1765] = "ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER";
    exports$1[1766] = "ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION";
    exports$1[1767] = "ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST";
    exports$1[1768] = "ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION";
    exports$1[1769] = "ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION";
    exports$1[1770] = "ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL";
    exports$1[1771] = "ER_SKIPPING_LOGGED_TRANSACTION";
    exports$1[1772] = "ER_MALFORMED_GTID_SET_SPECIFICATION";
    exports$1[1773] = "ER_MALFORMED_GTID_SET_ENCODING";
    exports$1[1774] = "ER_MALFORMED_GTID_SPECIFICATION";
    exports$1[1775] = "ER_GNO_EXHAUSTED";
    exports$1[1776] = "ER_BAD_REPLICA_AUTO_POSITION";
    exports$1[1777] = "ER_AUTO_POSITION_REQUIRES_GTID_MODE_NOT_OFF";
    exports$1[1778] = "ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET";
    exports$1[1779] = "ER_GTID_MODE_ON_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON";
    exports$1[1780] = "ER_GTID_MODE_REQUIRES_BINLOG";
    exports$1[1781] = "ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF";
    exports$1[1782] = "ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON";
    exports$1[1783] = "ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF";
    exports$1[1784] = "ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF";
    exports$1[1785] = "ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE";
    exports$1[1786] = "ER_GTID_UNSAFE_CREATE_SELECT";
    exports$1[1787] = "ER_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRANSACTION";
    exports$1[1788] = "ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME";
    exports$1[1789] = "ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS";
    exports$1[1790] = "ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID";
    exports$1[1791] = "ER_UNKNOWN_EXPLAIN_FORMAT";
    exports$1[1792] = "ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION";
    exports$1[1793] = "ER_TOO_LONG_TABLE_PARTITION_COMMENT";
    exports$1[1794] = "ER_REPLICA_CONFIGURATION";
    exports$1[1795] = "ER_INNODB_FT_LIMIT";
    exports$1[1796] = "ER_INNODB_NO_FT_TEMP_TABLE";
    exports$1[1797] = "ER_INNODB_FT_WRONG_DOCID_COLUMN";
    exports$1[1798] = "ER_INNODB_FT_WRONG_DOCID_INDEX";
    exports$1[1799] = "ER_INNODB_ONLINE_LOG_TOO_BIG";
    exports$1[1800] = "ER_UNKNOWN_ALTER_ALGORITHM";
    exports$1[1801] = "ER_UNKNOWN_ALTER_LOCK";
    exports$1[1802] = "ER_MTA_CHANGE_SOURCE_CANT_RUN_WITH_GAPS";
    exports$1[1803] = "ER_MTA_RECOVERY_FAILURE";
    exports$1[1804] = "ER_MTA_RESET_WORKERS";
    exports$1[1805] = "ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2";
    exports$1[1806] = "ER_REPLICA_SILENT_RETRY_TRANSACTION";
    exports$1[1807] = "ER_DISCARD_FK_CHECKS_RUNNING";
    exports$1[1808] = "ER_TABLE_SCHEMA_MISMATCH";
    exports$1[1809] = "ER_TABLE_IN_SYSTEM_TABLESPACE";
    exports$1[1810] = "ER_IO_READ_ERROR";
    exports$1[1811] = "ER_IO_WRITE_ERROR";
    exports$1[1812] = "ER_TABLESPACE_MISSING";
    exports$1[1813] = "ER_TABLESPACE_EXISTS";
    exports$1[1814] = "ER_TABLESPACE_DISCARDED";
    exports$1[1815] = "ER_INTERNAL_ERROR";
    exports$1[1816] = "ER_INNODB_IMPORT_ERROR";
    exports$1[1817] = "ER_INNODB_INDEX_CORRUPT";
    exports$1[1818] = "ER_INVALID_YEAR_COLUMN_LENGTH";
    exports$1[1819] = "ER_NOT_VALID_PASSWORD";
    exports$1[1820] = "ER_MUST_CHANGE_PASSWORD";
    exports$1[1821] = "ER_FK_NO_INDEX_CHILD";
    exports$1[1822] = "ER_FK_NO_INDEX_PARENT";
    exports$1[1823] = "ER_FK_FAIL_ADD_SYSTEM";
    exports$1[1824] = "ER_FK_CANNOT_OPEN_PARENT";
    exports$1[1825] = "ER_FK_INCORRECT_OPTION";
    exports$1[1826] = "ER_FK_DUP_NAME";
    exports$1[1827] = "ER_PASSWORD_FORMAT";
    exports$1[1828] = "ER_FK_COLUMN_CANNOT_DROP";
    exports$1[1829] = "ER_FK_COLUMN_CANNOT_DROP_CHILD";
    exports$1[1830] = "ER_FK_COLUMN_NOT_NULL";
    exports$1[1831] = "ER_DUP_INDEX";
    exports$1[1832] = "ER_FK_COLUMN_CANNOT_CHANGE";
    exports$1[1833] = "ER_FK_COLUMN_CANNOT_CHANGE_CHILD";
    exports$1[1834] = "ER_UNUSED5";
    exports$1[1835] = "ER_MALFORMED_PACKET";
    exports$1[1836] = "ER_READ_ONLY_MODE";
    exports$1[1837] = "ER_GTID_NEXT_TYPE_UNDEFINED_GTID";
    exports$1[1838] = "ER_VARIABLE_NOT_SETTABLE_IN_SP";
    exports$1[1839] = "ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF";
    exports$1[1840] = "ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY";
    exports$1[1841] = "ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY";
    exports$1[1842] = "ER_GTID_PURGED_WAS_CHANGED";
    exports$1[1843] = "ER_GTID_EXECUTED_WAS_CHANGED";
    exports$1[1844] = "ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES";
    exports$1[1845] = "ER_ALTER_OPERATION_NOT_SUPPORTED";
    exports$1[1846] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON";
    exports$1[1847] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY";
    exports$1[1848] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION";
    exports$1[1849] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME";
    exports$1[1850] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE";
    exports$1[1851] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK";
    exports$1[1852] = "ER_UNUSED6";
    exports$1[1853] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK";
    exports$1[1854] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC";
    exports$1[1855] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS";
    exports$1[1856] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS";
    exports$1[1857] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS";
    exports$1[1858] = "ER_SQL_REPLICA_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE";
    exports$1[1859] = "ER_DUP_UNKNOWN_IN_INDEX";
    exports$1[1860] = "ER_IDENT_CAUSES_TOO_LONG_PATH";
    exports$1[1861] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL";
    exports$1[1862] = "ER_MUST_CHANGE_PASSWORD_LOGIN";
    exports$1[1863] = "ER_ROW_IN_WRONG_PARTITION";
    exports$1[1864] = "ER_MTA_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX";
    exports$1[1865] = "ER_INNODB_NO_FT_USES_PARSER";
    exports$1[1866] = "ER_BINLOG_LOGICAL_CORRUPTION";
    exports$1[1867] = "ER_WARN_PURGE_LOG_IN_USE";
    exports$1[1868] = "ER_WARN_PURGE_LOG_IS_ACTIVE";
    exports$1[1869] = "ER_AUTO_INCREMENT_CONFLICT";
    exports$1[1870] = "WARN_ON_BLOCKHOLE_IN_RBR";
    exports$1[1871] = "ER_REPLICA_CM_INIT_REPOSITORY";
    exports$1[1872] = "ER_REPLICA_AM_INIT_REPOSITORY";
    exports$1[1873] = "ER_ACCESS_DENIED_CHANGE_USER_ERROR";
    exports$1[1874] = "ER_INNODB_READ_ONLY";
    exports$1[1875] = "ER_STOP_REPLICA_SQL_THREAD_TIMEOUT";
    exports$1[1876] = "ER_STOP_REPLICA_IO_THREAD_TIMEOUT";
    exports$1[1877] = "ER_TABLE_CORRUPT";
    exports$1[1878] = "ER_TEMP_FILE_WRITE_FAILURE";
    exports$1[1879] = "ER_INNODB_FT_AUX_NOT_HEX_ID";
    exports$1[1880] = "ER_OLD_TEMPORALS_UPGRADED";
    exports$1[1881] = "ER_INNODB_FORCED_RECOVERY";
    exports$1[1882] = "ER_AES_INVALID_IV";
    exports$1[1883] = "ER_PLUGIN_CANNOT_BE_UNINSTALLED";
    exports$1[1884] = "ER_GTID_UNSAFE_BINLOG_SPLITTABLE_STATEMENT_AND_ASSIGNED_GTID";
    exports$1[1885] = "ER_REPLICA_HAS_MORE_GTIDS_THAN_SOURCE";
    exports$1[1886] = "ER_MISSING_KEY";
    exports$1[1887] = "WARN_NAMED_PIPE_ACCESS_EVERYONE";
    exports$1[3e3] = "ER_FILE_CORRUPT";
    exports$1[3001] = "ER_ERROR_ON_SOURCE";
    exports$1[3002] = "ER_INCONSISTENT_ERROR";
    exports$1[3003] = "ER_STORAGE_ENGINE_NOT_LOADED";
    exports$1[3004] = "ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER";
    exports$1[3005] = "ER_WARN_LEGACY_SYNTAX_CONVERTED";
    exports$1[3006] = "ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN";
    exports$1[3007] = "ER_CANNOT_DISCARD_TEMPORARY_TABLE";
    exports$1[3008] = "ER_FK_DEPTH_EXCEEDED";
    exports$1[3009] = "ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2";
    exports$1[3010] = "ER_WARN_TRIGGER_DOESNT_HAVE_CREATED";
    exports$1[3011] = "ER_REFERENCED_TRG_DOES_NOT_EXIST";
    exports$1[3012] = "ER_EXPLAIN_NOT_SUPPORTED";
    exports$1[3013] = "ER_INVALID_FIELD_SIZE";
    exports$1[3014] = "ER_MISSING_HA_CREATE_OPTION";
    exports$1[3015] = "ER_ENGINE_OUT_OF_MEMORY";
    exports$1[3016] = "ER_PASSWORD_EXPIRE_ANONYMOUS_USER";
    exports$1[3017] = "ER_REPLICA_SQL_THREAD_MUST_STOP";
    exports$1[3018] = "ER_NO_FT_MATERIALIZED_SUBQUERY";
    exports$1[3019] = "ER_INNODB_UNDO_LOG_FULL";
    exports$1[3020] = "ER_INVALID_ARGUMENT_FOR_LOGARITHM";
    exports$1[3021] = "ER_REPLICA_CHANNEL_IO_THREAD_MUST_STOP";
    exports$1[3022] = "ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO";
    exports$1[3023] = "ER_WARN_ONLY_SOURCE_LOG_FILE_NO_POS";
    exports$1[3024] = "ER_QUERY_TIMEOUT";
    exports$1[3025] = "ER_NON_RO_SELECT_DISABLE_TIMER";
    exports$1[3026] = "ER_DUP_LIST_ENTRY";
    exports$1[3027] = "ER_SQL_MODE_NO_EFFECT";
    exports$1[3028] = "ER_AGGREGATE_ORDER_FOR_UNION";
    exports$1[3029] = "ER_AGGREGATE_ORDER_NON_AGG_QUERY";
    exports$1[3030] = "ER_REPLICA_WORKER_STOPPED_PREVIOUS_THD_ERROR";
    exports$1[3031] = "ER_DONT_SUPPORT_REPLICA_PRESERVE_COMMIT_ORDER";
    exports$1[3032] = "ER_SERVER_OFFLINE_MODE";
    exports$1[3033] = "ER_GIS_DIFFERENT_SRIDS";
    exports$1[3034] = "ER_GIS_UNSUPPORTED_ARGUMENT";
    exports$1[3035] = "ER_GIS_UNKNOWN_ERROR";
    exports$1[3036] = "ER_GIS_UNKNOWN_EXCEPTION";
    exports$1[3037] = "ER_GIS_INVALID_DATA";
    exports$1[3038] = "ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION";
    exports$1[3039] = "ER_BOOST_GEOMETRY_CENTROID_EXCEPTION";
    exports$1[3040] = "ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION";
    exports$1[3041] = "ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION";
    exports$1[3042] = "ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION";
    exports$1[3043] = "ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION";
    exports$1[3044] = "ER_STD_BAD_ALLOC_ERROR";
    exports$1[3045] = "ER_STD_DOMAIN_ERROR";
    exports$1[3046] = "ER_STD_LENGTH_ERROR";
    exports$1[3047] = "ER_STD_INVALID_ARGUMENT";
    exports$1[3048] = "ER_STD_OUT_OF_RANGE_ERROR";
    exports$1[3049] = "ER_STD_OVERFLOW_ERROR";
    exports$1[3050] = "ER_STD_RANGE_ERROR";
    exports$1[3051] = "ER_STD_UNDERFLOW_ERROR";
    exports$1[3052] = "ER_STD_LOGIC_ERROR";
    exports$1[3053] = "ER_STD_RUNTIME_ERROR";
    exports$1[3054] = "ER_STD_UNKNOWN_EXCEPTION";
    exports$1[3055] = "ER_GIS_DATA_WRONG_ENDIANESS";
    exports$1[3056] = "ER_CHANGE_SOURCE_PASSWORD_LENGTH";
    exports$1[3057] = "ER_USER_LOCK_WRONG_NAME";
    exports$1[3058] = "ER_USER_LOCK_DEADLOCK";
    exports$1[3059] = "ER_REPLACE_INACCESSIBLE_ROWS";
    exports$1[3060] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS";
    exports$1[3061] = "ER_ILLEGAL_USER_VAR";
    exports$1[3062] = "ER_GTID_MODE_OFF";
    exports$1[3063] = "ER_UNSUPPORTED_BY_REPLICATION_THREAD";
    exports$1[3064] = "ER_INCORRECT_TYPE";
    exports$1[3065] = "ER_FIELD_IN_ORDER_NOT_SELECT";
    exports$1[3066] = "ER_AGGREGATE_IN_ORDER_NOT_SELECT";
    exports$1[3067] = "ER_INVALID_RPL_WILD_TABLE_FILTER_PATTERN";
    exports$1[3068] = "ER_NET_OK_PACKET_TOO_LARGE";
    exports$1[3069] = "ER_INVALID_JSON_DATA";
    exports$1[3070] = "ER_INVALID_GEOJSON_MISSING_MEMBER";
    exports$1[3071] = "ER_INVALID_GEOJSON_WRONG_TYPE";
    exports$1[3072] = "ER_INVALID_GEOJSON_UNSPECIFIED";
    exports$1[3073] = "ER_DIMENSION_UNSUPPORTED";
    exports$1[3074] = "ER_REPLICA_CHANNEL_DOES_NOT_EXIST";
    exports$1[3075] = "ER_SLAVE_MULTIPLE_CHANNELS_HOST_PORT";
    exports$1[3076] = "ER_REPLICA_CHANNEL_NAME_INVALID_OR_TOO_LONG";
    exports$1[3077] = "ER_REPLICA_NEW_CHANNEL_WRONG_REPOSITORY";
    exports$1[3078] = "ER_SLAVE_CHANNEL_DELETE";
    exports$1[3079] = "ER_REPLICA_MULTIPLE_CHANNELS_CMD";
    exports$1[3080] = "ER_REPLICA_MAX_CHANNELS_EXCEEDED";
    exports$1[3081] = "ER_REPLICA_CHANNEL_MUST_STOP";
    exports$1[3082] = "ER_REPLICA_CHANNEL_NOT_RUNNING";
    exports$1[3083] = "ER_REPLICA_CHANNEL_WAS_RUNNING";
    exports$1[3084] = "ER_REPLICA_CHANNEL_WAS_NOT_RUNNING";
    exports$1[3085] = "ER_REPLICA_CHANNEL_SQL_THREAD_MUST_STOP";
    exports$1[3086] = "ER_REPLICA_CHANNEL_SQL_SKIP_COUNTER";
    exports$1[3087] = "ER_WRONG_FIELD_WITH_GROUP_V2";
    exports$1[3088] = "ER_MIX_OF_GROUP_FUNC_AND_FIELDS_V2";
    exports$1[3089] = "ER_WARN_DEPRECATED_SYSVAR_UPDATE";
    exports$1[3090] = "ER_WARN_DEPRECATED_SQLMODE";
    exports$1[3091] = "ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID";
    exports$1[3092] = "ER_GROUP_REPLICATION_CONFIGURATION";
    exports$1[3093] = "ER_GROUP_REPLICATION_RUNNING";
    exports$1[3094] = "ER_GROUP_REPLICATION_APPLIER_INIT_ERROR";
    exports$1[3095] = "ER_GROUP_REPLICATION_STOP_APPLIER_THREAD_TIMEOUT";
    exports$1[3096] = "ER_GROUP_REPLICATION_COMMUNICATION_LAYER_SESSION_ERROR";
    exports$1[3097] = "ER_GROUP_REPLICATION_COMMUNICATION_LAYER_JOIN_ERROR";
    exports$1[3098] = "ER_BEFORE_DML_VALIDATION_ERROR";
    exports$1[3099] = "ER_PREVENTS_VARIABLE_WITHOUT_RBR";
    exports$1[3100] = "ER_RUN_HOOK_ERROR";
    exports$1[3101] = "ER_TRANSACTION_ROLLBACK_DURING_COMMIT";
    exports$1[3102] = "ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED";
    exports$1[3103] = "ER_UNSUPPORTED_ALTER_INPLACE_ON_VIRTUAL_COLUMN";
    exports$1[3104] = "ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN";
    exports$1[3105] = "ER_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN";
    exports$1[3106] = "ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN";
    exports$1[3107] = "ER_GENERATED_COLUMN_NON_PRIOR";
    exports$1[3108] = "ER_DEPENDENT_BY_GENERATED_COLUMN";
    exports$1[3109] = "ER_GENERATED_COLUMN_REF_AUTO_INC";
    exports$1[3110] = "ER_FEATURE_NOT_AVAILABLE";
    exports$1[3111] = "ER_CANT_SET_GTID_MODE";
    exports$1[3112] = "ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF";
    exports$1[3113] = "ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION";
    exports$1[3114] = "ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON";
    exports$1[3115] = "ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF";
    exports$1[3116] = "ER_CANT_ENFORCE_GTID_CONSISTENCY_WITH_ONGOING_GTID_VIOLATING_TX";
    exports$1[3117] = "ER_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TX";
    exports$1[3118] = "ER_ACCOUNT_HAS_BEEN_LOCKED";
    exports$1[3119] = "ER_WRONG_TABLESPACE_NAME";
    exports$1[3120] = "ER_TABLESPACE_IS_NOT_EMPTY";
    exports$1[3121] = "ER_WRONG_FILE_NAME";
    exports$1[3122] = "ER_BOOST_GEOMETRY_INCONSISTENT_TURNS_EXCEPTION";
    exports$1[3123] = "ER_WARN_OPTIMIZER_HINT_SYNTAX_ERROR";
    exports$1[3124] = "ER_WARN_BAD_MAX_EXECUTION_TIME";
    exports$1[3125] = "ER_WARN_UNSUPPORTED_MAX_EXECUTION_TIME";
    exports$1[3126] = "ER_WARN_CONFLICTING_HINT";
    exports$1[3127] = "ER_WARN_UNKNOWN_QB_NAME";
    exports$1[3128] = "ER_UNRESOLVED_HINT_NAME";
    exports$1[3129] = "ER_WARN_ON_MODIFYING_GTID_EXECUTED_TABLE";
    exports$1[3130] = "ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED";
    exports$1[3131] = "ER_LOCKING_SERVICE_WRONG_NAME";
    exports$1[3132] = "ER_LOCKING_SERVICE_DEADLOCK";
    exports$1[3133] = "ER_LOCKING_SERVICE_TIMEOUT";
    exports$1[3134] = "ER_GIS_MAX_POINTS_IN_GEOMETRY_OVERFLOWED";
    exports$1[3135] = "ER_SQL_MODE_MERGED";
    exports$1[3136] = "ER_VTOKEN_PLUGIN_TOKEN_MISMATCH";
    exports$1[3137] = "ER_VTOKEN_PLUGIN_TOKEN_NOT_FOUND";
    exports$1[3138] = "ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID";
    exports$1[3139] = "ER_REPLICA_CHANNEL_OPERATION_NOT_ALLOWED";
    exports$1[3140] = "ER_INVALID_JSON_TEXT";
    exports$1[3141] = "ER_INVALID_JSON_TEXT_IN_PARAM";
    exports$1[3142] = "ER_INVALID_JSON_BINARY_DATA";
    exports$1[3143] = "ER_INVALID_JSON_PATH";
    exports$1[3144] = "ER_INVALID_JSON_CHARSET";
    exports$1[3145] = "ER_INVALID_JSON_CHARSET_IN_FUNCTION";
    exports$1[3146] = "ER_INVALID_TYPE_FOR_JSON";
    exports$1[3147] = "ER_INVALID_CAST_TO_JSON";
    exports$1[3148] = "ER_INVALID_JSON_PATH_CHARSET";
    exports$1[3149] = "ER_INVALID_JSON_PATH_WILDCARD";
    exports$1[3150] = "ER_JSON_VALUE_TOO_BIG";
    exports$1[3151] = "ER_JSON_KEY_TOO_BIG";
    exports$1[3152] = "ER_JSON_USED_AS_KEY";
    exports$1[3153] = "ER_JSON_VACUOUS_PATH";
    exports$1[3154] = "ER_JSON_BAD_ONE_OR_ALL_ARG";
    exports$1[3155] = "ER_NUMERIC_JSON_VALUE_OUT_OF_RANGE";
    exports$1[3156] = "ER_INVALID_JSON_VALUE_FOR_CAST";
    exports$1[3157] = "ER_JSON_DOCUMENT_TOO_DEEP";
    exports$1[3158] = "ER_JSON_DOCUMENT_NULL_KEY";
    exports$1[3159] = "ER_SECURE_TRANSPORT_REQUIRED";
    exports$1[3160] = "ER_NO_SECURE_TRANSPORTS_CONFIGURED";
    exports$1[3161] = "ER_DISABLED_STORAGE_ENGINE";
    exports$1[3162] = "ER_USER_DOES_NOT_EXIST";
    exports$1[3163] = "ER_USER_ALREADY_EXISTS";
    exports$1[3164] = "ER_AUDIT_API_ABORT";
    exports$1[3165] = "ER_INVALID_JSON_PATH_ARRAY_CELL";
    exports$1[3166] = "ER_BUFPOOL_RESIZE_INPROGRESS";
    exports$1[3167] = "ER_FEATURE_DISABLED_SEE_DOC";
    exports$1[3168] = "ER_SERVER_ISNT_AVAILABLE";
    exports$1[3169] = "ER_SESSION_WAS_KILLED";
    exports$1[3170] = "ER_CAPACITY_EXCEEDED";
    exports$1[3171] = "ER_CAPACITY_EXCEEDED_IN_RANGE_OPTIMIZER";
    exports$1[3172] = "ER_TABLE_NEEDS_UPG_PART";
    exports$1[3173] = "ER_CANT_WAIT_FOR_EXECUTED_GTID_SET_WHILE_OWNING_A_GTID";
    exports$1[3174] = "ER_CANNOT_ADD_FOREIGN_BASE_COL_VIRTUAL";
    exports$1[3175] = "ER_CANNOT_CREATE_VIRTUAL_INDEX_CONSTRAINT";
    exports$1[3176] = "ER_ERROR_ON_MODIFYING_GTID_EXECUTED_TABLE";
    exports$1[3177] = "ER_LOCK_REFUSED_BY_ENGINE";
    exports$1[3178] = "ER_UNSUPPORTED_ALTER_ONLINE_ON_VIRTUAL_COLUMN";
    exports$1[3179] = "ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE";
    exports$1[3180] = "ER_MASTER_KEY_ROTATION_ERROR_BY_SE";
    exports$1[3181] = "ER_MASTER_KEY_ROTATION_BINLOG_FAILED";
    exports$1[3182] = "ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE";
    exports$1[3183] = "ER_TABLESPACE_CANNOT_ENCRYPT";
    exports$1[3184] = "ER_INVALID_ENCRYPTION_OPTION";
    exports$1[3185] = "ER_CANNOT_FIND_KEY_IN_KEYRING";
    exports$1[3186] = "ER_CAPACITY_EXCEEDED_IN_PARSER";
    exports$1[3187] = "ER_UNSUPPORTED_ALTER_ENCRYPTION_INPLACE";
    exports$1[3188] = "ER_KEYRING_UDF_KEYRING_SERVICE_ERROR";
    exports$1[3189] = "ER_USER_COLUMN_OLD_LENGTH";
    exports$1[3190] = "ER_CANT_RESET_SOURCE";
    exports$1[3191] = "ER_GROUP_REPLICATION_MAX_GROUP_SIZE";
    exports$1[3192] = "ER_CANNOT_ADD_FOREIGN_BASE_COL_STORED";
    exports$1[3193] = "ER_TABLE_REFERENCED";
    exports$1[3194] = "ER_PARTITION_ENGINE_DEPRECATED_FOR_TABLE";
    exports$1[3195] = "ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID_ZERO";
    exports$1[3196] = "ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID";
    exports$1[3197] = "ER_XA_RETRY";
    exports$1[3198] = "ER_KEYRING_AWS_UDF_AWS_KMS_ERROR";
    exports$1[3199] = "ER_BINLOG_UNSAFE_XA";
    exports$1[3200] = "ER_UDF_ERROR";
    exports$1[3201] = "ER_KEYRING_MIGRATION_FAILURE";
    exports$1[3202] = "ER_KEYRING_ACCESS_DENIED_ERROR";
    exports$1[3203] = "ER_KEYRING_MIGRATION_STATUS";
    exports$1[3204] = "ER_PLUGIN_FAILED_TO_OPEN_TABLES";
    exports$1[3205] = "ER_PLUGIN_FAILED_TO_OPEN_TABLE";
    exports$1[3206] = "ER_AUDIT_LOG_NO_KEYRING_PLUGIN_INSTALLED";
    exports$1[3207] = "ER_AUDIT_LOG_ENCRYPTION_PASSWORD_HAS_NOT_BEEN_SET";
    exports$1[3208] = "ER_AUDIT_LOG_COULD_NOT_CREATE_AES_KEY";
    exports$1[3209] = "ER_AUDIT_LOG_ENCRYPTION_PASSWORD_CANNOT_BE_FETCHED";
    exports$1[3210] = "ER_AUDIT_LOG_JSON_FILTERING_NOT_ENABLED";
    exports$1[3211] = "ER_AUDIT_LOG_UDF_INSUFFICIENT_PRIVILEGE";
    exports$1[3212] = "ER_AUDIT_LOG_SUPER_PRIVILEGE_REQUIRED";
    exports$1[3213] = "ER_COULD_NOT_REINITIALIZE_AUDIT_LOG_FILTERS";
    exports$1[3214] = "ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_TYPE";
    exports$1[3215] = "ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_COUNT";
    exports$1[3216] = "ER_AUDIT_LOG_HAS_NOT_BEEN_INSTALLED";
    exports$1[3217] = "ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_TYPE";
    exports$1[3218] = "ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_VALUE";
    exports$1[3219] = "ER_AUDIT_LOG_JSON_FILTER_PARSING_ERROR";
    exports$1[3220] = "ER_AUDIT_LOG_JSON_FILTER_NAME_CANNOT_BE_EMPTY";
    exports$1[3221] = "ER_AUDIT_LOG_JSON_USER_NAME_CANNOT_BE_EMPTY";
    exports$1[3222] = "ER_AUDIT_LOG_JSON_FILTER_DOES_NOT_EXISTS";
    exports$1[3223] = "ER_AUDIT_LOG_USER_FIRST_CHARACTER_MUST_BE_ALPHANUMERIC";
    exports$1[3224] = "ER_AUDIT_LOG_USER_NAME_INVALID_CHARACTER";
    exports$1[3225] = "ER_AUDIT_LOG_HOST_NAME_INVALID_CHARACTER";
    exports$1[3226] = "WARN_DEPRECATED_MAXDB_SQL_MODE_FOR_TIMESTAMP";
    exports$1[3227] = "ER_XA_REPLICATION_FILTERS";
    exports$1[3228] = "ER_CANT_OPEN_ERROR_LOG";
    exports$1[3229] = "ER_GROUPING_ON_TIMESTAMP_IN_DST";
    exports$1[3230] = "ER_CANT_START_SERVER_NAMED_PIPE";
    exports$1[3231] = "ER_WRITE_SET_EXCEEDS_LIMIT";
    exports$1[3232] = "ER_DEPRECATED_TLS_VERSION_SESSION_57";
    exports$1[3233] = "ER_WARN_DEPRECATED_TLS_VERSION_57";
    exports$1[3234] = "ER_WARN_WRONG_NATIVE_TABLE_STRUCTURE";
    exports$1[3235] = "ER_AES_INVALID_KDF_NAME";
    exports$1[3236] = "ER_AES_INVALID_KDF_ITERATIONS";
    exports$1[3237] = "WARN_AES_KEY_SIZE";
    exports$1[3238] = "ER_AES_INVALID_KDF_OPTION_SIZE";
    exports$1[3500] = "ER_UNSUPPORT_COMPRESSED_TEMPORARY_TABLE";
    exports$1[3501] = "ER_ACL_OPERATION_FAILED";
    exports$1[3502] = "ER_UNSUPPORTED_INDEX_ALGORITHM";
    exports$1[3503] = "ER_NO_SUCH_DB";
    exports$1[3504] = "ER_TOO_BIG_ENUM";
    exports$1[3505] = "ER_TOO_LONG_SET_ENUM_VALUE";
    exports$1[3506] = "ER_INVALID_DD_OBJECT";
    exports$1[3507] = "ER_UPDATING_DD_TABLE";
    exports$1[3508] = "ER_INVALID_DD_OBJECT_ID";
    exports$1[3509] = "ER_INVALID_DD_OBJECT_NAME";
    exports$1[3510] = "ER_TABLESPACE_MISSING_WITH_NAME";
    exports$1[3511] = "ER_TOO_LONG_ROUTINE_COMMENT";
    exports$1[3512] = "ER_SP_LOAD_FAILED";
    exports$1[3513] = "ER_INVALID_BITWISE_OPERANDS_SIZE";
    exports$1[3514] = "ER_INVALID_BITWISE_AGGREGATE_OPERANDS_SIZE";
    exports$1[3515] = "ER_WARN_UNSUPPORTED_HINT";
    exports$1[3516] = "ER_UNEXPECTED_GEOMETRY_TYPE";
    exports$1[3517] = "ER_SRS_PARSE_ERROR";
    exports$1[3518] = "ER_SRS_PROJ_PARAMETER_MISSING";
    exports$1[3519] = "ER_WARN_SRS_NOT_FOUND";
    exports$1[3520] = "ER_SRS_NOT_CARTESIAN";
    exports$1[3521] = "ER_SRS_NOT_CARTESIAN_UNDEFINED";
    exports$1[3522] = "ER_PK_INDEX_CANT_BE_INVISIBLE";
    exports$1[3523] = "ER_UNKNOWN_AUTHID";
    exports$1[3524] = "ER_FAILED_ROLE_GRANT";
    exports$1[3525] = "ER_OPEN_ROLE_TABLES";
    exports$1[3526] = "ER_FAILED_DEFAULT_ROLES";
    exports$1[3527] = "ER_COMPONENTS_NO_SCHEME";
    exports$1[3528] = "ER_COMPONENTS_NO_SCHEME_SERVICE";
    exports$1[3529] = "ER_COMPONENTS_CANT_LOAD";
    exports$1[3530] = "ER_ROLE_NOT_GRANTED";
    exports$1[3531] = "ER_FAILED_REVOKE_ROLE";
    exports$1[3532] = "ER_RENAME_ROLE";
    exports$1[3533] = "ER_COMPONENTS_CANT_ACQUIRE_SERVICE_IMPLEMENTATION";
    exports$1[3534] = "ER_COMPONENTS_CANT_SATISFY_DEPENDENCY";
    exports$1[3535] = "ER_COMPONENTS_LOAD_CANT_REGISTER_SERVICE_IMPLEMENTATION";
    exports$1[3536] = "ER_COMPONENTS_LOAD_CANT_INITIALIZE";
    exports$1[3537] = "ER_COMPONENTS_UNLOAD_NOT_LOADED";
    exports$1[3538] = "ER_COMPONENTS_UNLOAD_CANT_DEINITIALIZE";
    exports$1[3539] = "ER_COMPONENTS_CANT_RELEASE_SERVICE";
    exports$1[3540] = "ER_COMPONENTS_UNLOAD_CANT_UNREGISTER_SERVICE";
    exports$1[3541] = "ER_COMPONENTS_CANT_UNLOAD";
    exports$1[3542] = "ER_WARN_UNLOAD_THE_NOT_PERSISTED";
    exports$1[3543] = "ER_COMPONENT_TABLE_INCORRECT";
    exports$1[3544] = "ER_COMPONENT_MANIPULATE_ROW_FAILED";
    exports$1[3545] = "ER_COMPONENTS_UNLOAD_DUPLICATE_IN_GROUP";
    exports$1[3546] = "ER_CANT_SET_GTID_PURGED_DUE_SETS_CONSTRAINTS";
    exports$1[3547] = "ER_CANNOT_LOCK_USER_MANAGEMENT_CACHES";
    exports$1[3548] = "ER_SRS_NOT_FOUND";
    exports$1[3549] = "ER_VARIABLE_NOT_PERSISTED";
    exports$1[3550] = "ER_IS_QUERY_INVALID_CLAUSE";
    exports$1[3551] = "ER_UNABLE_TO_STORE_STATISTICS";
    exports$1[3552] = "ER_NO_SYSTEM_SCHEMA_ACCESS";
    exports$1[3553] = "ER_NO_SYSTEM_TABLESPACE_ACCESS";
    exports$1[3554] = "ER_NO_SYSTEM_TABLE_ACCESS";
    exports$1[3555] = "ER_NO_SYSTEM_TABLE_ACCESS_FOR_DICTIONARY_TABLE";
    exports$1[3556] = "ER_NO_SYSTEM_TABLE_ACCESS_FOR_SYSTEM_TABLE";
    exports$1[3557] = "ER_NO_SYSTEM_TABLE_ACCESS_FOR_TABLE";
    exports$1[3558] = "ER_INVALID_OPTION_KEY";
    exports$1[3559] = "ER_INVALID_OPTION_VALUE";
    exports$1[3560] = "ER_INVALID_OPTION_KEY_VALUE_PAIR";
    exports$1[3561] = "ER_INVALID_OPTION_START_CHARACTER";
    exports$1[3562] = "ER_INVALID_OPTION_END_CHARACTER";
    exports$1[3563] = "ER_INVALID_OPTION_CHARACTERS";
    exports$1[3564] = "ER_DUPLICATE_OPTION_KEY";
    exports$1[3565] = "ER_WARN_SRS_NOT_FOUND_AXIS_ORDER";
    exports$1[3566] = "ER_NO_ACCESS_TO_NATIVE_FCT";
    exports$1[3567] = "ER_RESET_SOURCE_TO_VALUE_OUT_OF_RANGE";
    exports$1[3568] = "ER_UNRESOLVED_TABLE_LOCK";
    exports$1[3569] = "ER_DUPLICATE_TABLE_LOCK";
    exports$1[3570] = "ER_BINLOG_UNSAFE_SKIP_LOCKED";
    exports$1[3571] = "ER_BINLOG_UNSAFE_NOWAIT";
    exports$1[3572] = "ER_LOCK_NOWAIT";
    exports$1[3573] = "ER_CTE_RECURSIVE_REQUIRES_UNION";
    exports$1[3574] = "ER_CTE_RECURSIVE_REQUIRES_NONRECURSIVE_FIRST";
    exports$1[3575] = "ER_CTE_RECURSIVE_FORBIDS_AGGREGATION";
    exports$1[3576] = "ER_CTE_RECURSIVE_FORBIDDEN_JOIN_ORDER";
    exports$1[3577] = "ER_CTE_RECURSIVE_REQUIRES_SINGLE_REFERENCE";
    exports$1[3578] = "ER_SWITCH_TMP_ENGINE";
    exports$1[3579] = "ER_WINDOW_NO_SUCH_WINDOW";
    exports$1[3580] = "ER_WINDOW_CIRCULARITY_IN_WINDOW_GRAPH";
    exports$1[3581] = "ER_WINDOW_NO_CHILD_PARTITIONING";
    exports$1[3582] = "ER_WINDOW_NO_INHERIT_FRAME";
    exports$1[3583] = "ER_WINDOW_NO_REDEFINE_ORDER_BY";
    exports$1[3584] = "ER_WINDOW_FRAME_START_ILLEGAL";
    exports$1[3585] = "ER_WINDOW_FRAME_END_ILLEGAL";
    exports$1[3586] = "ER_WINDOW_FRAME_ILLEGAL";
    exports$1[3587] = "ER_WINDOW_RANGE_FRAME_ORDER_TYPE";
    exports$1[3588] = "ER_WINDOW_RANGE_FRAME_TEMPORAL_TYPE";
    exports$1[3589] = "ER_WINDOW_RANGE_FRAME_NUMERIC_TYPE";
    exports$1[3590] = "ER_WINDOW_RANGE_BOUND_NOT_CONSTANT";
    exports$1[3591] = "ER_WINDOW_DUPLICATE_NAME";
    exports$1[3592] = "ER_WINDOW_ILLEGAL_ORDER_BY";
    exports$1[3593] = "ER_WINDOW_INVALID_WINDOW_FUNC_USE";
    exports$1[3594] = "ER_WINDOW_INVALID_WINDOW_FUNC_ALIAS_USE";
    exports$1[3595] = "ER_WINDOW_NESTED_WINDOW_FUNC_USE_IN_WINDOW_SPEC";
    exports$1[3596] = "ER_WINDOW_ROWS_INTERVAL_USE";
    exports$1[3597] = "ER_WINDOW_NO_GROUP_ORDER";
    exports$1[3598] = "ER_WINDOW_EXPLAIN_JSON";
    exports$1[3599] = "ER_WINDOW_FUNCTION_IGNORES_FRAME";
    exports$1[3600] = "ER_WL9236_NOW";
    exports$1[3601] = "ER_INVALID_NO_OF_ARGS";
    exports$1[3602] = "ER_FIELD_IN_GROUPING_NOT_GROUP_BY";
    exports$1[3603] = "ER_TOO_LONG_TABLESPACE_COMMENT";
    exports$1[3604] = "ER_ENGINE_CANT_DROP_TABLE";
    exports$1[3605] = "ER_ENGINE_CANT_DROP_MISSING_TABLE";
    exports$1[3606] = "ER_TABLESPACE_DUP_FILENAME";
    exports$1[3607] = "ER_DB_DROP_RMDIR2";
    exports$1[3608] = "ER_IMP_NO_FILES_MATCHED";
    exports$1[3609] = "ER_IMP_SCHEMA_DOES_NOT_EXIST";
    exports$1[3610] = "ER_IMP_TABLE_ALREADY_EXISTS";
    exports$1[3611] = "ER_IMP_INCOMPATIBLE_MYSQLD_VERSION";
    exports$1[3612] = "ER_IMP_INCOMPATIBLE_DD_VERSION";
    exports$1[3613] = "ER_IMP_INCOMPATIBLE_SDI_VERSION";
    exports$1[3614] = "ER_WARN_INVALID_HINT";
    exports$1[3615] = "ER_VAR_DOES_NOT_EXIST";
    exports$1[3616] = "ER_LONGITUDE_OUT_OF_RANGE";
    exports$1[3617] = "ER_LATITUDE_OUT_OF_RANGE";
    exports$1[3618] = "ER_NOT_IMPLEMENTED_FOR_GEOGRAPHIC_SRS";
    exports$1[3619] = "ER_ILLEGAL_PRIVILEGE_LEVEL";
    exports$1[3620] = "ER_NO_SYSTEM_VIEW_ACCESS";
    exports$1[3621] = "ER_COMPONENT_FILTER_FLABBERGASTED";
    exports$1[3622] = "ER_PART_EXPR_TOO_LONG";
    exports$1[3623] = "ER_UDF_DROP_DYNAMICALLY_REGISTERED";
    exports$1[3624] = "ER_UNABLE_TO_STORE_COLUMN_STATISTICS";
    exports$1[3625] = "ER_UNABLE_TO_UPDATE_COLUMN_STATISTICS";
    exports$1[3626] = "ER_UNABLE_TO_DROP_COLUMN_STATISTICS";
    exports$1[3627] = "ER_UNABLE_TO_BUILD_HISTOGRAM";
    exports$1[3628] = "ER_MANDATORY_ROLE";
    exports$1[3629] = "ER_MISSING_TABLESPACE_FILE";
    exports$1[3630] = "ER_PERSIST_ONLY_ACCESS_DENIED_ERROR";
    exports$1[3631] = "ER_CMD_NEED_SUPER";
    exports$1[3632] = "ER_PATH_IN_DATADIR";
    exports$1[3633] = "ER_CLONE_DDL_IN_PROGRESS";
    exports$1[3634] = "ER_CLONE_TOO_MANY_CONCURRENT_CLONES";
    exports$1[3635] = "ER_APPLIER_LOG_EVENT_VALIDATION_ERROR";
    exports$1[3636] = "ER_CTE_MAX_RECURSION_DEPTH";
    exports$1[3637] = "ER_NOT_HINT_UPDATABLE_VARIABLE";
    exports$1[3638] = "ER_CREDENTIALS_CONTRADICT_TO_HISTORY";
    exports$1[3639] = "ER_WARNING_PASSWORD_HISTORY_CLAUSES_VOID";
    exports$1[3640] = "ER_CLIENT_DOES_NOT_SUPPORT";
    exports$1[3641] = "ER_I_S_SKIPPED_TABLESPACE";
    exports$1[3642] = "ER_TABLESPACE_ENGINE_MISMATCH";
    exports$1[3643] = "ER_WRONG_SRID_FOR_COLUMN";
    exports$1[3644] = "ER_CANNOT_ALTER_SRID_DUE_TO_INDEX";
    exports$1[3645] = "ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED";
    exports$1[3646] = "ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED";
    exports$1[3647] = "ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES";
    exports$1[3648] = "ER_COULD_NOT_APPLY_JSON_DIFF";
    exports$1[3649] = "ER_CORRUPTED_JSON_DIFF";
    exports$1[3650] = "ER_RESOURCE_GROUP_EXISTS";
    exports$1[3651] = "ER_RESOURCE_GROUP_NOT_EXISTS";
    exports$1[3652] = "ER_INVALID_VCPU_ID";
    exports$1[3653] = "ER_INVALID_VCPU_RANGE";
    exports$1[3654] = "ER_INVALID_THREAD_PRIORITY";
    exports$1[3655] = "ER_DISALLOWED_OPERATION";
    exports$1[3656] = "ER_RESOURCE_GROUP_BUSY";
    exports$1[3657] = "ER_RESOURCE_GROUP_DISABLED";
    exports$1[3658] = "ER_FEATURE_UNSUPPORTED";
    exports$1[3659] = "ER_ATTRIBUTE_IGNORED";
    exports$1[3660] = "ER_INVALID_THREAD_ID";
    exports$1[3661] = "ER_RESOURCE_GROUP_BIND_FAILED";
    exports$1[3662] = "ER_INVALID_USE_OF_FORCE_OPTION";
    exports$1[3663] = "ER_GROUP_REPLICATION_COMMAND_FAILURE";
    exports$1[3664] = "ER_SDI_OPERATION_FAILED";
    exports$1[3665] = "ER_MISSING_JSON_TABLE_VALUE";
    exports$1[3666] = "ER_WRONG_JSON_TABLE_VALUE";
    exports$1[3667] = "ER_TF_MUST_HAVE_ALIAS";
    exports$1[3668] = "ER_TF_FORBIDDEN_JOIN_TYPE";
    exports$1[3669] = "ER_JT_VALUE_OUT_OF_RANGE";
    exports$1[3670] = "ER_JT_MAX_NESTED_PATH";
    exports$1[3671] = "ER_PASSWORD_EXPIRATION_NOT_SUPPORTED_BY_AUTH_METHOD";
    exports$1[3672] = "ER_INVALID_GEOJSON_CRS_NOT_TOP_LEVEL";
    exports$1[3673] = "ER_BAD_NULL_ERROR_NOT_IGNORED";
    exports$1[3674] = "WARN_USELESS_SPATIAL_INDEX";
    exports$1[3675] = "ER_DISK_FULL_NOWAIT";
    exports$1[3676] = "ER_PARSE_ERROR_IN_DIGEST_FN";
    exports$1[3677] = "ER_UNDISCLOSED_PARSE_ERROR_IN_DIGEST_FN";
    exports$1[3678] = "ER_SCHEMA_DIR_EXISTS";
    exports$1[3679] = "ER_SCHEMA_DIR_MISSING";
    exports$1[3680] = "ER_SCHEMA_DIR_CREATE_FAILED";
    exports$1[3681] = "ER_SCHEMA_DIR_UNKNOWN";
    exports$1[3682] = "ER_ONLY_IMPLEMENTED_FOR_SRID_0_AND_4326";
    exports$1[3683] = "ER_BINLOG_EXPIRE_LOG_DAYS_AND_SECS_USED_TOGETHER";
    exports$1[3684] = "ER_REGEXP_BUFFER_OVERFLOW";
    exports$1[3685] = "ER_REGEXP_ILLEGAL_ARGUMENT";
    exports$1[3686] = "ER_REGEXP_INDEX_OUTOFBOUNDS_ERROR";
    exports$1[3687] = "ER_REGEXP_INTERNAL_ERROR";
    exports$1[3688] = "ER_REGEXP_RULE_SYNTAX";
    exports$1[3689] = "ER_REGEXP_BAD_ESCAPE_SEQUENCE";
    exports$1[3690] = "ER_REGEXP_UNIMPLEMENTED";
    exports$1[3691] = "ER_REGEXP_MISMATCHED_PAREN";
    exports$1[3692] = "ER_REGEXP_BAD_INTERVAL";
    exports$1[3693] = "ER_REGEXP_MAX_LT_MIN";
    exports$1[3694] = "ER_REGEXP_INVALID_BACK_REF";
    exports$1[3695] = "ER_REGEXP_LOOK_BEHIND_LIMIT";
    exports$1[3696] = "ER_REGEXP_MISSING_CLOSE_BRACKET";
    exports$1[3697] = "ER_REGEXP_INVALID_RANGE";
    exports$1[3698] = "ER_REGEXP_STACK_OVERFLOW";
    exports$1[3699] = "ER_REGEXP_TIME_OUT";
    exports$1[3700] = "ER_REGEXP_PATTERN_TOO_BIG";
    exports$1[3701] = "ER_CANT_SET_ERROR_LOG_SERVICE";
    exports$1[3702] = "ER_EMPTY_PIPELINE_FOR_ERROR_LOG_SERVICE";
    exports$1[3703] = "ER_COMPONENT_FILTER_DIAGNOSTICS";
    exports$1[3704] = "ER_NOT_IMPLEMENTED_FOR_CARTESIAN_SRS";
    exports$1[3705] = "ER_NOT_IMPLEMENTED_FOR_PROJECTED_SRS";
    exports$1[3706] = "ER_NONPOSITIVE_RADIUS";
    exports$1[3707] = "ER_RESTART_SERVER_FAILED";
    exports$1[3708] = "ER_SRS_MISSING_MANDATORY_ATTRIBUTE";
    exports$1[3709] = "ER_SRS_MULTIPLE_ATTRIBUTE_DEFINITIONS";
    exports$1[3710] = "ER_SRS_NAME_CANT_BE_EMPTY_OR_WHITESPACE";
    exports$1[3711] = "ER_SRS_ORGANIZATION_CANT_BE_EMPTY_OR_WHITESPACE";
    exports$1[3712] = "ER_SRS_ID_ALREADY_EXISTS";
    exports$1[3713] = "ER_WARN_SRS_ID_ALREADY_EXISTS";
    exports$1[3714] = "ER_CANT_MODIFY_SRID_0";
    exports$1[3715] = "ER_WARN_RESERVED_SRID_RANGE";
    exports$1[3716] = "ER_CANT_MODIFY_SRS_USED_BY_COLUMN";
    exports$1[3717] = "ER_SRS_INVALID_CHARACTER_IN_ATTRIBUTE";
    exports$1[3718] = "ER_SRS_ATTRIBUTE_STRING_TOO_LONG";
    exports$1[3719] = "ER_DEPRECATED_UTF8_ALIAS";
    exports$1[3720] = "ER_DEPRECATED_NATIONAL";
    exports$1[3721] = "ER_INVALID_DEFAULT_UTF8MB4_COLLATION";
    exports$1[3722] = "ER_UNABLE_TO_COLLECT_LOG_STATUS";
    exports$1[3723] = "ER_RESERVED_TABLESPACE_NAME";
    exports$1[3724] = "ER_UNABLE_TO_SET_OPTION";
    exports$1[3725] = "ER_REPLICA_POSSIBLY_DIVERGED_AFTER_DDL";
    exports$1[3726] = "ER_SRS_NOT_GEOGRAPHIC";
    exports$1[3727] = "ER_POLYGON_TOO_LARGE";
    exports$1[3728] = "ER_SPATIAL_UNIQUE_INDEX";
    exports$1[3729] = "ER_INDEX_TYPE_NOT_SUPPORTED_FOR_SPATIAL_INDEX";
    exports$1[3730] = "ER_FK_CANNOT_DROP_PARENT";
    exports$1[3731] = "ER_GEOMETRY_PARAM_LONGITUDE_OUT_OF_RANGE";
    exports$1[3732] = "ER_GEOMETRY_PARAM_LATITUDE_OUT_OF_RANGE";
    exports$1[3733] = "ER_FK_CANNOT_USE_VIRTUAL_COLUMN";
    exports$1[3734] = "ER_FK_NO_COLUMN_PARENT";
    exports$1[3735] = "ER_CANT_SET_ERROR_SUPPRESSION_LIST";
    exports$1[3736] = "ER_SRS_GEOGCS_INVALID_AXES";
    exports$1[3737] = "ER_SRS_INVALID_SEMI_MAJOR_AXIS";
    exports$1[3738] = "ER_SRS_INVALID_INVERSE_FLATTENING";
    exports$1[3739] = "ER_SRS_INVALID_ANGULAR_UNIT";
    exports$1[3740] = "ER_SRS_INVALID_PRIME_MERIDIAN";
    exports$1[3741] = "ER_TRANSFORM_SOURCE_SRS_NOT_SUPPORTED";
    exports$1[3742] = "ER_TRANSFORM_TARGET_SRS_NOT_SUPPORTED";
    exports$1[3743] = "ER_TRANSFORM_SOURCE_SRS_MISSING_TOWGS84";
    exports$1[3744] = "ER_TRANSFORM_TARGET_SRS_MISSING_TOWGS84";
    exports$1[3745] = "ER_TEMP_TABLE_PREVENTS_SWITCH_SESSION_BINLOG_FORMAT";
    exports$1[3746] = "ER_TEMP_TABLE_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT";
    exports$1[3747] = "ER_RUNNING_APPLIER_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT";
    exports$1[3748] = "ER_CLIENT_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRX_IN_SBR";
    exports$1[3749] = "ER_XA_CANT_CREATE_MDL_BACKUP";
    exports$1[3750] = "ER_TABLE_WITHOUT_PK";
    exports$1[3751] = "ER_WARN_DATA_TRUNCATED_FUNCTIONAL_INDEX";
    exports$1[3752] = "ER_WARN_DATA_OUT_OF_RANGE_FUNCTIONAL_INDEX";
    exports$1[3753] = "ER_FUNCTIONAL_INDEX_ON_JSON_OR_GEOMETRY_FUNCTION";
    exports$1[3754] = "ER_FUNCTIONAL_INDEX_REF_AUTO_INCREMENT";
    exports$1[3755] = "ER_CANNOT_DROP_COLUMN_FUNCTIONAL_INDEX";
    exports$1[3756] = "ER_FUNCTIONAL_INDEX_PRIMARY_KEY";
    exports$1[3757] = "ER_FUNCTIONAL_INDEX_ON_LOB";
    exports$1[3758] = "ER_FUNCTIONAL_INDEX_FUNCTION_IS_NOT_ALLOWED";
    exports$1[3759] = "ER_FULLTEXT_FUNCTIONAL_INDEX";
    exports$1[3760] = "ER_SPATIAL_FUNCTIONAL_INDEX";
    exports$1[3761] = "ER_WRONG_KEY_COLUMN_FUNCTIONAL_INDEX";
    exports$1[3762] = "ER_FUNCTIONAL_INDEX_ON_FIELD";
    exports$1[3763] = "ER_GENERATED_COLUMN_NAMED_FUNCTION_IS_NOT_ALLOWED";
    exports$1[3764] = "ER_GENERATED_COLUMN_ROW_VALUE";
    exports$1[3765] = "ER_GENERATED_COLUMN_VARIABLES";
    exports$1[3766] = "ER_DEPENDENT_BY_DEFAULT_GENERATED_VALUE";
    exports$1[3767] = "ER_DEFAULT_VAL_GENERATED_NON_PRIOR";
    exports$1[3768] = "ER_DEFAULT_VAL_GENERATED_REF_AUTO_INC";
    exports$1[3769] = "ER_DEFAULT_VAL_GENERATED_FUNCTION_IS_NOT_ALLOWED";
    exports$1[3770] = "ER_DEFAULT_VAL_GENERATED_NAMED_FUNCTION_IS_NOT_ALLOWED";
    exports$1[3771] = "ER_DEFAULT_VAL_GENERATED_ROW_VALUE";
    exports$1[3772] = "ER_DEFAULT_VAL_GENERATED_VARIABLES";
    exports$1[3773] = "ER_DEFAULT_AS_VAL_GENERATED";
    exports$1[3774] = "ER_UNSUPPORTED_ACTION_ON_DEFAULT_VAL_GENERATED";
    exports$1[3775] = "ER_GTID_UNSAFE_ALTER_ADD_COL_WITH_DEFAULT_EXPRESSION";
    exports$1[3776] = "ER_FK_CANNOT_CHANGE_ENGINE";
    exports$1[3777] = "ER_WARN_DEPRECATED_USER_SET_EXPR";
    exports$1[3778] = "ER_WARN_DEPRECATED_UTF8MB3_COLLATION";
    exports$1[3779] = "ER_WARN_DEPRECATED_NESTED_COMMENT_SYNTAX";
    exports$1[3780] = "ER_FK_INCOMPATIBLE_COLUMNS";
    exports$1[3781] = "ER_GR_HOLD_WAIT_TIMEOUT";
    exports$1[3782] = "ER_GR_HOLD_KILLED";
    exports$1[3783] = "ER_GR_HOLD_MEMBER_STATUS_ERROR";
    exports$1[3784] = "ER_RPL_ENCRYPTION_FAILED_TO_FETCH_KEY";
    exports$1[3785] = "ER_RPL_ENCRYPTION_KEY_NOT_FOUND";
    exports$1[3786] = "ER_RPL_ENCRYPTION_KEYRING_INVALID_KEY";
    exports$1[3787] = "ER_RPL_ENCRYPTION_HEADER_ERROR";
    exports$1[3788] = "ER_RPL_ENCRYPTION_FAILED_TO_ROTATE_LOGS";
    exports$1[3789] = "ER_RPL_ENCRYPTION_KEY_EXISTS_UNEXPECTED";
    exports$1[3790] = "ER_RPL_ENCRYPTION_FAILED_TO_GENERATE_KEY";
    exports$1[3791] = "ER_RPL_ENCRYPTION_FAILED_TO_STORE_KEY";
    exports$1[3792] = "ER_RPL_ENCRYPTION_FAILED_TO_REMOVE_KEY";
    exports$1[3793] = "ER_RPL_ENCRYPTION_UNABLE_TO_CHANGE_OPTION";
    exports$1[3794] = "ER_RPL_ENCRYPTION_MASTER_KEY_RECOVERY_FAILED";
    exports$1[3795] = "ER_SLOW_LOG_MODE_IGNORED_WHEN_NOT_LOGGING_TO_FILE";
    exports$1[3796] = "ER_GRP_TRX_CONSISTENCY_NOT_ALLOWED";
    exports$1[3797] = "ER_GRP_TRX_CONSISTENCY_BEFORE";
    exports$1[3798] = "ER_GRP_TRX_CONSISTENCY_AFTER_ON_TRX_BEGIN";
    exports$1[3799] = "ER_GRP_TRX_CONSISTENCY_BEGIN_NOT_ALLOWED";
    exports$1[3800] = "ER_FUNCTIONAL_INDEX_ROW_VALUE_IS_NOT_ALLOWED";
    exports$1[3801] = "ER_RPL_ENCRYPTION_FAILED_TO_ENCRYPT";
    exports$1[3802] = "ER_PAGE_TRACKING_NOT_STARTED";
    exports$1[3803] = "ER_PAGE_TRACKING_RANGE_NOT_TRACKED";
    exports$1[3804] = "ER_PAGE_TRACKING_CANNOT_PURGE";
    exports$1[3805] = "ER_RPL_ENCRYPTION_CANNOT_ROTATE_BINLOG_MASTER_KEY";
    exports$1[3806] = "ER_BINLOG_MASTER_KEY_RECOVERY_OUT_OF_COMBINATION";
    exports$1[3807] = "ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_OPERATE_KEY";
    exports$1[3808] = "ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_ROTATE_LOGS";
    exports$1[3809] = "ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_REENCRYPT_LOG";
    exports$1[3810] = "ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_UNUSED_KEYS";
    exports$1[3811] = "ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_AUX_KEY";
    exports$1[3812] = "ER_NON_BOOLEAN_EXPR_FOR_CHECK_CONSTRAINT";
    exports$1[3813] = "ER_COLUMN_CHECK_CONSTRAINT_REFERENCES_OTHER_COLUMN";
    exports$1[3814] = "ER_CHECK_CONSTRAINT_NAMED_FUNCTION_IS_NOT_ALLOWED";
    exports$1[3815] = "ER_CHECK_CONSTRAINT_FUNCTION_IS_NOT_ALLOWED";
    exports$1[3816] = "ER_CHECK_CONSTRAINT_VARIABLES";
    exports$1[3817] = "ER_CHECK_CONSTRAINT_ROW_VALUE";
    exports$1[3818] = "ER_CHECK_CONSTRAINT_REFERS_AUTO_INCREMENT_COLUMN";
    exports$1[3819] = "ER_CHECK_CONSTRAINT_VIOLATED";
    exports$1[3820] = "ER_CHECK_CONSTRAINT_REFERS_UNKNOWN_COLUMN";
    exports$1[3821] = "ER_CHECK_CONSTRAINT_NOT_FOUND";
    exports$1[3822] = "ER_CHECK_CONSTRAINT_DUP_NAME";
    exports$1[3823] = "ER_CHECK_CONSTRAINT_CLAUSE_USING_FK_REFER_ACTION_COLUMN";
    exports$1[3824] = "WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB";
    exports$1[3825] = "ER_INVALID_ENCRYPTION_REQUEST";
    exports$1[3826] = "ER_CANNOT_SET_TABLE_ENCRYPTION";
    exports$1[3827] = "ER_CANNOT_SET_DATABASE_ENCRYPTION";
    exports$1[3828] = "ER_CANNOT_SET_TABLESPACE_ENCRYPTION";
    exports$1[3829] = "ER_TABLESPACE_CANNOT_BE_ENCRYPTED";
    exports$1[3830] = "ER_TABLESPACE_CANNOT_BE_DECRYPTED";
    exports$1[3831] = "ER_TABLESPACE_TYPE_UNKNOWN";
    exports$1[3832] = "ER_TARGET_TABLESPACE_UNENCRYPTED";
    exports$1[3833] = "ER_CANNOT_USE_ENCRYPTION_CLAUSE";
    exports$1[3834] = "ER_INVALID_MULTIPLE_CLAUSES";
    exports$1[3835] = "ER_UNSUPPORTED_USE_OF_GRANT_AS";
    exports$1[3836] = "ER_UKNOWN_AUTH_ID_OR_ACCESS_DENIED_FOR_GRANT_AS";
    exports$1[3837] = "ER_DEPENDENT_BY_FUNCTIONAL_INDEX";
    exports$1[3838] = "ER_PLUGIN_NOT_EARLY";
    exports$1[3839] = "ER_INNODB_REDO_LOG_ARCHIVE_START_SUBDIR_PATH";
    exports$1[3840] = "ER_INNODB_REDO_LOG_ARCHIVE_START_TIMEOUT";
    exports$1[3841] = "ER_INNODB_REDO_LOG_ARCHIVE_DIRS_INVALID";
    exports$1[3842] = "ER_INNODB_REDO_LOG_ARCHIVE_LABEL_NOT_FOUND";
    exports$1[3843] = "ER_INNODB_REDO_LOG_ARCHIVE_DIR_EMPTY";
    exports$1[3844] = "ER_INNODB_REDO_LOG_ARCHIVE_NO_SUCH_DIR";
    exports$1[3845] = "ER_INNODB_REDO_LOG_ARCHIVE_DIR_CLASH";
    exports$1[3846] = "ER_INNODB_REDO_LOG_ARCHIVE_DIR_PERMISSIONS";
    exports$1[3847] = "ER_INNODB_REDO_LOG_ARCHIVE_FILE_CREATE";
    exports$1[3848] = "ER_INNODB_REDO_LOG_ARCHIVE_ACTIVE";
    exports$1[3849] = "ER_INNODB_REDO_LOG_ARCHIVE_INACTIVE";
    exports$1[3850] = "ER_INNODB_REDO_LOG_ARCHIVE_FAILED";
    exports$1[3851] = "ER_INNODB_REDO_LOG_ARCHIVE_SESSION";
    exports$1[3852] = "ER_STD_REGEX_ERROR";
    exports$1[3853] = "ER_INVALID_JSON_TYPE";
    exports$1[3854] = "ER_CANNOT_CONVERT_STRING";
    exports$1[3855] = "ER_DEPENDENT_BY_PARTITION_FUNC";
    exports$1[3856] = "ER_WARN_DEPRECATED_FLOAT_AUTO_INCREMENT";
    exports$1[3857] = "ER_RPL_CANT_STOP_REPLICA_WHILE_LOCKED_BACKUP";
    exports$1[3858] = "ER_WARN_DEPRECATED_FLOAT_DIGITS";
    exports$1[3859] = "ER_WARN_DEPRECATED_FLOAT_UNSIGNED";
    exports$1[3860] = "ER_WARN_DEPRECATED_INTEGER_DISPLAY_WIDTH";
    exports$1[3861] = "ER_WARN_DEPRECATED_ZEROFILL";
    exports$1[3862] = "ER_CLONE_DONOR";
    exports$1[3863] = "ER_CLONE_PROTOCOL";
    exports$1[3864] = "ER_CLONE_DONOR_VERSION";
    exports$1[3865] = "ER_CLONE_OS";
    exports$1[3866] = "ER_CLONE_PLATFORM";
    exports$1[3867] = "ER_CLONE_CHARSET";
    exports$1[3868] = "ER_CLONE_CONFIG";
    exports$1[3869] = "ER_CLONE_SYS_CONFIG";
    exports$1[3870] = "ER_CLONE_PLUGIN_MATCH";
    exports$1[3871] = "ER_CLONE_LOOPBACK";
    exports$1[3872] = "ER_CLONE_ENCRYPTION";
    exports$1[3873] = "ER_CLONE_DISK_SPACE";
    exports$1[3874] = "ER_CLONE_IN_PROGRESS";
    exports$1[3875] = "ER_CLONE_DISALLOWED";
    exports$1[3876] = "ER_CANNOT_GRANT_ROLES_TO_ANONYMOUS_USER";
    exports$1[3877] = "ER_SECONDARY_ENGINE_PLUGIN";
    exports$1[3878] = "ER_SECOND_PASSWORD_CANNOT_BE_EMPTY";
    exports$1[3879] = "ER_DB_ACCESS_DENIED";
    exports$1[3880] = "ER_DA_AUTH_ID_WITH_SYSTEM_USER_PRIV_IN_MANDATORY_ROLES";
    exports$1[3881] = "ER_DA_RPL_GTID_TABLE_CANNOT_OPEN";
    exports$1[3882] = "ER_GEOMETRY_IN_UNKNOWN_LENGTH_UNIT";
    exports$1[3883] = "ER_DA_PLUGIN_INSTALL_ERROR";
    exports$1[3884] = "ER_NO_SESSION_TEMP";
    exports$1[3885] = "ER_DA_UNKNOWN_ERROR_NUMBER";
    exports$1[3886] = "ER_COLUMN_CHANGE_SIZE";
    exports$1[3887] = "ER_REGEXP_INVALID_CAPTURE_GROUP_NAME";
    exports$1[3888] = "ER_DA_SSL_LIBRARY_ERROR";
    exports$1[3889] = "ER_SECONDARY_ENGINE";
    exports$1[3890] = "ER_SECONDARY_ENGINE_DDL";
    exports$1[3891] = "ER_INCORRECT_CURRENT_PASSWORD";
    exports$1[3892] = "ER_MISSING_CURRENT_PASSWORD";
    exports$1[3893] = "ER_CURRENT_PASSWORD_NOT_REQUIRED";
    exports$1[3894] = "ER_PASSWORD_CANNOT_BE_RETAINED_ON_PLUGIN_CHANGE";
    exports$1[3895] = "ER_CURRENT_PASSWORD_CANNOT_BE_RETAINED";
    exports$1[3896] = "ER_PARTIAL_REVOKES_EXIST";
    exports$1[3897] = "ER_CANNOT_GRANT_SYSTEM_PRIV_TO_MANDATORY_ROLE";
    exports$1[3898] = "ER_XA_REPLICATION_FILTERS";
    exports$1[3899] = "ER_UNSUPPORTED_SQL_MODE";
    exports$1[3900] = "ER_REGEXP_INVALID_FLAG";
    exports$1[3901] = "ER_PARTIAL_REVOKE_AND_DB_GRANT_BOTH_EXISTS";
    exports$1[3902] = "ER_UNIT_NOT_FOUND";
    exports$1[3903] = "ER_INVALID_JSON_VALUE_FOR_FUNC_INDEX";
    exports$1[3904] = "ER_JSON_VALUE_OUT_OF_RANGE_FOR_FUNC_INDEX";
    exports$1[3905] = "ER_EXCEEDED_MV_KEYS_NUM";
    exports$1[3906] = "ER_EXCEEDED_MV_KEYS_SPACE";
    exports$1[3907] = "ER_FUNCTIONAL_INDEX_DATA_IS_TOO_LONG";
    exports$1[3908] = "ER_WRONG_MVI_VALUE";
    exports$1[3909] = "ER_WARN_FUNC_INDEX_NOT_APPLICABLE";
    exports$1[3910] = "ER_GRP_RPL_UDF_ERROR";
    exports$1[3911] = "ER_UPDATE_GTID_PURGED_WITH_GR";
    exports$1[3912] = "ER_GROUPING_ON_TIMESTAMP_IN_DST";
    exports$1[3913] = "ER_TABLE_NAME_CAUSES_TOO_LONG_PATH";
    exports$1[3914] = "ER_AUDIT_LOG_INSUFFICIENT_PRIVILEGE";
    exports$1[3915] = "ER_AUDIT_LOG_PASSWORD_HAS_BEEN_COPIED";
    exports$1[3916] = "ER_DA_GRP_RPL_STARTED_AUTO_REJOIN";
    exports$1[3917] = "ER_SYSVAR_CHANGE_DURING_QUERY";
    exports$1[3918] = "ER_GLOBSTAT_CHANGE_DURING_QUERY";
    exports$1[3919] = "ER_GRP_RPL_MESSAGE_SERVICE_INIT_FAILURE";
    exports$1[3920] = "ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_CLIENT";
    exports$1[3921] = "ER_CHANGE_SOURCE_WRONG_COMPRESSION_LEVEL_CLIENT";
    exports$1[3922] = "ER_WRONG_COMPRESSION_ALGORITHM_CLIENT";
    exports$1[3923] = "ER_WRONG_COMPRESSION_LEVEL_CLIENT";
    exports$1[3924] = "ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_LIST_CLIENT";
    exports$1[3925] = "ER_CLIENT_PRIVILEGE_CHECKS_USER_CANNOT_BE_ANONYMOUS";
    exports$1[3926] = "ER_CLIENT_PRIVILEGE_CHECKS_USER_DOES_NOT_EXIST";
    exports$1[3927] = "ER_CLIENT_PRIVILEGE_CHECKS_USER_CORRUPT";
    exports$1[3928] = "ER_CLIENT_PRIVILEGE_CHECKS_USER_NEEDS_RPL_APPLIER_PRIV";
    exports$1[3929] = "ER_WARN_DA_PRIVILEGE_NOT_REGISTERED";
    exports$1[3930] = "ER_CLIENT_KEYRING_UDF_KEY_INVALID";
    exports$1[3931] = "ER_CLIENT_KEYRING_UDF_KEY_TYPE_INVALID";
    exports$1[3932] = "ER_CLIENT_KEYRING_UDF_KEY_TOO_LONG";
    exports$1[3933] = "ER_CLIENT_KEYRING_UDF_KEY_TYPE_TOO_LONG";
    exports$1[3934] = "ER_JSON_SCHEMA_VALIDATION_ERROR_WITH_DETAILED_REPORT";
    exports$1[3935] = "ER_DA_UDF_INVALID_CHARSET_SPECIFIED";
    exports$1[3936] = "ER_DA_UDF_INVALID_CHARSET";
    exports$1[3937] = "ER_DA_UDF_INVALID_COLLATION";
    exports$1[3938] = "ER_DA_UDF_INVALID_EXTENSION_ARGUMENT_TYPE";
    exports$1[3939] = "ER_MULTIPLE_CONSTRAINTS_WITH_SAME_NAME";
    exports$1[3940] = "ER_CONSTRAINT_NOT_FOUND";
    exports$1[3941] = "ER_ALTER_CONSTRAINT_ENFORCEMENT_NOT_SUPPORTED";
    exports$1[3942] = "ER_TABLE_VALUE_CONSTRUCTOR_MUST_HAVE_COLUMNS";
    exports$1[3943] = "ER_TABLE_VALUE_CONSTRUCTOR_CANNOT_HAVE_DEFAULT";
    exports$1[3944] = "ER_CLIENT_QUERY_FAILURE_INVALID_NON_ROW_FORMAT";
    exports$1[3945] = "ER_REQUIRE_ROW_FORMAT_INVALID_VALUE";
    exports$1[3946] = "ER_FAILED_TO_DETERMINE_IF_ROLE_IS_MANDATORY";
    exports$1[3947] = "ER_FAILED_TO_FETCH_MANDATORY_ROLE_LIST";
    exports$1[3948] = "ER_CLIENT_LOCAL_FILES_DISABLED";
    exports$1[3949] = "ER_IMP_INCOMPATIBLE_CFG_VERSION";
    exports$1[3950] = "ER_DA_OOM";
    exports$1[3951] = "ER_DA_UDF_INVALID_ARGUMENT_TO_SET_CHARSET";
    exports$1[3952] = "ER_DA_UDF_INVALID_RETURN_TYPE_TO_SET_CHARSET";
    exports$1[3953] = "ER_MULTIPLE_INTO_CLAUSES";
    exports$1[3954] = "ER_MISPLACED_INTO";
    exports$1[3955] = "ER_USER_ACCESS_DENIED_FOR_USER_ACCOUNT_BLOCKED_BY_PASSWORD_LOCK";
    exports$1[3956] = "ER_WARN_DEPRECATED_YEAR_UNSIGNED";
    exports$1[3957] = "ER_CLONE_NETWORK_PACKET";
    exports$1[3958] = "ER_SDI_OPERATION_FAILED_MISSING_RECORD";
    exports$1[3959] = "ER_DEPENDENT_BY_CHECK_CONSTRAINT";
    exports$1[3960] = "ER_GRP_OPERATION_NOT_ALLOWED_GR_MUST_STOP";
    exports$1[3961] = "ER_WARN_DEPRECATED_JSON_TABLE_ON_ERROR_ON_EMPTY";
    exports$1[3962] = "ER_WARN_DEPRECATED_INNER_INTO";
    exports$1[3963] = "ER_WARN_DEPRECATED_VALUES_FUNCTION_ALWAYS_NULL";
    exports$1[3964] = "ER_WARN_DEPRECATED_SQL_CALC_FOUND_ROWS";
    exports$1[3965] = "ER_WARN_DEPRECATED_FOUND_ROWS";
    exports$1[3966] = "ER_MISSING_JSON_VALUE";
    exports$1[3967] = "ER_MULTIPLE_JSON_VALUES";
    exports$1[3968] = "ER_HOSTNAME_TOO_LONG";
    exports$1[3969] = "ER_WARN_CLIENT_DEPRECATED_PARTITION_PREFIX_KEY";
    exports$1[3970] = "ER_GROUP_REPLICATION_USER_EMPTY_MSG";
    exports$1[3971] = "ER_GROUP_REPLICATION_USER_MANDATORY_MSG";
    exports$1[3972] = "ER_GROUP_REPLICATION_PASSWORD_LENGTH";
    exports$1[3973] = "ER_SUBQUERY_TRANSFORM_REJECTED";
    exports$1[3974] = "ER_DA_GRP_RPL_RECOVERY_ENDPOINT_FORMAT";
    exports$1[3975] = "ER_DA_GRP_RPL_RECOVERY_ENDPOINT_INVALID";
    exports$1[3976] = "ER_WRONG_VALUE_FOR_VAR_PLUS_ACTIONABLE_PART";
    exports$1[3977] = "ER_STATEMENT_NOT_ALLOWED_AFTER_START_TRANSACTION";
    exports$1[3978] = "ER_FOREIGN_KEY_WITH_ATOMIC_CREATE_SELECT";
    exports$1[3979] = "ER_NOT_ALLOWED_WITH_START_TRANSACTION";
    exports$1[3980] = "ER_INVALID_JSON_ATTRIBUTE";
    exports$1[3981] = "ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED";
    exports$1[3982] = "ER_INVALID_USER_ATTRIBUTE_JSON";
    exports$1[3983] = "ER_INNODB_REDO_DISABLED";
    exports$1[3984] = "ER_INNODB_REDO_ARCHIVING_ENABLED";
    exports$1[3985] = "ER_MDL_OUT_OF_RESOURCES";
    exports$1[3986] = "ER_IMPLICIT_COMPARISON_FOR_JSON";
    exports$1[3987] = "ER_FUNCTION_DOES_NOT_SUPPORT_CHARACTER_SET";
    exports$1[3988] = "ER_IMPOSSIBLE_STRING_CONVERSION";
    exports$1[3989] = "ER_SCHEMA_READ_ONLY";
    exports$1[3990] = "ER_RPL_ASYNC_RECONNECT_GTID_MODE_OFF";
    exports$1[3991] = "ER_RPL_ASYNC_RECONNECT_AUTO_POSITION_OFF";
    exports$1[3992] = "ER_DISABLE_GTID_MODE_REQUIRES_ASYNC_RECONNECT_OFF";
    exports$1[3993] = "ER_DISABLE_AUTO_POSITION_REQUIRES_ASYNC_RECONNECT_OFF";
    exports$1[3994] = "ER_INVALID_PARAMETER_USE";
    exports$1[3995] = "ER_CHARACTER_SET_MISMATCH";
    exports$1[3996] = "ER_WARN_VAR_VALUE_CHANGE_NOT_SUPPORTED";
    exports$1[3997] = "ER_INVALID_TIME_ZONE_INTERVAL";
    exports$1[3998] = "ER_INVALID_CAST";
    exports$1[3999] = "ER_HYPERGRAPH_NOT_SUPPORTED_YET";
    exports$1[4e3] = "ER_WARN_HYPERGRAPH_EXPERIMENTAL";
    exports$1[4001] = "ER_DA_NO_ERROR_LOG_PARSER_CONFIGURED";
    exports$1[4002] = "ER_DA_ERROR_LOG_TABLE_DISABLED";
    exports$1[4003] = "ER_DA_ERROR_LOG_MULTIPLE_FILTERS";
    exports$1[4004] = "ER_DA_CANT_OPEN_ERROR_LOG";
    exports$1[4005] = "ER_USER_REFERENCED_AS_DEFINER";
    exports$1[4006] = "ER_CANNOT_USER_REFERENCED_AS_DEFINER";
    exports$1[4007] = "ER_REGEX_NUMBER_TOO_BIG";
    exports$1[4008] = "ER_SPVAR_NONINTEGER_TYPE";
    exports$1[4009] = "WARN_UNSUPPORTED_ACL_TABLES_READ";
    exports$1[4010] = "ER_BINLOG_UNSAFE_ACL_TABLE_READ_IN_DML_DDL";
    exports$1[4011] = "ER_STOP_REPLICA_MONITOR_IO_THREAD_TIMEOUT";
    exports$1[4012] = "ER_STARTING_REPLICA_MONITOR_IO_THREAD";
    exports$1[4013] = "ER_CANT_USE_ANONYMOUS_TO_GTID_WITH_GTID_MODE_NOT_ON";
    exports$1[4014] = "ER_CANT_COMBINE_ANONYMOUS_TO_GTID_AND_AUTOPOSITION";
    exports$1[4015] = "ER_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_REQUIRES_GTID_MODE_ON";
    exports$1[4016] = "ER_SQL_REPLICA_SKIP_COUNTER_USED_WITH_GTID_MODE_ON";
    exports$1[4017] = "ER_USING_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_AS_LOCAL_OR_UUID";
    exports$1[4018] = "ER_CANT_SET_ANONYMOUS_TO_GTID_AND_WAIT_UNTIL_SQL_THD_AFTER_GTIDS";
    exports$1[4019] = "ER_CANT_SET_SQL_AFTER_OR_BEFORE_GTIDS_WITH_ANONYMOUS_TO_GTID";
    exports$1[4020] = "ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_GROUP_NAME";
    exports$1[4021] = "ER_CANT_USE_SAME_UUID_AS_GROUP_NAME";
    exports$1[4022] = "ER_GRP_RPL_RECOVERY_CHANNEL_STILL_RUNNING";
    exports$1[4023] = "ER_INNODB_INVALID_AUTOEXTEND_SIZE_VALUE";
    exports$1[4024] = "ER_INNODB_INCOMPATIBLE_WITH_TABLESPACE";
    exports$1[4025] = "ER_INNODB_AUTOEXTEND_SIZE_OUT_OF_RANGE";
    exports$1[4026] = "ER_CANNOT_USE_AUTOEXTEND_SIZE_CLAUSE";
    exports$1[4027] = "ER_ROLE_GRANTED_TO_ITSELF";
    exports$1[4028] = "ER_TABLE_MUST_HAVE_A_VISIBLE_COLUMN";
    exports$1[4029] = "ER_INNODB_COMPRESSION_FAILURE";
    exports$1[4030] = "ER_WARN_ASYNC_CONN_FAILOVER_NETWORK_NAMESPACE";
    exports$1[4031] = "ER_CLIENT_INTERACTION_TIMEOUT";
    exports$1[4032] = "ER_INVALID_CAST_TO_GEOMETRY";
    exports$1[4033] = "ER_INVALID_CAST_POLYGON_RING_DIRECTION";
    exports$1[4034] = "ER_GIS_DIFFERENT_SRIDS_AGGREGATION";
    exports$1[4035] = "ER_RELOAD_KEYRING_FAILURE";
    exports$1[4036] = "ER_SDI_GET_KEYS_INVALID_TABLESPACE";
    exports$1[4037] = "ER_CHANGE_RPL_SRC_WRONG_COMPRESSION_ALGORITHM_SIZE";
    exports$1[4038] = "ER_WARN_DEPRECATED_TLS_VERSION_FOR_CHANNEL_CLI";
    exports$1[4039] = "ER_CANT_USE_SAME_UUID_AS_VIEW_CHANGE_UUID";
    exports$1[4040] = "ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_VIEW_CHANGE_UUID";
    exports$1[4041] = "ER_GRP_RPL_VIEW_CHANGE_UUID_FAIL_GET_VARIABLE";
    exports$1[4042] = "ER_WARN_ADUIT_LOG_MAX_SIZE_AND_PRUNE_SECONDS";
    exports$1[4043] = "ER_WARN_ADUIT_LOG_MAX_SIZE_CLOSE_TO_ROTATE_ON_SIZE";
    exports$1[4044] = "ER_KERBEROS_CREATE_USER";
    exports$1[4045] = "ER_INSTALL_PLUGIN_CONFLICT_CLIENT";
    exports$1[4046] = "ER_DA_ERROR_LOG_COMPONENT_FLUSH_FAILED";
    exports$1[4047] = "ER_WARN_SQL_AFTER_MTS_GAPS_GAP_NOT_CALCULATED";
    exports$1[4048] = "ER_INVALID_ASSIGNMENT_TARGET";
    exports$1[4049] = "ER_OPERATION_NOT_ALLOWED_ON_GR_SECONDARY";
    exports$1[4050] = "ER_GRP_RPL_FAILOVER_CHANNEL_STATUS_PROPAGATION";
    exports$1[4051] = "ER_WARN_AUDIT_LOG_FORMAT_UNIX_TIMESTAMP_ONLY_WHEN_JSON";
    exports$1[4052] = "ER_INVALID_MFA_PLUGIN_SPECIFIED";
    exports$1[4053] = "ER_IDENTIFIED_BY_UNSUPPORTED";
    exports$1[4054] = "ER_INVALID_PLUGIN_FOR_REGISTRATION";
    exports$1[4055] = "ER_PLUGIN_REQUIRES_REGISTRATION";
    exports$1[4056] = "ER_MFA_METHOD_EXISTS";
    exports$1[4057] = "ER_MFA_METHOD_NOT_EXISTS";
    exports$1[4058] = "ER_AUTHENTICATION_POLICY_MISMATCH";
    exports$1[4059] = "ER_PLUGIN_REGISTRATION_DONE";
    exports$1[4060] = "ER_INVALID_USER_FOR_REGISTRATION";
    exports$1[4061] = "ER_USER_REGISTRATION_FAILED";
    exports$1[4062] = "ER_MFA_METHODS_INVALID_ORDER";
    exports$1[4063] = "ER_MFA_METHODS_IDENTICAL";
    exports$1[4064] = "ER_INVALID_MFA_OPERATIONS_FOR_PASSWORDLESS_USER";
    exports$1[4065] = "ER_CHANGE_REPLICATION_SOURCE_NO_OPTIONS_FOR_GTID_ONLY";
    exports$1[4066] = "ER_CHANGE_REP_SOURCE_CANT_DISABLE_REQ_ROW_FORMAT_WITH_GTID_ONLY";
    exports$1[4067] = "ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POSITION_WITH_GTID_ONLY";
    exports$1[4068] = "ER_CHANGE_REP_SOURCE_CANT_DISABLE_GTID_ONLY_WITHOUT_POSITIONS";
    exports$1[4069] = "ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POS_WITHOUT_POSITIONS";
    exports$1[4070] = "ER_CHANGE_REP_SOURCE_GR_CHANNEL_WITH_GTID_MODE_NOT_ON";
    exports$1[4071] = "ER_CANT_USE_GTID_ONLY_WITH_GTID_MODE_NOT_ON";
    exports$1[4072] = "ER_WARN_C_DISABLE_GTID_ONLY_WITH_SOURCE_AUTO_POS_INVALID_POS";
    exports$1[4073] = "ER_DA_SSL_FIPS_MODE_ERROR";
    exports$1[4074] = "ER_VALUE_OUT_OF_RANGE";
    exports$1[4075] = "ER_FULLTEXT_WITH_ROLLUP";
    exports$1[4076] = "ER_REGEXP_MISSING_RESOURCE";
    exports$1[4077] = "ER_WARN_REGEXP_USING_DEFAULT";
    exports$1[4078] = "ER_REGEXP_MISSING_FILE";
    exports$1[4079] = "ER_WARN_DEPRECATED_COLLATION";
    exports$1[4080] = "ER_CONCURRENT_PROCEDURE_USAGE";
    exports$1[4081] = "ER_DA_GLOBAL_CONN_LIMIT";
    exports$1[4082] = "ER_DA_CONN_LIMIT";
    exports$1[4083] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE_INSTANT";
    exports$1[4084] = "ER_WARN_SF_UDF_NAME_COLLISION";
    exports$1[4085] = "ER_CANNOT_PURGE_BINLOG_WITH_BACKUP_LOCK";
    exports$1[4086] = "ER_TOO_MANY_WINDOWS";
    exports$1[4087] = "ER_MYSQLBACKUP_CLIENT_MSG";
    exports$1[4088] = "ER_COMMENT_CONTAINS_INVALID_STRING";
    exports$1[4089] = "ER_DEFINITION_CONTAINS_INVALID_STRING";
    exports$1[4090] = "ER_CANT_EXECUTE_COMMAND_WITH_ASSIGNED_GTID_NEXT";
    exports$1[4091] = "ER_XA_TEMP_TABLE";
    exports$1[4092] = "ER_INNODB_MAX_ROW_VERSION";
    exports$1[4093] = "ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_SIZE";
    exports$1[4094] = "ER_OPERATION_NOT_ALLOWED_WHILE_PRIMARY_CHANGE_IS_RUNNING";
    exports$1[4095] = "ER_WARN_DEPRECATED_DATETIME_DELIMITER";
    exports$1[4096] = "ER_WARN_DEPRECATED_SUPERFLUOUS_DELIMITER";
    exports$1[4097] = "ER_CANNOT_PERSIST_SENSITIVE_VARIABLES";
    exports$1[4098] = "ER_WARN_CANNOT_SECURELY_PERSIST_SENSITIVE_VARIABLES";
    exports$1[4099] = "ER_WARN_TRG_ALREADY_EXISTS";
    exports$1[4100] = "ER_IF_NOT_EXISTS_UNSUPPORTED_TRG_EXISTS_ON_DIFFERENT_TABLE";
    exports$1[4101] = "ER_IF_NOT_EXISTS_UNSUPPORTED_UDF_NATIVE_FCT_NAME_COLLISION";
    exports$1[4102] = "ER_SET_PASSWORD_AUTH_PLUGIN_ERROR";
    exports$1[4103] = "ER_REDUCED_DBLWR_FILE_CORRUPTED";
    exports$1[4104] = "ER_REDUCED_DBLWR_PAGE_FOUND";
    exports$1[4105] = "ER_SRS_INVALID_LATITUDE_OF_ORIGIN";
    exports$1[4106] = "ER_SRS_INVALID_LONGITUDE_OF_ORIGIN";
    exports$1[4107] = "ER_SRS_UNUSED_PROJ_PARAMETER_PRESENT";
    exports$1[4108] = "ER_GIPK_COLUMN_EXISTS";
    exports$1[4109] = "ER_GIPK_FAILED_AUTOINC_COLUMN_EXISTS";
    exports$1[4110] = "ER_GIPK_COLUMN_ALTER_NOT_ALLOWED";
    exports$1[4111] = "ER_DROP_PK_COLUMN_TO_DROP_GIPK";
    exports$1[4112] = "ER_CREATE_SELECT_WITH_GIPK_DISALLOWED_IN_SBR";
    exports$1[4113] = "ER_DA_EXPIRE_LOGS_DAYS_IGNORED";
    exports$1[4114] = "ER_CTE_RECURSIVE_NOT_UNION";
    exports$1[4115] = "ER_COMMAND_BACKEND_FAILED_TO_FETCH_SECURITY_CTX";
    exports$1[4116] = "ER_COMMAND_SERVICE_BACKEND_FAILED";
    exports$1[4117] = "ER_CLIENT_FILE_PRIVILEGE_FOR_REPLICATION_CHECKS";
    exports$1[4118] = "ER_GROUP_REPLICATION_FORCE_MEMBERS_COMMAND_FAILURE";
    exports$1[4119] = "ER_WARN_DEPRECATED_IDENT";
    exports$1[4120] = "ER_INTERSECT_ALL_MAX_DUPLICATES_EXCEEDED";
    exports$1[4121] = "ER_TP_QUERY_THRS_PER_GRP_EXCEEDS_TXN_THR_LIMIT";
    exports$1[4122] = "ER_BAD_TIMESTAMP_FORMAT";
    exports$1[4123] = "ER_SHAPE_PRIDICTION_UDF";
    exports$1[4124] = "ER_SRS_INVALID_HEIGHT";
    exports$1[4125] = "ER_SRS_INVALID_SCALING";
    exports$1[4126] = "ER_SRS_INVALID_ZONE_WIDTH";
    exports$1[4127] = "ER_SRS_INVALID_LATITUDE_POLAR_STERE_VAR_A";
    exports$1[4128] = "ER_WARN_DEPRECATED_CLIENT_NO_SCHEMA_OPTION";
    exports$1[4129] = "ER_TABLE_NOT_EMPTY";
    exports$1[4130] = "ER_TABLE_NO_PRIMARY_KEY";
    exports$1[4131] = "ER_TABLE_IN_SHARED_TABLESPACE";
    exports$1[4132] = "ER_INDEX_OTHER_THAN_PK";
    exports$1[4133] = "ER_LOAD_BULK_DATA_UNSORTED";
    exports$1[4134] = "ER_BULK_EXECUTOR_ERROR";
    exports$1[4135] = "ER_BULK_READER_LIBCURL_INIT_FAILED";
    exports$1[4136] = "ER_BULK_READER_LIBCURL_ERROR";
    exports$1[4137] = "ER_BULK_READER_SERVER_ERROR";
    exports$1[4138] = "ER_BULK_READER_COMMUNICATION_ERROR";
    exports$1[4139] = "ER_BULK_LOAD_DATA_FAILED";
    exports$1[4140] = "ER_BULK_LOADER_COLUMN_TOO_BIG_FOR_LEFTOVER_BUFFER";
    exports$1[4141] = "ER_BULK_LOADER_COMPONENT_ERROR";
    exports$1[4142] = "ER_BULK_LOADER_FILE_CONTAINS_LESS_LINES_THAN_IGNORE_CLAUSE";
    exports$1[4143] = "ER_BULK_PARSER_MISSING_ENCLOSED_BY";
    exports$1[4144] = "ER_BULK_PARSER_ROW_BUFFER_MAX_TOTAL_COLS_EXCEEDED";
    exports$1[4145] = "ER_BULK_PARSER_COPY_BUFFER_SIZE_EXCEEDED";
    exports$1[4146] = "ER_BULK_PARSER_UNEXPECTED_END_OF_INPUT";
    exports$1[4147] = "ER_BULK_PARSER_UNEXPECTED_ROW_TERMINATOR";
    exports$1[4148] = "ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_ENDING_ENCLOSED_BY";
    exports$1[4149] = "ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_NULL_ESCAPE";
    exports$1[4150] = "ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_COLUMN_TERMINATOR";
    exports$1[4151] = "ER_BULK_PARSER_INCOMPLETE_ESCAPE_SEQUENCE";
    exports$1[4152] = "ER_LOAD_BULK_DATA_FAILED";
    exports$1[4153] = "ER_LOAD_BULK_DATA_WRONG_VALUE_FOR_FIELD";
    exports$1[4154] = "ER_LOAD_BULK_DATA_WARN_NULL_TO_NOTNULL";
    exports$1[4155] = "ER_REQUIRE_TABLE_PRIMARY_KEY_CHECK_GENERATE_WITH_GR";
    exports$1[4156] = "ER_CANT_CHANGE_SYS_VAR_IN_READ_ONLY_MODE";
    exports$1[4157] = "ER_INNODB_INSTANT_ADD_DROP_NOT_SUPPORTED_MAX_SIZE";
    exports$1[4158] = "ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_FIELDS";
    exports$1[4159] = "ER_CANT_SET_PERSISTED";
    exports$1[4160] = "ER_INSTALL_COMPONENT_SET_NULL_VALUE";
    exports$1[4161] = "ER_INSTALL_COMPONENT_SET_UNUSED_VALUE";
    exports$1[4162] = "ER_WARN_DEPRECATED_USER_DEFINED_COLLATIONS";
  })(errors);
  return errors;
}
var umd$1 = { exports: {} };
var umd = umd$1.exports;
var hasRequiredUmd;
function requireUmd() {
  if (hasRequiredUmd) return umd$1.exports;
  hasRequiredUmd = 1;
  (function(module, exports$1) {
    (function(global2, factory) {
      function preferDefault(exports$12) {
        return exports$12.default || exports$12;
      }
      {
        factory(exports$1);
        module.exports = preferDefault(exports$1);
      }
    })(
      typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : umd,
      function(_exports) {
        Object.defineProperty(_exports, "__esModule", {
          value: true
        });
        _exports.default = void 0;
        var wasm = null;
        try {
          wasm = new WebAssembly.Instance(
            new WebAssembly.Module(
              new Uint8Array([
                // \0asm
                0,
                97,
                115,
                109,
                // version 1
                1,
                0,
                0,
                0,
                // section "type"
                1,
                13,
                2,
                // 0, () => i32
                96,
                0,
                1,
                127,
                // 1, (i32, i32, i32, i32) => i32
                96,
                4,
                127,
                127,
                127,
                127,
                1,
                127,
                // section "function"
                3,
                7,
                6,
                // 0, type 0
                0,
                // 1, type 1
                1,
                // 2, type 1
                1,
                // 3, type 1
                1,
                // 4, type 1
                1,
                // 5, type 1
                1,
                // section "global"
                6,
                6,
                1,
                // 0, "high", mutable i32
                127,
                1,
                65,
                0,
                11,
                // section "export"
                7,
                50,
                6,
                // 0, "mul"
                3,
                109,
                117,
                108,
                0,
                1,
                // 1, "div_s"
                5,
                100,
                105,
                118,
                95,
                115,
                0,
                2,
                // 2, "div_u"
                5,
                100,
                105,
                118,
                95,
                117,
                0,
                3,
                // 3, "rem_s"
                5,
                114,
                101,
                109,
                95,
                115,
                0,
                4,
                // 4, "rem_u"
                5,
                114,
                101,
                109,
                95,
                117,
                0,
                5,
                // 5, "get_high"
                8,
                103,
                101,
                116,
                95,
                104,
                105,
                103,
                104,
                0,
                0,
                // section "code"
                10,
                191,
                1,
                6,
                // 0, "get_high"
                4,
                0,
                35,
                0,
                11,
                // 1, "mul"
                36,
                1,
                1,
                126,
                32,
                0,
                173,
                32,
                1,
                173,
                66,
                32,
                134,
                132,
                32,
                2,
                173,
                32,
                3,
                173,
                66,
                32,
                134,
                132,
                126,
                34,
                4,
                66,
                32,
                135,
                167,
                36,
                0,
                32,
                4,
                167,
                11,
                // 2, "div_s"
                36,
                1,
                1,
                126,
                32,
                0,
                173,
                32,
                1,
                173,
                66,
                32,
                134,
                132,
                32,
                2,
                173,
                32,
                3,
                173,
                66,
                32,
                134,
                132,
                127,
                34,
                4,
                66,
                32,
                135,
                167,
                36,
                0,
                32,
                4,
                167,
                11,
                // 3, "div_u"
                36,
                1,
                1,
                126,
                32,
                0,
                173,
                32,
                1,
                173,
                66,
                32,
                134,
                132,
                32,
                2,
                173,
                32,
                3,
                173,
                66,
                32,
                134,
                132,
                128,
                34,
                4,
                66,
                32,
                135,
                167,
                36,
                0,
                32,
                4,
                167,
                11,
                // 4, "rem_s"
                36,
                1,
                1,
                126,
                32,
                0,
                173,
                32,
                1,
                173,
                66,
                32,
                134,
                132,
                32,
                2,
                173,
                32,
                3,
                173,
                66,
                32,
                134,
                132,
                129,
                34,
                4,
                66,
                32,
                135,
                167,
                36,
                0,
                32,
                4,
                167,
                11,
                // 5, "rem_u"
                36,
                1,
                1,
                126,
                32,
                0,
                173,
                32,
                1,
                173,
                66,
                32,
                134,
                132,
                32,
                2,
                173,
                32,
                3,
                173,
                66,
                32,
                134,
                132,
                130,
                34,
                4,
                66,
                32,
                135,
                167,
                36,
                0,
                32,
                4,
                167,
                11
              ])
            ),
            {}
          ).exports;
        } catch {
        }
        function Long(low, high, unsigned) {
          this.low = low | 0;
          this.high = high | 0;
          this.unsigned = !!unsigned;
        }
        Long.prototype.__isLong__;
        Object.defineProperty(Long.prototype, "__isLong__", {
          value: true
        });
        function isLong(obj) {
          return (obj && obj["__isLong__"]) === true;
        }
        function ctz32(value) {
          var c = Math.clz32(value & -value);
          return value ? 31 - c : c;
        }
        Long.isLong = isLong;
        var INT_CACHE = {};
        var UINT_CACHE = {};
        function fromInt(value, unsigned) {
          var obj, cachedObj, cache;
          if (unsigned) {
            value >>>= 0;
            if (cache = 0 <= value && value < 256) {
              cachedObj = UINT_CACHE[value];
              if (cachedObj) return cachedObj;
            }
            obj = fromBits(value, 0, true);
            if (cache) UINT_CACHE[value] = obj;
            return obj;
          } else {
            value |= 0;
            if (cache = -128 <= value && value < 128) {
              cachedObj = INT_CACHE[value];
              if (cachedObj) return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache) INT_CACHE[value] = obj;
            return obj;
          }
        }
        Long.fromInt = fromInt;
        function fromNumber(value, unsigned) {
          if (isNaN(value)) return unsigned ? UZERO : ZERO;
          if (unsigned) {
            if (value < 0) return UZERO;
            if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
          } else {
            if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
          }
          if (value < 0) return fromNumber(-value, unsigned).neg();
          return fromBits(
            value % TWO_PWR_32_DBL | 0,
            value / TWO_PWR_32_DBL | 0,
            unsigned
          );
        }
        Long.fromNumber = fromNumber;
        function fromBits(lowBits, highBits, unsigned) {
          return new Long(lowBits, highBits, unsigned);
        }
        Long.fromBits = fromBits;
        var pow_dbl = Math.pow;
        function fromString(str2, unsigned, radix) {
          if (str2.length === 0) throw Error("empty string");
          if (typeof unsigned === "number") {
            radix = unsigned;
            unsigned = false;
          } else {
            unsigned = !!unsigned;
          }
          if (str2 === "NaN" || str2 === "Infinity" || str2 === "+Infinity" || str2 === "-Infinity")
            return unsigned ? UZERO : ZERO;
          radix = radix || 10;
          if (radix < 2 || 36 < radix) throw RangeError("radix");
          var p;
          if ((p = str2.indexOf("-")) > 0) throw Error("interior hyphen");
          else if (p === 0) {
            return fromString(str2.substring(1), unsigned, radix).neg();
          }
          var radixToPower = fromNumber(pow_dbl(radix, 8));
          var result = ZERO;
          for (var i = 0; i < str2.length; i += 8) {
            var size = Math.min(8, str2.length - i), value = parseInt(str2.substring(i, i + size), radix);
            if (size < 8) {
              var power = fromNumber(pow_dbl(radix, size));
              result = result.mul(power).add(fromNumber(value));
            } else {
              result = result.mul(radixToPower);
              result = result.add(fromNumber(value));
            }
          }
          result.unsigned = unsigned;
          return result;
        }
        Long.fromString = fromString;
        function fromValue(val, unsigned) {
          if (typeof val === "number") return fromNumber(val, unsigned);
          if (typeof val === "string") return fromString(val, unsigned);
          return fromBits(
            val.low,
            val.high,
            typeof unsigned === "boolean" ? unsigned : val.unsigned
          );
        }
        Long.fromValue = fromValue;
        var TWO_PWR_16_DBL = 1 << 16;
        var TWO_PWR_24_DBL = 1 << 24;
        var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
        var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
        var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
        var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
        var ZERO = fromInt(0);
        Long.ZERO = ZERO;
        var UZERO = fromInt(0, true);
        Long.UZERO = UZERO;
        var ONE = fromInt(1);
        Long.ONE = ONE;
        var UONE = fromInt(1, true);
        Long.UONE = UONE;
        var NEG_ONE = fromInt(-1);
        Long.NEG_ONE = NEG_ONE;
        var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
        Long.MAX_VALUE = MAX_VALUE;
        var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
        Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
        var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
        Long.MIN_VALUE = MIN_VALUE;
        var LongPrototype = Long.prototype;
        LongPrototype.toInt = function toInt() {
          return this.unsigned ? this.low >>> 0 : this.low;
        };
        LongPrototype.toNumber = function toNumber() {
          if (this.unsigned)
            return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
          return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
        };
        LongPrototype.toString = function toString(radix) {
          radix = radix || 10;
          if (radix < 2 || 36 < radix) throw RangeError("radix");
          if (this.isZero()) return "0";
          if (this.isNegative()) {
            if (this.eq(MIN_VALUE)) {
              var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
              return div.toString(radix) + rem1.toInt().toString(radix);
            } else return "-" + this.neg().toString(radix);
          }
          var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
          var result = "";
          while (true) {
            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero()) return digits + result;
            else {
              while (digits.length < 6) digits = "0" + digits;
              result = "" + digits + result;
            }
          }
        };
        LongPrototype.getHighBits = function getHighBits() {
          return this.high;
        };
        LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
          return this.high >>> 0;
        };
        LongPrototype.getLowBits = function getLowBits() {
          return this.low;
        };
        LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
          return this.low >>> 0;
        };
        LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
          if (this.isNegative())
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
          var val = this.high != 0 ? this.high : this.low;
          for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
          return this.high != 0 ? bit + 33 : bit + 1;
        };
        LongPrototype.isSafeInteger = function isSafeInteger() {
          var top11Bits = this.high >> 21;
          if (!top11Bits) return true;
          if (this.unsigned) return false;
          return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
        };
        LongPrototype.isZero = function isZero() {
          return this.high === 0 && this.low === 0;
        };
        LongPrototype.eqz = LongPrototype.isZero;
        LongPrototype.isNegative = function isNegative() {
          return !this.unsigned && this.high < 0;
        };
        LongPrototype.isPositive = function isPositive() {
          return this.unsigned || this.high >= 0;
        };
        LongPrototype.isOdd = function isOdd() {
          return (this.low & 1) === 1;
        };
        LongPrototype.isEven = function isEven() {
          return (this.low & 1) === 0;
        };
        LongPrototype.equals = function equals(other) {
          if (!isLong(other)) other = fromValue(other);
          if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
            return false;
          return this.high === other.high && this.low === other.low;
        };
        LongPrototype.eq = LongPrototype.equals;
        LongPrototype.notEquals = function notEquals(other) {
          return !this.eq(
            /* validates */
            other
          );
        };
        LongPrototype.neq = LongPrototype.notEquals;
        LongPrototype.ne = LongPrototype.notEquals;
        LongPrototype.lessThan = function lessThan(other) {
          return this.comp(
            /* validates */
            other
          ) < 0;
        };
        LongPrototype.lt = LongPrototype.lessThan;
        LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
          return this.comp(
            /* validates */
            other
          ) <= 0;
        };
        LongPrototype.lte = LongPrototype.lessThanOrEqual;
        LongPrototype.le = LongPrototype.lessThanOrEqual;
        LongPrototype.greaterThan = function greaterThan(other) {
          return this.comp(
            /* validates */
            other
          ) > 0;
        };
        LongPrototype.gt = LongPrototype.greaterThan;
        LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
          return this.comp(
            /* validates */
            other
          ) >= 0;
        };
        LongPrototype.gte = LongPrototype.greaterThanOrEqual;
        LongPrototype.ge = LongPrototype.greaterThanOrEqual;
        LongPrototype.compare = function compare(other) {
          if (!isLong(other)) other = fromValue(other);
          if (this.eq(other)) return 0;
          var thisNeg = this.isNegative(), otherNeg = other.isNegative();
          if (thisNeg && !otherNeg) return -1;
          if (!thisNeg && otherNeg) return 1;
          if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
          return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
        };
        LongPrototype.comp = LongPrototype.compare;
        LongPrototype.negate = function negate() {
          if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
          return this.not().add(ONE);
        };
        LongPrototype.neg = LongPrototype.negate;
        LongPrototype.add = function add(addend) {
          if (!isLong(addend)) addend = fromValue(addend);
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a16 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = addend.high >>> 16;
          var b32 = addend.high & 65535;
          var b16 = addend.low >>> 16;
          var b00 = addend.low & 65535;
          var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 + b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 + b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 + b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 + b48;
          c48 &= 65535;
          return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        LongPrototype.subtract = function subtract(subtrahend) {
          if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
          return this.add(subtrahend.neg());
        };
        LongPrototype.sub = LongPrototype.subtract;
        LongPrototype.multiply = function multiply(multiplier) {
          if (this.isZero()) return this;
          if (!isLong(multiplier)) multiplier = fromValue(multiplier);
          if (wasm) {
            var low = wasm["mul"](
              this.low,
              this.high,
              multiplier.low,
              multiplier.high
            );
            return fromBits(low, wasm["get_high"](), this.unsigned);
          }
          if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
          if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
          if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
          if (this.isNegative()) {
            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
            else return this.neg().mul(multiplier).neg();
          } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();
          if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
            return fromNumber(
              this.toNumber() * multiplier.toNumber(),
              this.unsigned
            );
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a16 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = multiplier.high >>> 16;
          var b32 = multiplier.high & 65535;
          var b16 = multiplier.low >>> 16;
          var b00 = multiplier.low & 65535;
          var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 * b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 * b00;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c16 += a00 * b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 * b00;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a16 * b16;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a00 * b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
          c48 &= 65535;
          return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        LongPrototype.mul = LongPrototype.multiply;
        LongPrototype.divide = function divide(divisor) {
          if (!isLong(divisor)) divisor = fromValue(divisor);
          if (divisor.isZero()) throw Error("division by zero");
          if (wasm) {
            if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
              return this;
            }
            var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
              this.low,
              this.high,
              divisor.low,
              divisor.high
            );
            return fromBits(low, wasm["get_high"](), this.unsigned);
          }
          if (this.isZero()) return this.unsigned ? UZERO : ZERO;
          var approx, rem, res;
          if (!this.unsigned) {
            if (this.eq(MIN_VALUE)) {
              if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;
              else if (divisor.eq(MIN_VALUE)) return ONE;
              else {
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                  return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                  rem = this.sub(divisor.mul(approx));
                  res = approx.add(rem.div(divisor));
                  return res;
                }
              }
            } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
              if (divisor.isNegative()) return this.neg().div(divisor.neg());
              return this.neg().div(divisor).neg();
            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
            res = ZERO;
          } else {
            if (!divisor.unsigned) divisor = divisor.toUnsigned();
            if (divisor.gt(this)) return UZERO;
            if (divisor.gt(this.shru(1)))
              return UONE;
            res = UZERO;
          }
          rem = this;
          while (rem.gte(divisor)) {
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
            var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
              approx -= delta;
              approxRes = fromNumber(approx, this.unsigned);
              approxRem = approxRes.mul(divisor);
            }
            if (approxRes.isZero()) approxRes = ONE;
            res = res.add(approxRes);
            rem = rem.sub(approxRem);
          }
          return res;
        };
        LongPrototype.div = LongPrototype.divide;
        LongPrototype.modulo = function modulo(divisor) {
          if (!isLong(divisor)) divisor = fromValue(divisor);
          if (wasm) {
            var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
              this.low,
              this.high,
              divisor.low,
              divisor.high
            );
            return fromBits(low, wasm["get_high"](), this.unsigned);
          }
          return this.sub(this.div(divisor).mul(divisor));
        };
        LongPrototype.mod = LongPrototype.modulo;
        LongPrototype.rem = LongPrototype.modulo;
        LongPrototype.not = function not() {
          return fromBits(~this.low, ~this.high, this.unsigned);
        };
        LongPrototype.countLeadingZeros = function countLeadingZeros() {
          return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
        };
        LongPrototype.clz = LongPrototype.countLeadingZeros;
        LongPrototype.countTrailingZeros = function countTrailingZeros() {
          return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
        };
        LongPrototype.ctz = LongPrototype.countTrailingZeros;
        LongPrototype.and = function and(other) {
          if (!isLong(other)) other = fromValue(other);
          return fromBits(
            this.low & other.low,
            this.high & other.high,
            this.unsigned
          );
        };
        LongPrototype.or = function or(other) {
          if (!isLong(other)) other = fromValue(other);
          return fromBits(
            this.low | other.low,
            this.high | other.high,
            this.unsigned
          );
        };
        LongPrototype.xor = function xor(other) {
          if (!isLong(other)) other = fromValue(other);
          return fromBits(
            this.low ^ other.low,
            this.high ^ other.high,
            this.unsigned
          );
        };
        LongPrototype.shiftLeft = function shiftLeft(numBits) {
          if (isLong(numBits)) numBits = numBits.toInt();
          if ((numBits &= 63) === 0) return this;
          else if (numBits < 32)
            return fromBits(
              this.low << numBits,
              this.high << numBits | this.low >>> 32 - numBits,
              this.unsigned
            );
          else return fromBits(0, this.low << numBits - 32, this.unsigned);
        };
        LongPrototype.shl = LongPrototype.shiftLeft;
        LongPrototype.shiftRight = function shiftRight(numBits) {
          if (isLong(numBits)) numBits = numBits.toInt();
          if ((numBits &= 63) === 0) return this;
          else if (numBits < 32)
            return fromBits(
              this.low >>> numBits | this.high << 32 - numBits,
              this.high >> numBits,
              this.unsigned
            );
          else
            return fromBits(
              this.high >> numBits - 32,
              this.high >= 0 ? 0 : -1,
              this.unsigned
            );
        };
        LongPrototype.shr = LongPrototype.shiftRight;
        LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
          if (isLong(numBits)) numBits = numBits.toInt();
          if ((numBits &= 63) === 0) return this;
          if (numBits < 32)
            return fromBits(
              this.low >>> numBits | this.high << 32 - numBits,
              this.high >>> numBits,
              this.unsigned
            );
          if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
          return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
        };
        LongPrototype.shru = LongPrototype.shiftRightUnsigned;
        LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
        LongPrototype.rotateLeft = function rotateLeft(numBits) {
          var b;
          if (isLong(numBits)) numBits = numBits.toInt();
          if ((numBits &= 63) === 0) return this;
          if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
          if (numBits < 32) {
            b = 32 - numBits;
            return fromBits(
              this.low << numBits | this.high >>> b,
              this.high << numBits | this.low >>> b,
              this.unsigned
            );
          }
          numBits -= 32;
          b = 32 - numBits;
          return fromBits(
            this.high << numBits | this.low >>> b,
            this.low << numBits | this.high >>> b,
            this.unsigned
          );
        };
        LongPrototype.rotl = LongPrototype.rotateLeft;
        LongPrototype.rotateRight = function rotateRight(numBits) {
          var b;
          if (isLong(numBits)) numBits = numBits.toInt();
          if ((numBits &= 63) === 0) return this;
          if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
          if (numBits < 32) {
            b = 32 - numBits;
            return fromBits(
              this.high << b | this.low >>> numBits,
              this.low << b | this.high >>> numBits,
              this.unsigned
            );
          }
          numBits -= 32;
          b = 32 - numBits;
          return fromBits(
            this.low << b | this.high >>> numBits,
            this.high << b | this.low >>> numBits,
            this.unsigned
          );
        };
        LongPrototype.rotr = LongPrototype.rotateRight;
        LongPrototype.toSigned = function toSigned() {
          if (!this.unsigned) return this;
          return fromBits(this.low, this.high, false);
        };
        LongPrototype.toUnsigned = function toUnsigned() {
          if (this.unsigned) return this;
          return fromBits(this.low, this.high, true);
        };
        LongPrototype.toBytes = function toBytes(le) {
          return le ? this.toBytesLE() : this.toBytesBE();
        };
        LongPrototype.toBytesLE = function toBytesLE() {
          var hi = this.high, lo = this.low;
          return [
            lo & 255,
            lo >>> 8 & 255,
            lo >>> 16 & 255,
            lo >>> 24,
            hi & 255,
            hi >>> 8 & 255,
            hi >>> 16 & 255,
            hi >>> 24
          ];
        };
        LongPrototype.toBytesBE = function toBytesBE() {
          var hi = this.high, lo = this.low;
          return [
            hi >>> 24,
            hi >>> 16 & 255,
            hi >>> 8 & 255,
            hi & 255,
            lo >>> 24,
            lo >>> 16 & 255,
            lo >>> 8 & 255,
            lo & 255
          ];
        };
        Long.fromBytes = function fromBytes(bytes, unsigned, le) {
          return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
        };
        Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
          return new Long(
            bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
            bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
            unsigned
          );
        };
        Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
          return new Long(
            bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
            bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
            unsigned
          );
        };
        if (typeof BigInt === "function") {
          Long.fromBigInt = function fromBigInt(value, unsigned) {
            var lowBits = Number(BigInt.asIntN(32, value));
            var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
            return fromBits(lowBits, highBits, unsigned);
          };
          Long.fromValue = function fromValueWithBigInt(value, unsigned) {
            if (typeof value === "bigint") return Long.fromBigInt(value, unsigned);
            return fromValue(value, unsigned);
          };
          LongPrototype.toBigInt = function toBigInt() {
            var lowBigInt = BigInt(this.low >>> 0);
            var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
            return highBigInt << BigInt(32) | lowBigInt;
          };
        }
        _exports.default = Long;
      }
    );
  })(umd$1, umd$1.exports);
  return umd$1.exports;
}
var string = {};
var lib$2 = { exports: {} };
var safer_1;
var hasRequiredSafer;
function requireSafer() {
  if (hasRequiredSafer) return safer_1;
  hasRequiredSafer = 1;
  var buffer = require$$0$5;
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key)) continue;
    if (key === "SlowBuffer" || key === "Buffer") continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key)) continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  safer_1 = safer;
  return safer_1;
}
var bomHandling = {};
var hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling) return bomHandling;
  hasRequiredBomHandling = 1;
  var BOMChar = "\uFEFF";
  bomHandling.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str2) {
    if (this.addBOM) {
      str2 = BOMChar + str2;
      this.addBOM = false;
    }
    return this.encoder.write(str2);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  bomHandling.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res) {
      return res;
    }
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function") {
        this.options.stripBOM();
      }
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
  return bomHandling;
}
var mergeExports;
var hasRequiredMergeExports;
function requireMergeExports() {
  if (hasRequiredMergeExports) return mergeExports;
  hasRequiredMergeExports = 1;
  var hasOwn = typeof Object.hasOwn === "undefined" ? Function.call.bind(Object.prototype.hasOwnProperty) : Object.hasOwn;
  function mergeModules(target, module) {
    for (var key in module) {
      if (hasOwn(module, key)) {
        target[key] = module[key];
      }
    }
  }
  mergeExports = mergeModules;
  return mergeExports;
}
var encodings = {};
var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  var Buffer2 = requireSafer().Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64") {
      this.encoder = InternalEncoderBase64;
    } else if (this.enc === "utf8") {
      this.encoder = InternalEncoderUtf8;
    } else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require$$1$7.StringDecoder;
  function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
  }
  InternalDecoder.prototype.write = function(buf) {
    if (!Buffer2.isBuffer(buf)) {
      buf = Buffer2.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function() {
    return this.decoder.end();
  };
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str2) {
    return Buffer2.from(str2, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str2) {
    str2 = this.prevStr + str2;
    var completeQuads = str2.length - str2.length % 4;
    this.prevStr = str2.slice(completeQuads);
    str2 = str2.slice(0, completeQuads);
    return Buffer2.from(str2, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str2) {
    var buf = Buffer2.alloc(str2.length * 3);
    var bufIdx = 0;
    for (var i = 0; i < str2.length; i++) {
      var charCode = str2.charCodeAt(i);
      if (charCode < 128) {
        buf[bufIdx++] = charCode;
      } else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc;
    var contBytes = this.contBytes;
    var accBytes = this.accBytes;
    var res = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0) {
              res += this.defaultCharUnicode;
            } else if (accBytes === 3 && acc < 2048) {
              res += this.defaultCharUnicode;
            } else {
              res += String.fromCharCode(acc);
            }
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0) {
      res += this.defaultCharUnicode;
    }
    return res;
  };
  function InternalEncoderUtf8(options, codec) {
    this.highSurrogate = "";
  }
  InternalEncoderUtf8.prototype.write = function(str2) {
    if (this.highSurrogate) {
      str2 = this.highSurrogate + str2;
      this.highSurrogate = "";
    }
    if (str2.length > 0) {
      var charCode = str2.charCodeAt(str2.length - 1);
      if (charCode >= 55296 && charCode < 56320) {
        this.highSurrogate = str2[str2.length - 1];
        str2 = str2.slice(0, str2.length - 1);
      }
    }
    return Buffer2.from(str2, this.enc);
  };
  InternalEncoderUtf8.prototype.end = function() {
    if (this.highSurrogate) {
      var str2 = this.highSurrogate;
      this.highSurrogate = "";
      return Buffer2.from(str2, this.enc);
    }
  };
  return internal;
}
var utf32 = {};
var hasRequiredUtf32;
function requireUtf32() {
  if (hasRequiredUtf32) return utf32;
  hasRequiredUtf32 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf32._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  utf32.utf32le = { type: "_utf32", isLE: true };
  utf32.utf32be = { type: "_utf32", isLE: false };
  utf32.ucs4le = "utf32le";
  utf32.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str2) {
    var src2 = Buffer2.from(str2, "ucs2");
    var dst = Buffer2.alloc(src2.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i = 0; i < src2.length; i += 2) {
      var code = src2.readUInt16LE(i);
      var isHighSurrogate = code >= 55296 && code < 56320;
      var isLowSurrogate = code >= 56320 && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate) {
        this.highSurrogate = code;
      } else {
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length) {
      dst = dst.slice(0, offset);
    }
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate) {
      return;
    }
    var buf = Buffer2.alloc(4);
    if (this.isLE) {
      buf.writeUInt32LE(this.highSurrogate, 0);
    } else {
      buf.writeUInt32BE(this.highSurrogate, 0);
    }
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function(src2) {
    if (src2.length === 0) {
      return "";
    }
    var i = 0;
    var codepoint = 0;
    var dst = Buffer2.alloc(src2.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
      for (; i < src2.length && overflow.length < 4; i++) {
        overflow.push(src2[i]);
      }
      if (overflow.length === 4) {
        if (isLE) {
          codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
        } else {
          codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
        }
        overflow.length = 0;
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
    }
    for (; i < src2.length - 3; i += 4) {
      if (isLE) {
        codepoint = src2[i] | src2[i + 1] << 8 | src2[i + 2] << 16 | src2[i + 3] << 24;
      } else {
        codepoint = src2[i + 3] | src2[i + 2] << 8 | src2[i + 1] << 16 | src2[i] << 24;
      }
      offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }
    for (; i < src2.length; i++) {
      overflow.push(src2[i]);
    }
    return dst.slice(0, offset).toString("ucs2");
  };
  function _writeCodepoint(dst, offset, codepoint, badChar) {
    if (codepoint < 0 || codepoint > 1114111) {
      codepoint = badChar;
    }
    if (codepoint >= 65536) {
      codepoint -= 65536;
      var high = 55296 | codepoint >> 10;
      dst[offset++] = high & 255;
      dst[offset++] = high >> 8;
      var codepoint = 56320 | codepoint & 1023;
    }
    dst[offset++] = codepoint & 255;
    dst[offset++] = codepoint >> 8;
    return offset;
  }
  Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
  };
  utf32.utf32 = Utf32AutoCodec;
  utf32.ucs4 = "utf32";
  function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0) {
      options.addBOM = true;
    }
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
  }
  Utf32AutoEncoder.prototype.write = function(str2) {
    return this.encoder.write(str2);
  };
  Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32) {
        return "";
      }
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++) {
        resStr += this.decoder.write(this.initialBufs[i]);
      }
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++) {
        resStr += this.decoder.write(this.initialBufs[i]);
      }
      var trail = this.decoder.end();
      if (trail) {
        resStr += trail;
      }
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0;
    var invalidBE = 0;
    var bmpCharsLE = 0;
    var bmpCharsBE = 0;
    outerLoop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 4) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                return "utf-32le";
              }
              if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                return "utf-32be";
              }
            }
            if (b[0] !== 0 || b[1] > 16) invalidBE++;
            if (b[3] !== 0 || b[2] > 16) invalidLE++;
            if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
            if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outerLoop;
            }
          }
        }
      }
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
    return defaultEncoding || "utf-32le";
  }
  return utf32;
}
var utf16 = {};
var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16) return utf16;
  hasRequiredUtf16 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str2) {
    var buf = Buffer2.from(str2, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0) {
      return "";
    }
    var buf2 = Buffer2.alloc(buf.length + 1);
    var i = 0;
    var j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
  };
  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0) {
      options.addBOM = true;
    }
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str2) {
    return this.encoder.write(str2);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16) {
        return "";
      }
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++) {
        resStr += this.decoder.write(this.initialBufs[i]);
      }
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++) {
        resStr += this.decoder.write(this.initialBufs[i]);
      }
      var trail = this.decoder.end();
      if (trail) {
        resStr += trail;
      }
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0;
    var asciiCharsBE = 0;
    outerLoop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 2) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254) return "utf-16le";
              if (b[0] === 254 && b[1] === 255) return "utf-16be";
            }
            if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
            if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outerLoop;
            }
          }
        }
      }
    if (asciiCharsBE > asciiCharsLE) return "utf-16be";
    if (asciiCharsBE < asciiCharsLE) return "utf-16le";
    return defaultEncoding || "utf-16le";
  }
  return utf16;
}
var utf7 = {};
var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7) return utf7;
  hasRequiredUtf7 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str2) {
    return Buffer2.from(str2.replace(nonDirectChars, (function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }).bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++) {
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  }
  var plusChar = "+".charCodeAt(0);
  var minusChar = "-".charCodeAt(0);
  var andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res = "";
    var lastI = 0;
    var inBase64 = this.inBase64;
    var base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar) {
            i2--;
          }
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) {
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    }
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str2) {
    var inBase64 = this.inBase64;
    var base64Accum = this.base64Accum;
    var base64AccumIdx = this.base64AccumIdx;
    var buf = Buffer2.alloc(str2.length * 5 + 10);
    var bufIdx = 0;
    for (var i2 = 0; i2 < str2.length; i2++) {
      var uChar = str2.charCodeAt(i2);
      if (uChar >= 32 && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar) {
            buf[bufIdx++] = minusChar;
          }
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10);
    var bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "";
    var lastI = 0;
    var inBase64 = this.inBase64;
    var base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar) {
            i2--;
          }
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) {
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    }
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  return utf7;
}
var sbcsCodec = {};
var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec) return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions) {
      throw new Error("SBCS codec is called without the data.");
    }
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) {
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    }
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++) {
        asciiString += String.fromCharCode(i);
      }
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++) {
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    }
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str2) {
    var buf = Buffer2.alloc(str2.length);
    for (var i = 0; i < str2.length; i++) {
      buf[i] = this.encodeBuf[str2.charCodeAt(i)];
    }
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0;
    var idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec;
}
var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData) return sbcsData;
  hasRequiredSbcsData = 1;
  sbcsData = {
    // Not supported by iconv, not sure why.
    10029: "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: ""
    },
    808: "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: ""
    },
    mik: {
      type: "_sbcs",
      chars: ""
    },
    cp720: {
      type: "_sbcs",
      chars: ""
    },
    // Aliases of generated encodings.
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    1e4: "macroman",
    10006: "macgreek",
    10007: "maccyrillic",
    10079: "maciceland",
    10081: "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    20866: "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    21866: "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  };
  return sbcsData;
}
var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "\uFEFF"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return sbcsDataGenerated;
}
var dbcsCodec = {};
var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec) return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1;
  var GB18030_CODE = -2;
  var SEQ_START = -10;
  var NODE_START = -1e3;
  var UNASSIGNED_NODE = new Array(256);
  var DEF_CHAR = -1;
  for (var i = 0; i < 256; i++) {
    UNASSIGNED_NODE[i] = UNASSIGNED;
  }
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions) {
      throw new Error("DBCS codec is called without the data.");
    }
    if (!codecOptions.table) {
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    }
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++) {
      this._addDecodeChunk(mappingTable[i2]);
    }
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var firstByteNode = this.decodeTables[0];
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
        for (var j = 48; j <= 57; j++) {
          if (secondByteNode[j] === UNASSIGNED) {
            secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
          for (var k = 129; k <= 254; k++) {
            if (thirdByteNode[k] === UNASSIGNED) {
              thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
            for (var l = 48; l <= 57; l++) {
              if (fourthByteNode[l] === UNASSIGNED) {
                fourthByteNode[l] = GB18030_CODE;
              }
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals) {
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number") {
          skipEncodeChars[val] = true;
        } else {
          for (var j = val.from; j <= val.to; j++) {
            skipEncodeChars[j] = true;
          }
        }
      }
    }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd) {
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) {
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
        }
      }
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>>= 8) {
      bytes.push(addr & 255);
    }
    if (bytes.length == 0) {
      bytes.push(0);
    }
    var node2 = this.decodeTables[0];
    for (var i2 = bytes.length - 1; i2 > 0; i2--) {
      var val = node2[bytes[i2]];
      if (val == UNASSIGNED) {
        node2[bytes[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node2 = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node2 = this.decodeTables[NODE_START - val];
      } else {
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
      }
    }
    return node2;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (code >= 55296 && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (codeTrail >= 56320 && codeTrail < 57344) {
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            } else {
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
            }
          } else if (code > 4080 && code <= 4095) {
            var len = 4095 - code + 2;
            var seq2 = [];
            for (var m = 0; m < len; m++) {
              seq2.push(part.charCodeAt(l++));
            }
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq2);
          } else {
            writeTable[curAddr++] = code;
          }
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++) {
          writeTable[curAddr++] = charCode++;
        }
      } else {
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
      }
    }
    if (curAddr > 255) {
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    }
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0) {
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    }
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START) {
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    } else if (bucket[low] == UNASSIGNED) {
      bucket[low] = dbcsCode;
    }
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq2, dbcsCode) {
    var uCode = seq2[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node2;
    if (bucket[low] <= SEQ_START) {
      node2 = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node2 = {};
      if (bucket[low] !== UNASSIGNED) node2[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node2);
    }
    for (var j = 1; j < seq2.length - 1; j++) {
      var oldVal = node2[uCode];
      if (typeof oldVal === "object") {
        node2 = oldVal;
      } else {
        node2 = node2[uCode] = {};
        if (oldVal !== void 0) {
          node2[DEF_CHAR] = oldVal;
        }
      }
    }
    uCode = seq2[seq2.length - 1];
    node2[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node2 = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node2[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode]) {
        continue;
      }
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          var newPrefix = mbCode << 8 >>> 0;
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) {
            hasValues = true;
          } else {
            subNodeEmpty[subNodeIdx] = true;
          }
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str2) {
    var newBuf = Buffer2.alloc(str2.length * (this.gb18030 ? 4 : 3));
    var leadSurrogate = this.leadSurrogate;
    var seqObj = this.seqObj;
    var nextChar = -1;
    var i2 = 0;
    var j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str2.length) break;
        var uCode = str2.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (uCode >= 55296 && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode === "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0) {
          dbcsCode = subtable[uCode & 255];
        }
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED) {
        dbcsCode = this.defaultCharSingleByte;
      }
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else if (dbcsCode < 16777216) {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >>> 24;
        newBuf[j++] = dbcsCode >>> 16 & 255;
        newBuf[j++] = dbcsCode >>> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0) {
      return;
    }
    var newBuf = Buffer2.alloc(10);
    var j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBytes = [];
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2);
    var nodeIdx = this.nodeIdx;
    var prevBytes = this.prevBytes;
    var prevOffset = this.prevBytes.length;
    var seqStart = -this.prevBytes.length;
    var uCode;
    for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ;
      else if (uCode === UNASSIGNED) {
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i2 = seqStart;
      } else if (uCode === GB18030_CODE) {
        if (i2 >= 3) {
          var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
        } else {
          var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq2 = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq2.length - 1; k++) {
          uCode = seq2[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq2[seq2.length - 1];
      } else {
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      }
      if (uCode >= 65536) {
        uCode -= 65536;
        var uCodeLead = 55296 | uCode >> 10;
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 | uCode & 1023;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBytes.length > 0) {
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0) {
        ret += this.write(bytesArr);
      }
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val) {
      return -1;
    }
    var l = 0;
    var r = table.length;
    while (l < r - 1) {
      var mid = l + (r - l + 1 >> 1);
      if (table[mid] <= val) {
        l = mid;
      } else {
        r = mid;
      }
    }
    return l;
  }
  return dbcsCodec;
}
const require$$0 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "",
    62
  ],
  [
    "8140",
    "",
    9,
    ""
  ],
  [
    "8180",
    ""
  ],
  [
    "81b8",
    ""
  ],
  [
    "81c8",
    ""
  ],
  [
    "81da",
    ""
  ],
  [
    "81f0",
    ""
  ],
  [
    "81fc",
    ""
  ],
  [
    "824f",
    "",
    9
  ],
  [
    "8260",
    "",
    25
  ],
  [
    "8281",
    "",
    25
  ],
  [
    "829f",
    "",
    82
  ],
  [
    "8340",
    "",
    62
  ],
  [
    "8380",
    "",
    22
  ],
  [
    "839f",
    "",
    16,
    "",
    6
  ],
  [
    "83bf",
    "",
    16,
    "",
    6
  ],
  [
    "8440",
    "",
    5,
    "",
    25
  ],
  [
    "8470",
    "",
    5,
    "",
    7
  ],
  [
    "8480",
    "",
    17
  ],
  [
    "849f",
    ""
  ],
  [
    "8740",
    "",
    19,
    "",
    9
  ],
  [
    "875f",
    ""
  ],
  [
    "877e",
    ""
  ],
  [
    "8780",
    "",
    4,
    ""
  ],
  [
    "889f",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8980",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a80",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b80",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8c80",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d80",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8e80",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8f80",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "9080",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "9180",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "9280",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "9380",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "9480",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "9580",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "9680",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "9780",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "989f",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "9980",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9a80",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b80",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9c80",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9d80",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9e80",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f80",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e080",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e180",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e280",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e380",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e480",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e580",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e680",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e780",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e880",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e980",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "ea80",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "ed80",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "ee80",
    ""
  ],
  [
    "eeef",
    "",
    9,
    ""
  ],
  [
    "f040",
    "",
    62
  ],
  [
    "f080",
    "",
    124
  ],
  [
    "f140",
    "",
    62
  ],
  [
    "f180",
    "",
    124
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    124
  ],
  [
    "f340",
    "",
    62
  ],
  [
    "f380",
    "",
    124
  ],
  [
    "f440",
    "",
    62
  ],
  [
    "f480",
    "",
    124
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    124
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    124
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    124
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    124
  ],
  [
    "f940",
    ""
  ],
  [
    "fa40",
    "",
    9,
    "",
    9,
    ""
  ],
  [
    "fa80",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fb80",
    ""
  ],
  [
    "fc40",
    ""
  ]
];
const require$$1 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]');
const require$$2 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]');
const require$$3$1 = [
  [
    "a140",
    "",
    62
  ],
  [
    "a180",
    "",
    32
  ],
  [
    "a240",
    "",
    62
  ],
  [
    "a280",
    "",
    32
  ],
  [
    "a2ab",
    "",
    5
  ],
  [
    "a2e3",
    ""
  ],
  [
    "a2ef",
    ""
  ],
  [
    "a2fd",
    ""
  ],
  [
    "a340",
    "",
    62
  ],
  [
    "a380",
    "",
    31,
    ""
  ],
  [
    "a440",
    "",
    62
  ],
  [
    "a480",
    "",
    32
  ],
  [
    "a4f4",
    "",
    10
  ],
  [
    "a540",
    "",
    62
  ],
  [
    "a580",
    "",
    32
  ],
  [
    "a5f7",
    "",
    7
  ],
  [
    "a640",
    "",
    62
  ],
  [
    "a680",
    "",
    32
  ],
  [
    "a6b9",
    "",
    7
  ],
  [
    "a6d9",
    "",
    6
  ],
  [
    "a6ec",
    ""
  ],
  [
    "a6f3",
    ""
  ],
  [
    "a6f6",
    "",
    8
  ],
  [
    "a740",
    "",
    62
  ],
  [
    "a780",
    "",
    32
  ],
  [
    "a7c2",
    "",
    14
  ],
  [
    "a7f2",
    "",
    12
  ],
  [
    "a896",
    "",
    10
  ],
  [
    "a8bc",
    ""
  ],
  [
    "a8bf",
    ""
  ],
  [
    "a8c1",
    ""
  ],
  [
    "a8ea",
    "",
    20
  ],
  [
    "a958",
    ""
  ],
  [
    "a95b",
    ""
  ],
  [
    "a95d",
    ""
  ],
  [
    "a989",
    "",
    11
  ],
  [
    "a997",
    "",
    12
  ],
  [
    "a9f0",
    "",
    14
  ],
  [
    "aaa1",
    "",
    93
  ],
  [
    "aba1",
    "",
    93
  ],
  [
    "aca1",
    "",
    93
  ],
  [
    "ada1",
    "",
    93
  ],
  [
    "aea1",
    "",
    93
  ],
  [
    "afa1",
    "",
    93
  ],
  [
    "d7fa",
    "",
    4
  ],
  [
    "f8a1",
    "",
    93
  ],
  [
    "f9a1",
    "",
    93
  ],
  [
    "faa1",
    "",
    93
  ],
  [
    "fba1",
    "",
    93
  ],
  [
    "fca1",
    "",
    93
  ],
  [
    "fda1",
    "",
    93
  ],
  [
    "fe50",
    ""
  ],
  [
    "fe80",
    "",
    6,
    "",
    93
  ],
  [
    "8135f437",
    ""
  ]
];
const uChars = [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536];
const gbChars = [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3];
const require$$4 = {
  uChars,
  gbChars
};
const require$$5 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]');
const require$$6 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]');
const require$$7 = [
  [
    "8740",
    ""
  ],
  [
    "8767",
    ""
  ],
  [
    "87a1",
    ""
  ],
  [
    "8840",
    "",
    4,
    ""
  ],
  [
    "88a1",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8943",
    ""
  ],
  [
    "8946",
    ""
  ],
  [
    "894c",
    ""
  ],
  [
    "89a1",
    ""
  ],
  [
    "89ab",
    ""
  ],
  [
    "89b0",
    ""
  ],
  [
    "89b5",
    ""
  ],
  [
    "89c1",
    ""
  ],
  [
    "89c5",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a43",
    ""
  ],
  [
    "8a64",
    ""
  ],
  [
    "8a76",
    ""
  ],
  [
    "8aa1",
    ""
  ],
  [
    "8aac",
    ""
  ],
  [
    "8ab2",
    ""
  ],
  [
    "8abb",
    ""
  ],
  [
    "8ac9",
    ""
  ],
  [
    "8ace",
    ""
  ],
  [
    "8adf",
    ""
  ],
  [
    "8af6",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b55",
    ""
  ],
  [
    "8ba1",
    ""
  ],
  [
    "8bde",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8ca1",
    ""
  ],
  [
    "8ca7",
    ""
  ],
  [
    "8cc9",
    ""
  ],
  [
    "8cce",
    ""
  ],
  [
    "8ce6",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d42",
    ""
  ],
  [
    "8da1",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8ea1",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8fa1",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "90a1",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "91a1",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "92a1",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "93a1",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "94a1",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "95a1",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "96a1",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "97a1",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "98a1",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "99a1",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9aa1",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b62",
    ""
  ],
  [
    "9ba1",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9ca1",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9da1",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9ea1",
    ""
  ],
  [
    "9ead",
    ""
  ],
  [
    "9ec5",
    ""
  ],
  [
    "9ef5",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f4f",
    ""
  ],
  [
    "9fa1",
    ""
  ],
  [
    "9fae",
    ""
  ],
  [
    "9fb2",
    ""
  ],
  [
    "9fc1",
    ""
  ],
  [
    "9fc9",
    ""
  ],
  [
    "9fdb",
    ""
  ],
  [
    "9fe7",
    ""
  ],
  [
    "9feb",
    ""
  ],
  [
    "9ff0",
    ""
  ],
  [
    "a040",
    ""
  ],
  [
    "a055",
    ""
  ],
  [
    "a058",
    ""
  ],
  [
    "a05b",
    ""
  ],
  [
    "a063",
    ""
  ],
  [
    "a073",
    ""
  ],
  [
    "a0a1",
    ""
  ],
  [
    "a0a6",
    ""
  ],
  [
    "a0ae",
    ""
  ],
  [
    "a0b0",
    ""
  ],
  [
    "a0d4",
    ""
  ],
  [
    "a0e2",
    ""
  ],
  [
    "a3c0",
    "",
    31,
    ""
  ],
  [
    "c6a1",
    "",
    9,
    "",
    9,
    "",
    9,
    "",
    23
  ],
  [
    "c740",
    "",
    58,
    ""
  ],
  [
    "c7a1",
    "",
    81,
    "",
    5,
    "",
    4
  ],
  [
    "c840",
    "",
    26,
    "",
    25,
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c8cd",
    ""
  ],
  [
    "c8f5",
    ""
  ],
  [
    "f9fe",
    ""
  ],
  [
    "fa40",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fc40",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fd40",
    ""
  ],
  [
    "fda1",
    ""
  ],
  [
    "fe40",
    ""
  ],
  [
    "fea1",
    ""
  ]
];
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData) return dbcsData;
  hasRequiredDbcsData = 1;
  dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes.
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII,
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return require$$0;
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    932: "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return require$$1;
      },
      encodeAdd: { "": 92, "": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    windows936: "cp936",
    ms936: "cp936",
    936: "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return require$$2;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    gbk: {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3$1);
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    gb18030: {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3$1);
      },
      gb18030: function() {
        return require$$4;
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    chinese: "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    windows949: "cp949",
    ms949: "cp949",
    949: "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return require$$5;
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard.
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    //
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    windows950: "cp950",
    ms950: "cp950",
    950: "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [
        // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
        // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
        // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
        36457,
        36463,
        36478,
        36523,
        36532,
        36557,
        36560,
        36695,
        36713,
        36718,
        36811,
        36862,
        36973,
        36986,
        37060,
        37084,
        37105,
        37311,
        37551,
        37552,
        37553,
        37554,
        37585,
        37959,
        38090,
        38361,
        38652,
        39285,
        39798,
        39800,
        39803,
        39878,
        39902,
        39916,
        39926,
        40002,
        40019,
        40034,
        40040,
        40043,
        40055,
        40124,
        40125,
        40144,
        40279,
        40282,
        40388,
        40431,
        40443,
        40617,
        40687,
        40701,
        40800,
        40907,
        41079,
        41180,
        41183,
        36812,
        37576,
        38468,
        38637,
        // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
        41636,
        41637,
        41639,
        41638,
        41676,
        41678
      ]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  };
  return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings) return encodings;
  hasRequiredEncodings = 1;
  (function(exports$1) {
    var mergeModules = requireMergeExports();
    var modules = [
      requireInternal(),
      requireUtf32(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ];
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      mergeModules(exports$1, module);
    }
  })(encodings);
  return encodings;
}
var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer2 = requireSafer().Buffer;
  streams = function(streamModule) {
    var Transform = streamModule.Transform;
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteEncoderStream }
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
      if (typeof chunk !== "string") {
        return done(new Error("Iconv encoding stream needs strings as its input."));
      }
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer2.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteDecoderStream }
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
      if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array)) {
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      }
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream,
      IconvLiteDecoderStream
    };
  };
  return streams;
}
lib$2.exports;
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$2.exports;
  hasRequiredLib$1 = 1;
  (function(module) {
    var Buffer2 = requireSafer().Buffer;
    var bomHandling2 = requireBomHandling();
    var mergeModules = requireMergeExports();
    module.exports.encodings = null;
    module.exports.defaultCharUnicode = "";
    module.exports.defaultCharSingleByte = "?";
    module.exports.encode = function encode(str2, encoding, options) {
      str2 = "" + (str2 || "");
      var encoder = module.exports.getEncoder(encoding, options);
      var res = encoder.write(str2);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    module.exports.decode = function decode(buf, encoding, options) {
      if (typeof buf === "string") {
        if (!module.exports.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          module.exports.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = module.exports.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    module.exports.encodingExists = function encodingExists(enc) {
      try {
        module.exports.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    module.exports.toEncoding = module.exports.encode;
    module.exports.fromEncoding = module.exports.decode;
    module.exports._codecDataCache = { __proto__: null };
    module.exports.getCodec = function getCodec(encoding) {
      if (!module.exports.encodings) {
        var raw = requireEncodings();
        module.exports.encodings = { __proto__: null };
        mergeModules(module.exports.encodings, raw);
      }
      var enc = module.exports._canonicalizeEncoding(encoding);
      var codecOptions = {};
      while (true) {
        var codec = module.exports._codecDataCache[enc];
        if (codec) {
          return codec;
        }
        var codecDef = module.exports.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef) {
              codecOptions[key] = codecDef[key];
            }
            if (!codecOptions.encodingName) {
              codecOptions.encodingName = enc;
            }
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName) {
              codecOptions.encodingName = enc;
            }
            codec = new codecDef(codecOptions, module.exports);
            module.exports._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    module.exports._canonicalizeEncoding = function(encoding) {
      return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    module.exports.getEncoder = function getEncoder(encoding, options) {
      var codec = module.exports.getCodec(encoding);
      var encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM) {
        encoder = new bomHandling2.PrependBOM(encoder, options);
      }
      return encoder;
    };
    module.exports.getDecoder = function getDecoder(encoding, options) {
      var codec = module.exports.getCodec(encoding);
      var decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false)) {
        decoder = new bomHandling2.StripBOM(decoder, options);
      }
      return decoder;
    };
    module.exports.enableStreamingAPI = function enableStreamingAPI(streamModule2) {
      if (module.exports.supportsStreams) {
        return;
      }
      var streams2 = requireStreams()(streamModule2);
      module.exports.IconvLiteEncoderStream = streams2.IconvLiteEncoderStream;
      module.exports.IconvLiteDecoderStream = streams2.IconvLiteDecoderStream;
      module.exports.encodeStream = function encodeStream(encoding, options) {
        return new module.exports.IconvLiteEncoderStream(module.exports.getEncoder(encoding, options), options);
      };
      module.exports.decodeStream = function decodeStream(encoding, options) {
        return new module.exports.IconvLiteDecoderStream(module.exports.getDecoder(encoding, options), options);
      };
      module.exports.supportsStreams = true;
    };
    var streamModule;
    try {
      streamModule = require("stream");
    } catch (e) {
    }
    if (streamModule && streamModule.Transform) {
      module.exports.enableStreamingAPI(streamModule);
    } else {
      module.exports.encodeStream = module.exports.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
      };
    }
  })(lib$2);
  return lib$2.exports;
}
var hasRequiredString;
function requireString() {
  if (hasRequiredString) return string;
  hasRequiredString = 1;
  const Iconv = requireLib$1();
  const { createLRU } = requireLib$2();
  const decoderCache = createLRU({
    max: 500
  });
  string.decode = function(buffer, encoding, start, end, options) {
    if (Buffer.isEncoding(encoding)) {
      return buffer.toString(encoding, start, end);
    }
    let decoder;
    if (!options) {
      decoder = decoderCache.get(encoding);
      if (!decoder) {
        decoder = Iconv.getDecoder(encoding);
        decoderCache.set(encoding, decoder);
      }
    } else {
      const decoderArgs = { encoding, options };
      const decoderKey = JSON.stringify(decoderArgs);
      decoder = decoderCache.get(decoderKey);
      if (!decoder) {
        decoder = Iconv.getDecoder(decoderArgs.encoding, decoderArgs.options);
        decoderCache.set(decoderKey, decoder);
      }
    }
    const res = decoder.write(buffer.slice(start, end));
    const trail = decoder.end();
    return trail ? res + trail : res;
  };
  string.encode = function(string2, encoding, options) {
    if (Buffer.isEncoding(encoding)) {
      return Buffer.from(string2, encoding);
    }
    const encoder = Iconv.getEncoder(encoding, options || {});
    const res = encoder.write(string2);
    const trail = encoder.end();
    return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
  };
  return string;
}
var types = { exports: {} };
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types.exports;
  hasRequiredTypes = 1;
  types.exports = {
    0: "DECIMAL",
    // aka DECIMAL
    1: "TINY",
    // aka TINYINT, 1 byte
    2: "SHORT",
    // aka SMALLINT, 2 bytes
    3: "LONG",
    // aka INT, 4 bytes
    4: "FLOAT",
    // aka FLOAT, 4-8 bytes
    5: "DOUBLE",
    // aka DOUBLE, 8 bytes
    6: "NULL",
    // NULL (used for prepared statements, I think)
    7: "TIMESTAMP",
    // aka TIMESTAMP
    8: "LONGLONG",
    // aka BIGINT, 8 bytes
    9: "INT24",
    // aka MEDIUMINT, 3 bytes
    10: "DATE",
    // aka DATE
    11: "TIME",
    // aka TIME
    12: "DATETIME",
    // aka DATETIME
    13: "YEAR",
    // aka YEAR, 1 byte (don't ask)
    14: "NEWDATE",
    // aka ?
    15: "VARCHAR",
    // aka VARCHAR (?)
    16: "BIT",
    // aka BIT, 1-8 byte
    245: "JSON",
    246: "NEWDECIMAL",
    // aka DECIMAL
    247: "ENUM",
    // aka ENUM
    248: "SET",
    // aka SET
    249: "TINY_BLOB",
    // aka TINYBLOB, TINYTEXT
    250: "MEDIUM_BLOB",
    // aka MEDIUMBLOB, MEDIUMTEXT
    251: "LONG_BLOB",
    // aka LONGBLOG, LONGTEXT
    252: "BLOB",
    // aka BLOB, TEXT
    253: "VAR_STRING",
    // aka VARCHAR, VARBINARY
    254: "STRING",
    // aka CHAR, BINARY
    255: "GEOMETRY"
    // aka GEOMETRY
  };
  types.exports.DECIMAL = 0;
  types.exports.TINY = 1;
  types.exports.SHORT = 2;
  types.exports.LONG = 3;
  types.exports.FLOAT = 4;
  types.exports.DOUBLE = 5;
  types.exports.NULL = 6;
  types.exports.TIMESTAMP = 7;
  types.exports.LONGLONG = 8;
  types.exports.INT24 = 9;
  types.exports.DATE = 10;
  types.exports.TIME = 11;
  types.exports.DATETIME = 12;
  types.exports.YEAR = 13;
  types.exports.NEWDATE = 14;
  types.exports.VARCHAR = 15;
  types.exports.BIT = 16;
  types.exports.VECTOR = 242;
  types.exports.JSON = 245;
  types.exports.NEWDECIMAL = 246;
  types.exports.ENUM = 247;
  types.exports.SET = 248;
  types.exports.TINY_BLOB = 249;
  types.exports.MEDIUM_BLOB = 250;
  types.exports.LONG_BLOB = 251;
  types.exports.BLOB = 252;
  types.exports.VAR_STRING = 253;
  types.exports.STRING = 254;
  types.exports.GEOMETRY = 255;
  return types.exports;
}
var packet;
var hasRequiredPacket;
function requirePacket() {
  if (hasRequiredPacket) return packet;
  hasRequiredPacket = 1;
  const ErrorCodeToName = requireErrors();
  const NativeBuffer = require$$0$5.Buffer;
  const Long = requireUmd();
  const StringParser = requireString();
  const Types = requireTypes();
  const INVALID_DATE = /* @__PURE__ */ new Date(NaN);
  const pad = "000000000000";
  function leftPad(num, value) {
    const s = value.toString();
    if (s.length >= num) {
      return s;
    }
    return (pad + s).slice(-num);
  }
  const minus = "-".charCodeAt(0);
  const plus = "+".charCodeAt(0);
  const dot = ".".charCodeAt(0);
  const exponent = "e".charCodeAt(0);
  const exponentCapital = "E".charCodeAt(0);
  class Packet {
    constructor(id, buffer, start, end) {
      this.sequenceId = id;
      this.numPackets = 1;
      this.buffer = buffer;
      this.start = start;
      this.offset = start + 4;
      this.end = end;
    }
    // ==============================
    // readers
    // ==============================
    reset() {
      this.offset = this.start + 4;
    }
    length() {
      return this.end - this.start;
    }
    slice() {
      return this.buffer.slice(this.start, this.end);
    }
    dump() {
      console.log(
        [this.buffer.asciiSlice(this.start, this.end)],
        this.buffer.slice(this.start, this.end),
        this.length(),
        this.sequenceId
      );
    }
    haveMoreData() {
      return this.end > this.offset;
    }
    skip(num) {
      this.offset += num;
    }
    readInt8() {
      return this.buffer[this.offset++];
    }
    readInt16() {
      this.offset += 2;
      return this.buffer.readUInt16LE(this.offset - 2);
    }
    readInt24() {
      return this.readInt16() + (this.readInt8() << 16);
    }
    readInt32() {
      this.offset += 4;
      return this.buffer.readUInt32LE(this.offset - 4);
    }
    readSInt8() {
      return this.buffer.readInt8(this.offset++);
    }
    readSInt16() {
      this.offset += 2;
      return this.buffer.readInt16LE(this.offset - 2);
    }
    readSInt32() {
      this.offset += 4;
      return this.buffer.readInt32LE(this.offset - 4);
    }
    readInt64JSNumber() {
      const word0 = this.readInt32();
      const word1 = this.readInt32();
      const l = new Long(word0, word1, true);
      return l.toNumber();
    }
    readSInt64JSNumber() {
      const word0 = this.readInt32();
      const word1 = this.readInt32();
      if (!(word1 & 2147483648)) {
        return word0 + 4294967296 * word1;
      }
      const l = new Long(word0, word1, false);
      return l.toNumber();
    }
    readInt64String() {
      const word0 = this.readInt32();
      const word1 = this.readInt32();
      const res = new Long(word0, word1, true);
      return res.toString();
    }
    readSInt64String() {
      const word0 = this.readInt32();
      const word1 = this.readInt32();
      const res = new Long(word0, word1, false);
      return res.toString();
    }
    readInt64() {
      const word0 = this.readInt32();
      const word1 = this.readInt32();
      let res = new Long(word0, word1, true);
      const resNumber = res.toNumber();
      const resString = res.toString();
      res = resNumber.toString() === resString ? resNumber : resString;
      return res;
    }
    readSInt64() {
      const word0 = this.readInt32();
      const word1 = this.readInt32();
      let res = new Long(word0, word1, false);
      const resNumber = res.toNumber();
      const resString = res.toString();
      res = resNumber.toString() === resString ? resNumber : resString;
      return res;
    }
    isEOF() {
      return this.buffer[this.offset] === 254 && this.length() < 13;
    }
    eofStatusFlags() {
      return this.buffer.readInt16LE(this.offset + 3);
    }
    eofWarningCount() {
      return this.buffer.readInt16LE(this.offset + 1);
    }
    readLengthCodedNumber(bigNumberStrings, signed) {
      const byte1 = this.buffer[this.offset++];
      if (byte1 < 251) {
        return byte1;
      }
      return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);
    }
    readLengthCodedNumberSigned(bigNumberStrings) {
      return this.readLengthCodedNumber(bigNumberStrings, true);
    }
    readLengthCodedNumberExt(tag, bigNumberStrings, signed) {
      let word0, word1;
      let res;
      if (tag === 251) {
        return null;
      }
      if (tag === 252) {
        return this.readInt8() + (this.readInt8() << 8);
      }
      if (tag === 253) {
        return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);
      }
      if (tag === 254) {
        word0 = this.readInt32();
        word1 = this.readInt32();
        if (word1 === 0) {
          return word0;
        }
        if (word1 < 2097152) {
          return word1 * 4294967296 + word0;
        }
        res = new Long(word0, word1, !signed);
        const resNumber = res.toNumber();
        const resString = res.toString();
        res = resNumber.toString() === resString ? resNumber : resString;
        return bigNumberStrings ? resString : res;
      }
      console.trace();
      throw new Error(`Should not reach here: ${tag}`);
    }
    readFloat() {
      const res = this.buffer.readFloatLE(this.offset);
      this.offset += 4;
      return res;
    }
    readDouble() {
      const res = this.buffer.readDoubleLE(this.offset);
      this.offset += 8;
      return res;
    }
    readBuffer(len) {
      if (typeof len === "undefined") {
        len = this.end - this.offset;
      }
      this.offset += len;
      return this.buffer.slice(this.offset - len, this.offset);
    }
    // DATE, DATETIME and TIMESTAMP
    readDateTime(timezone) {
      if (!timezone || timezone === "Z" || timezone === "local") {
        const length = this.readInt8();
        if (length === 251) {
          return null;
        }
        let y = 0;
        let m = 0;
        let d = 0;
        let H = 0;
        let M = 0;
        let S = 0;
        let ms2 = 0;
        if (length > 3) {
          y = this.readInt16();
          m = this.readInt8();
          d = this.readInt8();
        }
        if (length > 6) {
          H = this.readInt8();
          M = this.readInt8();
          S = this.readInt8();
        }
        if (length > 10) {
          ms2 = this.readInt32() / 1e3;
        }
        if (y + m + d + H + M + S + ms2 === 0) {
          return INVALID_DATE;
        }
        if (timezone === "Z") {
          return new Date(Date.UTC(y, m - 1, d, H, M, S, ms2));
        }
        return new Date(y, m - 1, d, H, M, S, ms2);
      }
      let str2 = this.readDateTimeString(6, "T", null);
      if (str2.length === 10) {
        str2 += "T00:00:00";
      }
      return new Date(str2 + timezone);
    }
    readDateTimeString(decimals, timeSep, columnType) {
      const length = this.readInt8();
      let y = 0;
      let m = 0;
      let d = 0;
      let H = 0;
      let M = 0;
      let S = 0;
      let ms2 = 0;
      let str2;
      if (length > 3) {
        y = this.readInt16();
        m = this.readInt8();
        d = this.readInt8();
        str2 = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join("-");
      }
      if (length > 6) {
        H = this.readInt8();
        M = this.readInt8();
        S = this.readInt8();
        str2 += `${timeSep || " "}${[
          leftPad(2, H),
          leftPad(2, M),
          leftPad(2, S)
        ].join(":")}`;
      } else if (columnType === Types.DATETIME) {
        str2 += " 00:00:00";
      }
      if (length > 10) {
        ms2 = this.readInt32();
        str2 += ".";
        if (decimals) {
          ms2 = leftPad(6, ms2);
          if (ms2.length > decimals) {
            ms2 = ms2.substring(0, decimals);
          }
        }
        str2 += ms2;
      }
      return str2;
    }
    // TIME - value as a string, Can be negative
    readTimeString(convertTtoMs) {
      const length = this.readInt8();
      if (length === 0) {
        return "00:00:00";
      }
      const sign = this.readInt8() ? -1 : 1;
      let d = 0;
      let H = 0;
      let M = 0;
      let S = 0;
      let ms2 = 0;
      if (length > 6) {
        d = this.readInt32();
        H = this.readInt8();
        M = this.readInt8();
        S = this.readInt8();
      }
      if (length > 10) {
        ms2 = this.readInt32();
      }
      if (convertTtoMs) {
        H += d * 24;
        M += H * 60;
        S += M * 60;
        ms2 += S * 1e3;
        ms2 *= sign;
        return ms2;
      }
      return (sign === -1 ? "-" : "") + [leftPad(2, d * 24 + H), leftPad(2, M), leftPad(2, S)].join(":") + (ms2 ? `.${ms2}`.replace(/0+$/, "") : "");
    }
    readLengthCodedString(encoding) {
      const len = this.readLengthCodedNumber();
      if (len === null) {
        return null;
      }
      this.offset += len;
      return StringParser.decode(
        this.buffer,
        encoding,
        this.offset - len,
        this.offset
      );
    }
    readLengthCodedBuffer() {
      const len = this.readLengthCodedNumber();
      if (len === null) {
        return null;
      }
      return this.readBuffer(len);
    }
    readNullTerminatedString(encoding) {
      const start = this.offset;
      let end = this.offset;
      while (this.buffer[end]) {
        end = end + 1;
      }
      this.offset = end + 1;
      return StringParser.decode(this.buffer, encoding, start, end);
    }
    // TODO reuse?
    readString(len, encoding) {
      if (typeof len === "string" && typeof encoding === "undefined") {
        encoding = len;
        len = void 0;
      }
      if (typeof len === "undefined") {
        len = this.end - this.offset;
      }
      this.offset += len;
      return StringParser.decode(
        this.buffer,
        encoding,
        this.offset - len,
        this.offset
      );
    }
    parseInt(len, supportBigNumbers) {
      if (len === null) {
        return null;
      }
      if (len >= 14 && !supportBigNumbers) {
        const s = this.buffer.toString("ascii", this.offset, this.offset + len);
        this.offset += len;
        return Number(s);
      }
      let result = 0;
      const start = this.offset;
      const end = this.offset + len;
      let sign = 1;
      if (len === 0) {
        return 0;
      }
      if (this.buffer[this.offset] === minus) {
        this.offset++;
        sign = -1;
      }
      let str2;
      const numDigits = end - this.offset;
      if (supportBigNumbers) {
        if (numDigits >= 15) {
          str2 = this.readString(end - this.offset, "binary");
          result = parseInt(str2, 10);
          if (result.toString() === str2) {
            return sign * result;
          }
          return sign === -1 ? `-${str2}` : str2;
        }
        if (numDigits > 16) {
          str2 = this.readString(end - this.offset);
          return sign === -1 ? `-${str2}` : str2;
        }
      }
      if (this.buffer[this.offset] === plus) {
        this.offset++;
      }
      while (this.offset < end) {
        result *= 10;
        result += this.buffer[this.offset] - 48;
        this.offset++;
      }
      const num = result * sign;
      if (!supportBigNumbers) {
        return num;
      }
      str2 = this.buffer.toString("ascii", start, end);
      if (num.toString() === str2) {
        return num;
      }
      return str2;
    }
    // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER
    // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be
    // different from what you would get from Number(inputNumberAsString)
    // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString
    parseIntNoBigCheck(len) {
      if (len === null) {
        return null;
      }
      let result = 0;
      const end = this.offset + len;
      let sign = 1;
      if (len === 0) {
        return 0;
      }
      if (this.buffer[this.offset] === minus) {
        this.offset++;
        sign = -1;
      }
      if (this.buffer[this.offset] === plus) {
        this.offset++;
      }
      while (this.offset < end) {
        result *= 10;
        result += this.buffer[this.offset] - 48;
        this.offset++;
      }
      return result * sign;
    }
    // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js
    parseGeometryValue() {
      const buffer = this.readLengthCodedBuffer();
      let offset = 4;
      if (buffer === null || !buffer.length) {
        return null;
      }
      function parseGeometry() {
        let x, y, i, j, numPoints, line;
        let result = null;
        const byteOrder = buffer.readUInt8(offset);
        offset += 1;
        const wkbType = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
        offset += 4;
        switch (wkbType) {
          case 1:
            x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
            offset += 8;
            y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
            offset += 8;
            result = { x, y };
            break;
          case 2:
            numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
            offset += 4;
            result = [];
            for (i = numPoints; i > 0; i--) {
              x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
              offset += 8;
              y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
              offset += 8;
              result.push({ x, y });
            }
            break;
          case 3:
            const numRings = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
            offset += 4;
            result = [];
            for (i = numRings; i > 0; i--) {
              numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
              offset += 4;
              line = [];
              for (j = numPoints; j > 0; j--) {
                x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
                offset += 8;
                y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
                offset += 8;
                line.push({ x, y });
              }
              result.push(line);
            }
            break;
          case 4:
          // WKBMultiPoint
          case 5:
          // WKBMultiLineString
          case 6:
          // WKBMultiPolygon
          case 7:
            const num = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
            offset += 4;
            result = [];
            for (i = num; i > 0; i--) {
              result.push(parseGeometry());
            }
            break;
        }
        return result;
      }
      return parseGeometry();
    }
    parseVector() {
      const bufLen = this.readLengthCodedNumber();
      const vectorEnd = this.offset + bufLen;
      const result = [];
      while (this.offset < vectorEnd && this.offset < this.end) {
        result.push(this.readFloat());
      }
      return result;
    }
    parseDate(timezone) {
      const strLen = this.readLengthCodedNumber();
      if (strLen === null) {
        return null;
      }
      if (strLen !== 10) {
        return /* @__PURE__ */ new Date(NaN);
      }
      const y = this.parseInt(4);
      this.offset++;
      const m = this.parseInt(2);
      this.offset++;
      const d = this.parseInt(2);
      if (!timezone || timezone === "local") {
        return new Date(y, m - 1, d);
      }
      if (timezone === "Z") {
        return new Date(Date.UTC(y, m - 1, d));
      }
      return /* @__PURE__ */ new Date(
        `${leftPad(4, y)}-${leftPad(2, m)}-${leftPad(2, d)}T00:00:00${timezone}`
      );
    }
    parseDateTime(timezone) {
      const str2 = this.readLengthCodedString("binary");
      if (str2 === null) {
        return null;
      }
      if (!timezone || timezone === "local") {
        return new Date(str2);
      }
      return /* @__PURE__ */ new Date(`${str2}${timezone}`);
    }
    parseFloat(len) {
      if (len === null) {
        return null;
      }
      let result = 0;
      const end = this.offset + len;
      let factor = 1;
      let pastDot = false;
      let charCode = 0;
      if (len === 0) {
        return 0;
      }
      if (this.buffer[this.offset] === minus) {
        this.offset++;
        factor = -1;
      }
      if (this.buffer[this.offset] === plus) {
        this.offset++;
      }
      while (this.offset < end) {
        charCode = this.buffer[this.offset];
        if (charCode === dot) {
          pastDot = true;
          this.offset++;
        } else if (charCode === exponent || charCode === exponentCapital) {
          this.offset++;
          const exponentValue = this.parseInt(end - this.offset);
          return result / factor * Math.pow(10, exponentValue);
        } else {
          result *= 10;
          result += this.buffer[this.offset] - 48;
          this.offset++;
          if (pastDot) {
            factor = factor * 10;
          }
        }
      }
      return result / factor;
    }
    parseLengthCodedIntNoBigCheck() {
      return this.parseIntNoBigCheck(this.readLengthCodedNumber());
    }
    parseLengthCodedInt(supportBigNumbers) {
      return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);
    }
    parseLengthCodedIntString() {
      return this.readLengthCodedString("binary");
    }
    parseLengthCodedFloat() {
      return this.parseFloat(this.readLengthCodedNumber());
    }
    peekByte() {
      return this.buffer[this.offset];
    }
    // OxFE is often used as "Alt" flag - not ok, not error.
    // For example, it's first byte of AuthSwitchRequest
    isAlt() {
      return this.peekByte() === 254;
    }
    isError() {
      return this.peekByte() === 255;
    }
    asError(encoding) {
      this.reset();
      this.readInt8();
      const errorCode = this.readInt16();
      let sqlState = "";
      if (this.buffer[this.offset] === 35) {
        this.skip(1);
        sqlState = this.readBuffer(5).toString();
      }
      const message = this.readString(void 0, encoding);
      const err = new Error(message);
      err.code = ErrorCodeToName[errorCode];
      err.errno = errorCode;
      err.sqlState = sqlState;
      err.sqlMessage = message;
      return err;
    }
    writeInt32(n) {
      this.buffer.writeUInt32LE(n, this.offset);
      this.offset += 4;
    }
    writeInt24(n) {
      this.writeInt8(n & 255);
      this.writeInt16(n >> 8);
    }
    writeInt16(n) {
      this.buffer.writeUInt16LE(n, this.offset);
      this.offset += 2;
    }
    writeInt8(n) {
      this.buffer.writeUInt8(n, this.offset);
      this.offset++;
    }
    writeDouble(n) {
      this.buffer.writeDoubleLE(n, this.offset);
      this.offset += 8;
    }
    writeBuffer(b) {
      b.copy(this.buffer, this.offset);
      this.offset += b.length;
    }
    writeNull() {
      this.buffer[this.offset] = 251;
      this.offset++;
    }
    // TODO: refactor following three?
    writeNullTerminatedString(s, encoding) {
      const buf = StringParser.encode(s, encoding);
      this.buffer.length && buf.copy(this.buffer, this.offset);
      this.offset += buf.length;
      this.writeInt8(0);
    }
    writeString(s, encoding) {
      if (s === null) {
        this.writeInt8(251);
        return;
      }
      if (s.length === 0) {
        return;
      }
      const buf = StringParser.encode(s, encoding);
      this.buffer.length && buf.copy(this.buffer, this.offset);
      this.offset += buf.length;
    }
    writeLengthCodedString(s, encoding) {
      const buf = StringParser.encode(s, encoding);
      this.writeLengthCodedNumber(buf.length);
      this.buffer.length && buf.copy(this.buffer, this.offset);
      this.offset += buf.length;
    }
    writeLengthCodedBuffer(b) {
      this.writeLengthCodedNumber(b.length);
      b.copy(this.buffer, this.offset);
      this.offset += b.length;
    }
    writeLengthCodedNumber(n) {
      if (n < 251) {
        return this.writeInt8(n);
      }
      if (n < 65535) {
        this.writeInt8(252);
        return this.writeInt16(n);
      }
      if (n < 16777215) {
        this.writeInt8(253);
        return this.writeInt24(n);
      }
      if (n === null) {
        return this.writeInt8(251);
      }
      this.writeInt8(254);
      this.buffer.writeUInt32LE(n, this.offset);
      this.offset += 4;
      this.buffer.writeUInt32LE(n >> 32, this.offset);
      this.offset += 4;
      return this.offset;
    }
    writeDate(d, timezone) {
      this.buffer.writeUInt8(11, this.offset);
      if (!timezone || timezone === "local") {
        this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);
        this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);
        this.buffer.writeUInt8(d.getDate(), this.offset + 4);
        this.buffer.writeUInt8(d.getHours(), this.offset + 5);
        this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);
        this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);
        this.buffer.writeUInt32LE(d.getMilliseconds() * 1e3, this.offset + 8);
      } else {
        if (timezone !== "Z") {
          const offset = (timezone[0] === "-" ? -1 : 1) * (parseInt(timezone.substring(1, 3), 10) * 60 + parseInt(timezone.substring(4), 10));
          if (offset !== 0) {
            d = new Date(d.getTime() + 6e4 * offset);
          }
        }
        this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);
        this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);
        this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);
        this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);
        this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);
        this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);
        this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1e3, this.offset + 8);
      }
      this.offset += 12;
    }
    writeHeader(sequenceId) {
      const offset = this.offset;
      this.offset = 0;
      this.writeInt24(this.buffer.length - 4);
      this.writeInt8(sequenceId);
      this.offset = offset;
    }
    clone() {
      return new Packet(this.sequenceId, this.buffer, this.start, this.end);
    }
    type() {
      if (this.isEOF()) {
        return "EOF";
      }
      if (this.isError()) {
        return "Error";
      }
      if (this.buffer[this.offset] === 0) {
        return "maybeOK";
      }
      return "";
    }
    static lengthCodedNumberLength(n) {
      if (n < 251) {
        return 1;
      }
      if (n < 65535) {
        return 3;
      }
      if (n < 16777215) {
        return 5;
      }
      return 9;
    }
    static lengthCodedStringLength(str2, encoding) {
      const buf = StringParser.encode(str2, encoding);
      const slen = buf.length;
      return Packet.lengthCodedNumberLength(slen) + slen;
    }
    static MockBuffer() {
      const noop = function() {
      };
      const res = Buffer.alloc(0);
      for (const op in NativeBuffer.prototype) {
        if (typeof res[op] === "function") {
          res[op] = noop;
        }
      }
      return res;
    }
  }
  packet = Packet;
  return packet;
}
var packet_parser;
var hasRequiredPacket_parser;
function requirePacket_parser() {
  if (hasRequiredPacket_parser) return packet_parser;
  hasRequiredPacket_parser = 1;
  const Packet = requirePacket();
  const MAX_PACKET_LENGTH = 16777215;
  function readPacketLength(b, off) {
    const b0 = b[off];
    const b1 = b[off + 1];
    const b2 = b[off + 2];
    if (b1 + b2 === 0) {
      return b0;
    }
    return b0 + (b1 << 8) + (b2 << 16);
  }
  class PacketParser {
    constructor(onPacket, packetHeaderLength) {
      if (typeof packetHeaderLength === "undefined") {
        packetHeaderLength = 4;
      }
      this.buffer = [];
      this.bufferLength = 0;
      this.packetHeaderLength = packetHeaderLength;
      this.headerLen = 0;
      this.length = 0;
      this.largePacketParts = [];
      this.firstPacketSequenceId = 0;
      this.onPacket = onPacket;
      this.execute = PacketParser.prototype.executeStart;
      this._flushLargePacket = packetHeaderLength === 7 ? this._flushLargePacket7 : this._flushLargePacket4;
    }
    _flushLargePacket4() {
      const numPackets = this.largePacketParts.length;
      this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0]));
      const body = Buffer.concat(this.largePacketParts);
      const packet2 = new Packet(this.firstPacketSequenceId, body, 0, body.length);
      this.largePacketParts.length = 0;
      packet2.numPackets = numPackets;
      this.onPacket(packet2);
    }
    _flushLargePacket7() {
      const numPackets = this.largePacketParts.length;
      this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0, 0, 0, 0]));
      const body = Buffer.concat(this.largePacketParts);
      this.largePacketParts.length = 0;
      const packet2 = new Packet(this.firstPacketSequenceId, body, 0, body.length);
      packet2.numPackets = numPackets;
      this.onPacket(packet2);
    }
    executeStart(chunk) {
      let start = 0;
      const end = chunk.length;
      while (end - start >= 3) {
        this.length = readPacketLength(chunk, start);
        if (end - start >= this.length + this.packetHeaderLength) {
          const sequenceId = chunk[start + 3];
          if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {
            this.onPacket(
              new Packet(
                sequenceId,
                chunk,
                start,
                start + this.packetHeaderLength + this.length
              )
            );
          } else {
            if (this.largePacketParts.length === 0) {
              this.firstPacketSequenceId = sequenceId;
            }
            this.largePacketParts.push(
              chunk.slice(
                start + this.packetHeaderLength,
                start + this.packetHeaderLength + this.length
              )
            );
            if (this.length < MAX_PACKET_LENGTH) {
              this._flushLargePacket();
            }
          }
          start += this.packetHeaderLength + this.length;
        } else {
          this.buffer = [chunk.slice(start + 3, end)];
          this.bufferLength = end - start - 3;
          this.execute = PacketParser.prototype.executePayload;
          return;
        }
      }
      if (end - start > 0) {
        this.headerLen = end - start;
        this.length = chunk[start];
        if (this.headerLen === 2) {
          this.length = chunk[start] + (chunk[start + 1] << 8);
          this.execute = PacketParser.prototype.executeHeader3;
        } else {
          this.execute = PacketParser.prototype.executeHeader2;
        }
      }
    }
    executePayload(chunk) {
      let start = 0;
      const end = chunk.length;
      const remainingPayload = this.length - this.bufferLength + this.packetHeaderLength - 3;
      if (end - start >= remainingPayload) {
        const payload = Buffer.allocUnsafe(this.length + this.packetHeaderLength);
        let offset = 3;
        for (let i = 0; i < this.buffer.length; ++i) {
          this.buffer[i].copy(payload, offset);
          offset += this.buffer[i].length;
        }
        chunk.copy(payload, offset, start, start + remainingPayload);
        const sequenceId = payload[3];
        if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {
          this.onPacket(
            new Packet(
              sequenceId,
              payload,
              0,
              this.length + this.packetHeaderLength
            )
          );
        } else {
          if (this.largePacketParts.length === 0) {
            this.firstPacketSequenceId = sequenceId;
          }
          this.largePacketParts.push(
            payload.slice(
              this.packetHeaderLength,
              this.packetHeaderLength + this.length
            )
          );
          if (this.length < MAX_PACKET_LENGTH) {
            this._flushLargePacket();
          }
        }
        this.buffer = [];
        this.bufferLength = 0;
        this.execute = PacketParser.prototype.executeStart;
        start += remainingPayload;
        if (end - start > 0) {
          return this.execute(chunk.slice(start, end));
        }
      } else {
        this.buffer.push(chunk);
        this.bufferLength += chunk.length;
      }
      return null;
    }
    executeHeader2(chunk) {
      this.length += chunk[0] << 8;
      if (chunk.length > 1) {
        this.length += chunk[1] << 16;
        this.execute = PacketParser.prototype.executePayload;
        return this.executePayload(chunk.slice(2));
      }
      this.execute = PacketParser.prototype.executeHeader3;
      return null;
    }
    executeHeader3(chunk) {
      this.length += chunk[0] << 16;
      this.execute = PacketParser.prototype.executePayload;
      return this.executePayload(chunk.slice(1));
    }
  }
  packet_parser = PacketParser;
  return packet_parser;
}
var packets = { exports: {} };
var auth_next_factor;
var hasRequiredAuth_next_factor;
function requireAuth_next_factor() {
  if (hasRequiredAuth_next_factor) return auth_next_factor;
  hasRequiredAuth_next_factor = 1;
  const Packet = requirePacket();
  class AuthNextFactor {
    constructor(opts) {
      this.pluginName = opts.pluginName;
      this.pluginData = opts.pluginData;
    }
    toPacket(encoding) {
      const length = 6 + this.pluginName.length + this.pluginData.length;
      const buffer = Buffer.allocUnsafe(length);
      const packet2 = new Packet(0, buffer, 0, length);
      packet2.offset = 4;
      packet2.writeInt8(2);
      packet2.writeNullTerminatedString(this.pluginName, encoding);
      packet2.writeBuffer(this.pluginData);
      return packet2;
    }
    static fromPacket(packet2, encoding) {
      packet2.readInt8();
      const name = packet2.readNullTerminatedString(encoding);
      const data = packet2.readBuffer();
      return new AuthNextFactor({
        pluginName: name,
        pluginData: data
      });
    }
  }
  auth_next_factor = AuthNextFactor;
  return auth_next_factor;
}
var auth_switch_request;
var hasRequiredAuth_switch_request;
function requireAuth_switch_request() {
  if (hasRequiredAuth_switch_request) return auth_switch_request;
  hasRequiredAuth_switch_request = 1;
  const Packet = requirePacket();
  class AuthSwitchRequest {
    constructor(opts) {
      this.pluginName = opts.pluginName;
      this.pluginData = opts.pluginData;
    }
    toPacket() {
      const length = 6 + this.pluginName.length + this.pluginData.length;
      const buffer = Buffer.allocUnsafe(length);
      const packet2 = new Packet(0, buffer, 0, length);
      packet2.offset = 4;
      packet2.writeInt8(254);
      packet2.writeNullTerminatedString(this.pluginName, "cesu8");
      packet2.writeBuffer(this.pluginData);
      return packet2;
    }
    static fromPacket(packet2) {
      packet2.readInt8();
      const name = packet2.readNullTerminatedString("cesu8");
      const data = packet2.readBuffer();
      return new AuthSwitchRequest({
        pluginName: name,
        pluginData: data
      });
    }
  }
  auth_switch_request = AuthSwitchRequest;
  return auth_switch_request;
}
var auth_switch_request_more_data;
var hasRequiredAuth_switch_request_more_data;
function requireAuth_switch_request_more_data() {
  if (hasRequiredAuth_switch_request_more_data) return auth_switch_request_more_data;
  hasRequiredAuth_switch_request_more_data = 1;
  const Packet = requirePacket();
  class AuthSwitchRequestMoreData {
    constructor(data) {
      this.data = data;
    }
    toPacket() {
      const length = 5 + this.data.length;
      const buffer = Buffer.allocUnsafe(length);
      const packet2 = new Packet(0, buffer, 0, length);
      packet2.offset = 4;
      packet2.writeInt8(1);
      packet2.writeBuffer(this.data);
      return packet2;
    }
    static fromPacket(packet2) {
      packet2.readInt8();
      const data = packet2.readBuffer();
      return new AuthSwitchRequestMoreData(data);
    }
    static verifyMarker(packet2) {
      return packet2.peekByte() === 1;
    }
  }
  auth_switch_request_more_data = AuthSwitchRequestMoreData;
  return auth_switch_request_more_data;
}
var auth_switch_response;
var hasRequiredAuth_switch_response;
function requireAuth_switch_response() {
  if (hasRequiredAuth_switch_response) return auth_switch_response;
  hasRequiredAuth_switch_response = 1;
  const Packet = requirePacket();
  class AuthSwitchResponse {
    constructor(data) {
      if (!Buffer.isBuffer(data)) {
        data = Buffer.from(data);
      }
      this.data = data;
    }
    toPacket() {
      const length = 4 + this.data.length;
      const buffer = Buffer.allocUnsafe(length);
      const packet2 = new Packet(0, buffer, 0, length);
      packet2.offset = 4;
      packet2.writeBuffer(this.data);
      return packet2;
    }
    static fromPacket(packet2) {
      const data = packet2.readBuffer();
      return new AuthSwitchResponse(data);
    }
  }
  auth_switch_response = AuthSwitchResponse;
  return auth_switch_response;
}
var binary_row;
var hasRequiredBinary_row;
function requireBinary_row() {
  if (hasRequiredBinary_row) return binary_row;
  hasRequiredBinary_row = 1;
  const Types = requireTypes();
  const Packet = requirePacket();
  const binaryReader = new Array(256);
  class BinaryRow {
    constructor(columns) {
      this.columns = columns || [];
    }
    static toPacket(columns, encoding) {
      const sequenceId = 0;
      let length = 0;
      columns.forEach((val) => {
        if (val === null || typeof val === "undefined") {
          ++length;
          return;
        }
        length += Packet.lengthCodedStringLength(val.toString(10), encoding);
      });
      length = length + 2;
      const buffer = Buffer.allocUnsafe(length + 4);
      const packet2 = new Packet(sequenceId, buffer, 0, length + 4);
      packet2.offset = 4;
      packet2.writeInt8(0);
      let bitmap = 0;
      let bitValue = 1;
      columns.forEach((parameter) => {
        if (parameter.type === Types.NULL) {
          bitmap += bitValue;
        }
        bitValue *= 2;
        if (bitValue === 256) {
          packet2.writeInt8(bitmap);
          bitmap = 0;
          bitValue = 1;
        }
      });
      if (bitValue !== 1) {
        packet2.writeInt8(bitmap);
      }
      columns.forEach((val) => {
        if (val === null) {
          packet2.writeNull();
          return;
        }
        if (typeof val === "undefined") {
          packet2.writeInt8(0);
          return;
        }
        packet2.writeLengthCodedString(val.toString(10), encoding);
      });
      return packet2;
    }
    // TODO: complete list of types...
    static fromPacket(fields, packet2) {
      const columns = new Array(fields.length);
      packet2.readInt8();
      const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);
      packet2.skip(nullBitmapLength);
      for (let i = 0; i < columns.length; ++i) {
        columns[i] = binaryReader[fields[i].columnType].apply(packet2);
      }
      return new BinaryRow(columns);
    }
  }
  binaryReader[Types.DECIMAL] = Packet.prototype.readLengthCodedString;
  binaryReader[1] = Packet.prototype.readInt8;
  binaryReader[2] = Packet.prototype.readInt16;
  binaryReader[3] = Packet.prototype.readInt32;
  binaryReader[4] = Packet.prototype.readFloat;
  binaryReader[5] = Packet.prototype.readDouble;
  binaryReader[6] = Packet.prototype.assertInvalid;
  binaryReader[7] = Packet.prototype.readTimestamp;
  binaryReader[8] = Packet.prototype.readInt64;
  binaryReader[9] = Packet.prototype.readInt32;
  binaryReader[10] = Packet.prototype.readTimestamp;
  binaryReader[11] = Packet.prototype.readTime;
  binaryReader[12] = Packet.prototype.readDateTime;
  binaryReader[13] = Packet.prototype.readInt16;
  binaryReader[Types.VAR_STRING] = Packet.prototype.readLengthCodedString;
  binary_row = BinaryRow;
  return binary_row;
}
var commands$1;
var hasRequiredCommands$1;
function requireCommands$1() {
  if (hasRequiredCommands$1) return commands$1;
  hasRequiredCommands$1 = 1;
  commands$1 = {
    SLEEP: 0,
    // deprecated
    QUIT: 1,
    INIT_DB: 2,
    QUERY: 3,
    FIELD_LIST: 4,
    CREATE_DB: 5,
    DROP_DB: 6,
    REFRESH: 7,
    SHUTDOWN: 8,
    STATISTICS: 9,
    PROCESS_INFO: 10,
    // deprecated
    CONNECT: 11,
    // deprecated
    PROCESS_KILL: 12,
    DEBUG: 13,
    PING: 14,
    TIME: 15,
    // deprecated
    DELAYED_INSERT: 16,
    // deprecated
    CHANGE_USER: 17,
    BINLOG_DUMP: 18,
    TABLE_DUMP: 19,
    CONNECT_OUT: 20,
    REGISTER_SLAVE: 21,
    STMT_PREPARE: 22,
    STMT_EXECUTE: 23,
    STMT_SEND_LONG_DATA: 24,
    STMT_CLOSE: 25,
    STMT_RESET: 26,
    SET_OPTION: 27,
    STMT_FETCH: 28,
    DAEMON: 29,
    // deprecated
    BINLOG_DUMP_GTID: 30,
    UNKNOWN: 255
    // bad!
  };
  return commands$1;
}
var binlog_dump$1;
var hasRequiredBinlog_dump$1;
function requireBinlog_dump$1() {
  if (hasRequiredBinlog_dump$1) return binlog_dump$1;
  hasRequiredBinlog_dump$1 = 1;
  const Packet = requirePacket();
  const CommandCodes = requireCommands$1();
  class BinlogDump {
    constructor(opts) {
      this.binlogPos = opts.binlogPos || 0;
      this.serverId = opts.serverId || 0;
      this.flags = opts.flags || 0;
      this.filename = opts.filename || "";
    }
    toPacket() {
      const length = 15 + Buffer.byteLength(this.filename, "utf8");
      const buffer = Buffer.allocUnsafe(length);
      const packet2 = new Packet(0, buffer, 0, length);
      packet2.offset = 4;
      packet2.writeInt8(CommandCodes.BINLOG_DUMP);
      packet2.writeInt32(this.binlogPos);
      packet2.writeInt16(this.flags);
      packet2.writeInt32(this.serverId);
      packet2.writeString(this.filename);
      return packet2;
    }
  }
  binlog_dump$1 = BinlogDump;
  return binlog_dump$1;
}
var client = {};
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  client.LONG_PASSWORD = 1;
  client.FOUND_ROWS = 2;
  client.LONG_FLAG = 4;
  client.CONNECT_WITH_DB = 8;
  client.NO_SCHEMA = 16;
  client.COMPRESS = 32;
  client.ODBC = 64;
  client.LOCAL_FILES = 128;
  client.IGNORE_SPACE = 256;
  client.PROTOCOL_41 = 512;
  client.INTERACTIVE = 1024;
  client.SSL = 2048;
  client.IGNORE_SIGPIPE = 4096;
  client.TRANSACTIONS = 8192;
  client.RESERVED = 16384;
  client.SECURE_CONNECTION = 32768;
  client.MULTI_STATEMENTS = 65536;
  client.MULTI_RESULTS = 131072;
  client.PS_MULTI_RESULTS = 262144;
  client.PLUGIN_AUTH = 524288;
  client.CONNECT_ATTRS = 1048576;
  client.PLUGIN_AUTH_LENENC_CLIENT_DATA = 2097152;
  client.CAN_HANDLE_EXPIRED_PASSWORDS = 4194304;
  client.SESSION_TRACK = 8388608;
  client.DEPRECATE_EOF = 16777216;
  client.SSL_VERIFY_SERVER_CERT = 1073741824;
  client.REMEMBER_OPTIONS = 2147483648;
  client.MULTI_FACTOR_AUTHENTICATION = 268435456;
  return client;
}
var auth_41 = {};
var hasRequiredAuth_41;
function requireAuth_41() {
  if (hasRequiredAuth_41) return auth_41;
  hasRequiredAuth_41 = 1;
  (function(exports$1) {
    const crypto = require$$0$4;
    function sha1(msg, msg1, msg2) {
      const hash = crypto.createHash("sha1");
      hash.update(msg);
      if (msg1) {
        hash.update(msg1);
      }
      if (msg2) {
        hash.update(msg2);
      }
      return hash.digest();
    }
    function xor(a, b) {
      const result = Buffer.allocUnsafe(a.length);
      for (let i = 0; i < a.length; i++) {
        result[i] = a[i] ^ b[i];
      }
      return result;
    }
    exports$1.xor = xor;
    function token(password, scramble1, scramble2) {
      if (!password) {
        return Buffer.alloc(0);
      }
      const stage1 = sha1(password);
      return exports$1.calculateTokenFromPasswordSha(stage1, scramble1, scramble2);
    }
    exports$1.calculateTokenFromPasswordSha = function(passwordSha, scramble1, scramble2) {
      const authPluginData1 = scramble1.slice(0, 8);
      const authPluginData2 = scramble2.slice(0, 12);
      const stage2 = sha1(passwordSha);
      const stage3 = sha1(authPluginData1, authPluginData2, stage2);
      return xor(stage3, passwordSha);
    };
    exports$1.calculateToken = token;
    exports$1.verifyToken = function(publicSeed1, publicSeed2, token2, doubleSha) {
      const hashStage1 = xor(token2, sha1(publicSeed1, publicSeed2, doubleSha));
      const candidateHash2 = sha1(hashStage1);
      return candidateHash2.compare(doubleSha) === 0;
    };
    exports$1.doubleSha1 = function(password) {
      return sha1(sha1(password));
    };
    function xorRotating(a, seed) {
      const result = Buffer.allocUnsafe(a.length);
      const seedLen = seed.length;
      for (let i = 0; i < a.length; i++) {
        result[i] = a[i] ^ seed[i % seedLen];
      }
      return result;
    }
    exports$1.xorRotating = xorRotating;
  })(auth_41);
  return auth_41;
}
var charset_encodings;
var hasRequiredCharset_encodings;
function requireCharset_encodings() {
  if (hasRequiredCharset_encodings) return charset_encodings;
  hasRequiredCharset_encodings = 1;
  charset_encodings = [
    "utf8",
    "big5",
    "latin2",
    "dec8",
    "cp850",
    "latin1",
    "hp8",
    "koi8r",
    "latin1",
    "latin2",
    "swe7",
    "ascii",
    "eucjp",
    "sjis",
    "cp1251",
    "latin1",
    "hebrew",
    "utf8",
    "tis620",
    "euckr",
    "latin7",
    "latin2",
    "koi8u",
    "cp1251",
    "gb2312",
    "greek",
    "cp1250",
    "latin2",
    "gbk",
    "cp1257",
    "latin5",
    "latin1",
    "armscii8",
    "cesu8",
    "cp1250",
    "ucs2",
    "cp866",
    "keybcs2",
    "macintosh",
    "macroman",
    "cp852",
    "latin7",
    "latin7",
    "macintosh",
    "cp1250",
    "utf8",
    "utf8",
    "latin1",
    "latin1",
    "latin1",
    "cp1251",
    "cp1251",
    "cp1251",
    "macroman",
    "utf16",
    "utf16",
    "utf16-le",
    "cp1256",
    "cp1257",
    "cp1257",
    "utf32",
    "utf32",
    "utf16-le",
    "binary",
    "armscii8",
    "ascii",
    "cp1250",
    "cp1256",
    "cp866",
    "dec8",
    "greek",
    "hebrew",
    "hp8",
    "keybcs2",
    "koi8r",
    "koi8u",
    "cesu8",
    "latin2",
    "latin5",
    "latin7",
    "cp850",
    "cp852",
    "swe7",
    "cesu8",
    "big5",
    "euckr",
    "gb2312",
    "gbk",
    "sjis",
    "tis620",
    "ucs2",
    "eucjp",
    "geostd8",
    "geostd8",
    "latin1",
    "cp932",
    "cp932",
    "eucjpms",
    "eucjpms",
    "cp1250",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf8",
    "utf8",
    "utf8",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "ucs2",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "cesu8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "gb18030",
    "gb18030",
    "gb18030",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8"
  ];
  return charset_encodings;
}
var change_user$1;
var hasRequiredChange_user$1;
function requireChange_user$1() {
  if (hasRequiredChange_user$1) return change_user$1;
  hasRequiredChange_user$1 = 1;
  const CommandCode = requireCommands$1();
  const ClientConstants = requireClient();
  const Packet = requirePacket();
  const auth41 = requireAuth_41();
  const CharsetToEncoding = requireCharset_encodings();
  class ChangeUser {
    constructor(opts) {
      this.flags = opts.flags;
      this.user = opts.user || "";
      this.database = opts.database || "";
      this.password = opts.password || "";
      this.passwordSha1 = opts.passwordSha1;
      this.authPluginData1 = opts.authPluginData1;
      this.authPluginData2 = opts.authPluginData2;
      this.connectAttributes = opts.connectAttrinutes || {};
      let authToken;
      if (this.passwordSha1) {
        authToken = auth41.calculateTokenFromPasswordSha(
          this.passwordSha1,
          this.authPluginData1,
          this.authPluginData2
        );
      } else {
        authToken = auth41.calculateToken(
          this.password,
          this.authPluginData1,
          this.authPluginData2
        );
      }
      this.authToken = authToken;
      this.charsetNumber = opts.charsetNumber;
    }
    // TODO
    // ChangeUser.fromPacket = function(packet)
    // };
    serializeToBuffer(buffer) {
      const isSet = (flag) => this.flags & ClientConstants[flag];
      const packet2 = new Packet(0, buffer, 0, buffer.length);
      packet2.offset = 4;
      const encoding = CharsetToEncoding[this.charsetNumber];
      packet2.writeInt8(CommandCode.CHANGE_USER);
      packet2.writeNullTerminatedString(this.user, encoding);
      if (isSet("SECURE_CONNECTION")) {
        packet2.writeInt8(this.authToken.length);
        packet2.writeBuffer(this.authToken);
      } else {
        packet2.writeBuffer(this.authToken);
        packet2.writeInt8(0);
      }
      packet2.writeNullTerminatedString(this.database, encoding);
      packet2.writeInt16(this.charsetNumber);
      if (isSet("PLUGIN_AUTH")) {
        packet2.writeNullTerminatedString("mysql_native_password", "latin1");
      }
      if (isSet("CONNECT_ATTRS")) {
        const connectAttributes = this.connectAttributes;
        const attrNames = Object.keys(connectAttributes);
        let keysLength = 0;
        for (let k = 0; k < attrNames.length; ++k) {
          keysLength += Packet.lengthCodedStringLength(attrNames[k], encoding);
          keysLength += Packet.lengthCodedStringLength(
            connectAttributes[attrNames[k]],
            encoding
          );
        }
        packet2.writeLengthCodedNumber(keysLength);
        for (let k = 0; k < attrNames.length; ++k) {
          packet2.writeLengthCodedString(attrNames[k], encoding);
          packet2.writeLengthCodedString(
            connectAttributes[attrNames[k]],
            encoding
          );
        }
      }
      return packet2;
    }
    toPacket() {
      if (typeof this.user !== "string") {
        throw new Error('"user" connection config property must be a string');
      }
      if (typeof this.database !== "string") {
        throw new Error('"database" connection config property must be a string');
      }
      const p = this.serializeToBuffer(Packet.MockBuffer());
      return this.serializeToBuffer(Buffer.allocUnsafe(p.offset));
    }
  }
  change_user$1 = ChangeUser;
  return change_user$1;
}
var close_statement$1;
var hasRequiredClose_statement$1;
function requireClose_statement$1() {
  if (hasRequiredClose_statement$1) return close_statement$1;
  hasRequiredClose_statement$1 = 1;
  const Packet = requirePacket();
  const CommandCodes = requireCommands$1();
  class CloseStatement {
    constructor(id) {
      this.id = id;
    }
    // note: no response sent back
    toPacket() {
      const packet2 = new Packet(0, Buffer.allocUnsafe(9), 0, 9);
      packet2.offset = 4;
      packet2.writeInt8(CommandCodes.STMT_CLOSE);
      packet2.writeInt32(this.id);
      return packet2;
    }
  }
  close_statement$1 = CloseStatement;
  return close_statement$1;
}
var field_flags = {};
var hasRequiredField_flags;
function requireField_flags() {
  if (hasRequiredField_flags) return field_flags;
  hasRequiredField_flags = 1;
  field_flags.NOT_NULL = 1;
  field_flags.PRI_KEY = 2;
  field_flags.UNIQUE_KEY = 4;
  field_flags.MULTIPLE_KEY = 8;
  field_flags.BLOB = 16;
  field_flags.UNSIGNED = 32;
  field_flags.ZEROFILL = 64;
  field_flags.BINARY = 128;
  field_flags.ENUM = 256;
  field_flags.AUTO_INCREMENT = 512;
  field_flags.TIMESTAMP = 1024;
  field_flags.SET = 2048;
  field_flags.NO_DEFAULT_VALUE = 4096;
  field_flags.ON_UPDATE_NOW = 8192;
  field_flags.NUM = 32768;
  return field_flags;
}
var column_definition;
var hasRequiredColumn_definition;
function requireColumn_definition() {
  if (hasRequiredColumn_definition) return column_definition;
  hasRequiredColumn_definition = 1;
  const Packet = requirePacket();
  const StringParser = requireString();
  const CharsetToEncoding = requireCharset_encodings();
  const fields = ["catalog", "schema", "table", "orgTable", "name", "orgName"];
  class ColumnDefinition {
    constructor(packet2, clientEncoding) {
      this._buf = packet2.buffer;
      this._clientEncoding = clientEncoding;
      this._catalogLength = packet2.readLengthCodedNumber();
      this._catalogStart = packet2.offset;
      packet2.offset += this._catalogLength;
      this._schemaLength = packet2.readLengthCodedNumber();
      this._schemaStart = packet2.offset;
      packet2.offset += this._schemaLength;
      this._tableLength = packet2.readLengthCodedNumber();
      this._tableStart = packet2.offset;
      packet2.offset += this._tableLength;
      this._orgTableLength = packet2.readLengthCodedNumber();
      this._orgTableStart = packet2.offset;
      packet2.offset += this._orgTableLength;
      const _nameLength = packet2.readLengthCodedNumber();
      const _nameStart = packet2.offset;
      packet2.offset += _nameLength;
      this._orgNameLength = packet2.readLengthCodedNumber();
      this._orgNameStart = packet2.offset;
      packet2.offset += this._orgNameLength;
      packet2.skip(1);
      this.characterSet = packet2.readInt16();
      this.encoding = CharsetToEncoding[this.characterSet];
      this.name = StringParser.decode(
        this._buf,
        this.encoding === "binary" ? this._clientEncoding : this.encoding,
        _nameStart,
        _nameStart + _nameLength
      );
      this.columnLength = packet2.readInt32();
      this.columnType = packet2.readInt8();
      this.type = this.columnType;
      this.flags = packet2.readInt16();
      this.decimals = packet2.readInt8();
    }
    inspect() {
      return {
        catalog: this.catalog,
        schema: this.schema,
        name: this.name,
        orgName: this.orgName,
        table: this.table,
        orgTable: this.orgTable,
        characterSet: this.characterSet,
        encoding: this.encoding,
        columnLength: this.columnLength,
        type: this.columnType,
        flags: this.flags,
        decimals: this.decimals
      };
    }
    [/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")](depth, inspectOptions, inspect) {
      const Types = requireTypes();
      const typeNames = [];
      for (const t in Types) {
        typeNames[Types[t]] = t;
      }
      const fiedFlags = requireField_flags();
      const flagNames = [];
      const inspectFlags = this.flags;
      for (const f in fiedFlags) {
        if (inspectFlags & fiedFlags[f]) {
          if (f === "PRI_KEY") {
            flagNames.push("PRIMARY KEY");
          } else if (f === "NOT_NULL") {
            flagNames.push("NOT NULL");
          } else if (f === "BINARY") ;
          else if (f === "MULTIPLE_KEY") ;
          else if (f === "NO_DEFAULT_VALUE") ;
          else if (f === "BLOB") ;
          else if (f === "UNSIGNED") ;
          else if (f === "TIMESTAMP") ;
          else if (f === "ON_UPDATE_NOW") {
            flagNames.push("ON UPDATE CURRENT_TIMESTAMP");
          } else {
            flagNames.push(f);
          }
        }
      }
      if (depth > 1) {
        return inspect({
          ...this.inspect(),
          typeName: typeNames[this.columnType],
          flags: flagNames
        });
      }
      const isUnsigned = this.flags & fiedFlags.UNSIGNED;
      let typeName = typeNames[this.columnType];
      if (typeName === "BLOB") {
        if (this.columnLength === 4294967295) {
          typeName = "LONGTEXT";
        } else if (this.columnLength === 67108860) {
          typeName = "MEDIUMTEXT";
        } else if (this.columnLength === 262140) {
          typeName = "TEXT";
        } else if (this.columnLength === 1020) {
          typeName = "TINYTEXT";
        } else {
          typeName = `BLOB(${this.columnLength})`;
        }
      } else if (typeName === "VAR_STRING") {
        typeName = `VARCHAR(${Math.ceil(this.columnLength / 4)})`;
      } else if (typeName === "TINY") {
        if (this.columnLength === 3 && isUnsigned || this.columnLength === 4 && !isUnsigned) {
          typeName = "TINYINT";
        } else {
          typeName = `TINYINT(${this.columnLength})`;
        }
      } else if (typeName === "LONGLONG") {
        if (this.columnLength === 20) {
          typeName = "BIGINT";
        } else {
          typeName = `BIGINT(${this.columnLength})`;
        }
      } else if (typeName === "SHORT") {
        if (isUnsigned && this.columnLength === 5) {
          typeName = "SMALLINT";
        } else if (!isUnsigned && this.columnLength === 6) {
          typeName = "SMALLINT";
        } else {
          typeName = `SMALLINT(${this.columnLength})`;
        }
      } else if (typeName === "LONG") {
        if (isUnsigned && this.columnLength === 10) {
          typeName = "INT";
        } else if (!isUnsigned && this.columnLength === 11) {
          typeName = "INT";
        } else {
          typeName = `INT(${this.columnLength})`;
        }
      } else if (typeName === "INT24") {
        if (isUnsigned && this.columnLength === 8) {
          typeName = "MEDIUMINT";
        } else if (!isUnsigned && this.columnLength === 9) {
          typeName = "MEDIUMINT";
        } else {
          typeName = `MEDIUMINT(${this.columnLength})`;
        }
      } else if (typeName === "DOUBLE") {
        if (this.columnLength === 22 && this.decimals === 31) {
          typeName = "DOUBLE";
        } else {
          typeName = `DOUBLE(${this.columnLength},${this.decimals})`;
        }
      } else if (typeName === "FLOAT") {
        if (this.columnLength === 12 && this.decimals === 31) {
          typeName = "FLOAT";
        } else {
          typeName = `FLOAT(${this.columnLength},${this.decimals})`;
        }
      } else if (typeName === "NEWDECIMAL") {
        if (this.columnLength === 11 && this.decimals === 0) {
          typeName = "DECIMAL";
        } else if (this.decimals === 0) {
          if (isUnsigned) {
            typeName = `DECIMAL(${this.columnLength})`;
          } else {
            typeName = `DECIMAL(${this.columnLength - 1})`;
          }
        } else {
          typeName = `DECIMAL(${this.columnLength - 2},${this.decimals})`;
        }
      } else {
        typeName = `${typeNames[this.columnType]}(${this.columnLength})`;
      }
      if (isUnsigned) {
        typeName += " UNSIGNED";
      }
      return `\`${this.name}\` ${[typeName, ...flagNames].join(" ")}`;
    }
    static toPacket(column, sequenceId) {
      let length = 17;
      fields.forEach((field) => {
        length += Packet.lengthCodedStringLength(
          column[field],
          CharsetToEncoding[column.characterSet]
        );
      });
      const buffer = Buffer.allocUnsafe(length);
      const packet2 = new Packet(sequenceId, buffer, 0, length);
      function writeField(name) {
        packet2.writeLengthCodedString(
          column[name],
          CharsetToEncoding[column.characterSet]
        );
      }
      packet2.offset = 4;
      fields.forEach(writeField);
      packet2.writeInt8(12);
      packet2.writeInt16(column.characterSet);
      packet2.writeInt32(column.columnLength);
      packet2.writeInt8(column.columnType);
      packet2.writeInt16(column.flags);
      packet2.writeInt8(column.decimals);
      packet2.writeInt16(0);
      return packet2;
    }
    // node-mysql compatibility: alias "db" to "schema"
    get db() {
      return this.schema;
    }
  }
  const addString = function(name) {
    Object.defineProperty(ColumnDefinition.prototype, name, {
      get: function() {
        const start = this[`_${name}Start`];
        const end = start + this[`_${name}Length`];
        const val = StringParser.decode(
          this._buf,
          this.encoding === "binary" ? this._clientEncoding : this.encoding,
          start,
          end
        );
        Object.defineProperty(this, name, {
          value: val,
          writable: false,
          configurable: false,
          enumerable: false
        });
        return val;
      }
    });
  };
  addString("catalog");
  addString("schema");
  addString("table");
  addString("orgTable");
  addString("orgName");
  column_definition = ColumnDefinition;
  return column_definition;
}
var cursor;
var hasRequiredCursor;
function requireCursor() {
  if (hasRequiredCursor) return cursor;
  hasRequiredCursor = 1;
  cursor = {
    NO_CURSOR: 0,
    READ_ONLY: 1,
    FOR_UPDATE: 2,
    SCROLLABLE: 3
  };
  return cursor;
}
var execute$1;
var hasRequiredExecute$1;
function requireExecute$1() {
  if (hasRequiredExecute$1) return execute$1;
  hasRequiredExecute$1 = 1;
  const CursorType = requireCursor();
  const CommandCodes = requireCommands$1();
  const Types = requireTypes();
  const Packet = requirePacket();
  const CharsetToEncoding = requireCharset_encodings();
  function isJSON(value) {
    return Array.isArray(value) || value.constructor === Object || typeof value.toJSON === "function" && !Buffer.isBuffer(value);
  }
  function toParameter(value, encoding, timezone) {
    let type2 = Types.VAR_STRING;
    let length;
    let writer = function(value2) {
      return Packet.prototype.writeLengthCodedString.call(this, value2, encoding);
    };
    if (value !== null) {
      switch (typeof value) {
        case "undefined":
          throw new TypeError("Bind parameters must not contain undefined");
        case "number":
          type2 = Types.DOUBLE;
          length = 8;
          writer = Packet.prototype.writeDouble;
          break;
        case "boolean":
          value = value | 0;
          type2 = Types.TINY;
          length = 1;
          writer = Packet.prototype.writeInt8;
          break;
        case "object":
          if (Object.prototype.toString.call(value) === "[object Date]") {
            type2 = Types.DATETIME;
            length = 12;
            writer = function(value2) {
              return Packet.prototype.writeDate.call(this, value2, timezone);
            };
          } else if (isJSON(value)) {
            value = JSON.stringify(value);
            type2 = Types.JSON;
          } else if (Buffer.isBuffer(value)) {
            length = Packet.lengthCodedNumberLength(value.length) + value.length;
            writer = Packet.prototype.writeLengthCodedBuffer;
          }
          break;
        default:
          value = value.toString();
      }
    } else {
      value = "";
      type2 = Types.NULL;
    }
    if (!length) {
      length = Packet.lengthCodedStringLength(value, encoding);
    }
    return { value, type: type2, length, writer };
  }
  class Execute {
    constructor(id, parameters, charsetNumber, timezone) {
      this.id = id;
      this.parameters = parameters;
      this.encoding = CharsetToEncoding[charsetNumber];
      this.timezone = timezone;
    }
    static fromPacket(packet2, encoding) {
      const stmtId = packet2.readInt32();
      const flags = packet2.readInt8();
      const iterationCount = packet2.readInt32();
      let i = packet2.offset;
      while (i < packet2.end - 1) {
        if ((packet2.buffer[i + 1] === Types.VAR_STRING || packet2.buffer[i + 1] === Types.NULL || packet2.buffer[i + 1] === Types.DOUBLE || packet2.buffer[i + 1] === Types.TINY || packet2.buffer[i + 1] === Types.DATETIME || packet2.buffer[i + 1] === Types.JSON) && packet2.buffer[i] === 1 && packet2.buffer[i + 2] === 0) {
          break;
        } else {
          packet2.readInt8();
        }
        i++;
      }
      const types2 = [];
      for (let i2 = packet2.offset + 1; i2 < packet2.end - 1; i2++) {
        if ((packet2.buffer[i2] === Types.VAR_STRING || packet2.buffer[i2] === Types.NULL || packet2.buffer[i2] === Types.DOUBLE || packet2.buffer[i2] === Types.TINY || packet2.buffer[i2] === Types.DATETIME || packet2.buffer[i2] === Types.JSON) && packet2.buffer[i2 + 1] === 0) {
          types2.push(packet2.buffer[i2]);
          packet2.skip(2);
        }
      }
      packet2.skip(1);
      const values = [];
      for (let i2 = 0; i2 < types2.length; i2++) {
        if (types2[i2] === Types.VAR_STRING) {
          values.push(packet2.readLengthCodedString(encoding));
        } else if (types2[i2] === Types.DOUBLE) {
          values.push(packet2.readDouble());
        } else if (types2[i2] === Types.TINY) {
          values.push(packet2.readInt8());
        } else if (types2[i2] === Types.DATETIME) {
          values.push(packet2.readDateTime());
        } else if (types2[i2] === Types.JSON) {
          values.push(JSON.parse(packet2.readLengthCodedString(encoding)));
        }
        if (types2[i2] === Types.NULL) {
          values.push(null);
        }
      }
      return { stmtId, flags, iterationCount, values };
    }
    toPacket() {
      let length = 14;
      let parameters;
      if (this.parameters && this.parameters.length > 0) {
        length += Math.floor((this.parameters.length + 7) / 8);
        length += 1;
        length += 2 * this.parameters.length;
        parameters = this.parameters.map(
          (value) => toParameter(value, this.encoding, this.timezone)
        );
        length += parameters.reduce(
          (accumulator, parameter) => accumulator + parameter.length,
          0
        );
      }
      const buffer = Buffer.allocUnsafe(length);
      const packet2 = new Packet(0, buffer, 0, length);
      packet2.offset = 4;
      packet2.writeInt8(CommandCodes.STMT_EXECUTE);
      packet2.writeInt32(this.id);
      packet2.writeInt8(CursorType.NO_CURSOR);
      packet2.writeInt32(1);
      if (parameters) {
        let bitmap = 0;
        let bitValue = 1;
        parameters.forEach((parameter) => {
          if (parameter.type === Types.NULL) {
            bitmap += bitValue;
          }
          bitValue *= 2;
          if (bitValue === 256) {
            packet2.writeInt8(bitmap);
            bitmap = 0;
            bitValue = 1;
          }
        });
        if (bitValue !== 1) {
          packet2.writeInt8(bitmap);
        }
        packet2.writeInt8(1);
        parameters.forEach((parameter) => {
          packet2.writeInt8(parameter.type);
          packet2.writeInt8(0);
        });
        parameters.forEach((parameter) => {
          if (parameter.type !== Types.NULL) {
            parameter.writer.call(packet2, parameter.value);
          }
        });
      }
      return packet2;
    }
  }
  execute$1 = Execute;
  return execute$1;
}
var handshake;
var hasRequiredHandshake;
function requireHandshake() {
  if (hasRequiredHandshake) return handshake;
  hasRequiredHandshake = 1;
  const Packet = requirePacket();
  const ClientConstants = requireClient();
  class Handshake {
    constructor(args) {
      this.protocolVersion = args.protocolVersion;
      this.serverVersion = args.serverVersion;
      this.capabilityFlags = args.capabilityFlags;
      this.connectionId = args.connectionId;
      this.authPluginData1 = args.authPluginData1;
      this.authPluginData2 = args.authPluginData2;
      this.characterSet = args.characterSet;
      this.statusFlags = args.statusFlags;
      this.authPluginName = args.authPluginName;
    }
    setScrambleData(cb) {
      require$$0$4.randomBytes(20, (err, data) => {
        if (err) {
          cb(err);
          return;
        }
        this.authPluginData1 = data.slice(0, 8);
        this.authPluginData2 = data.slice(8, 20);
        cb();
      });
    }
    toPacket(sequenceId) {
      const length = 68 + Buffer.byteLength(this.serverVersion, "utf8");
      const buffer = Buffer.alloc(length + 4, 0);
      const packet2 = new Packet(sequenceId, buffer, 0, length + 4);
      packet2.offset = 4;
      packet2.writeInt8(this.protocolVersion);
      packet2.writeString(this.serverVersion, "cesu8");
      packet2.writeInt8(0);
      packet2.writeInt32(this.connectionId);
      packet2.writeBuffer(this.authPluginData1);
      packet2.writeInt8(0);
      const capabilityFlagsBuffer = Buffer.allocUnsafe(4);
      capabilityFlagsBuffer.writeUInt32LE(this.capabilityFlags, 0);
      packet2.writeBuffer(capabilityFlagsBuffer.slice(0, 2));
      packet2.writeInt8(this.characterSet);
      packet2.writeInt16(this.statusFlags);
      packet2.writeBuffer(capabilityFlagsBuffer.slice(2, 4));
      packet2.writeInt8(21);
      packet2.skip(10);
      packet2.writeBuffer(this.authPluginData2);
      packet2.writeInt8(0);
      packet2.writeString("mysql_native_password", "latin1");
      packet2.writeInt8(0);
      return packet2;
    }
    static fromPacket(packet2) {
      const args = {};
      args.protocolVersion = packet2.readInt8();
      args.serverVersion = packet2.readNullTerminatedString("cesu8");
      args.connectionId = packet2.readInt32();
      args.authPluginData1 = packet2.readBuffer(8);
      packet2.skip(1);
      const capabilityFlagsBuffer = Buffer.allocUnsafe(4);
      capabilityFlagsBuffer[0] = packet2.readInt8();
      capabilityFlagsBuffer[1] = packet2.readInt8();
      if (packet2.haveMoreData()) {
        args.characterSet = packet2.readInt8();
        args.statusFlags = packet2.readInt16();
        capabilityFlagsBuffer[2] = packet2.readInt8();
        capabilityFlagsBuffer[3] = packet2.readInt8();
        args.capabilityFlags = capabilityFlagsBuffer.readUInt32LE(0);
        if (args.capabilityFlags & ClientConstants.PLUGIN_AUTH) {
          args.authPluginDataLength = packet2.readInt8();
        } else {
          args.authPluginDataLength = 0;
          packet2.skip(1);
        }
        packet2.skip(10);
      } else {
        args.capabilityFlags = capabilityFlagsBuffer.readUInt16LE(0);
      }
      const isSecureConnection = args.capabilityFlags & ClientConstants.SECURE_CONNECTION;
      if (isSecureConnection) {
        const authPluginDataLength = args.authPluginDataLength;
        if (authPluginDataLength === 0) {
          args.authPluginDataLength = 20;
          args.authPluginData2 = packet2.readBuffer(12);
          packet2.skip(1);
        } else {
          const len = Math.max(13, authPluginDataLength - 8);
          args.authPluginData2 = packet2.readBuffer(len);
        }
      }
      if (args.capabilityFlags & ClientConstants.PLUGIN_AUTH) {
        args.authPluginName = packet2.readNullTerminatedString("ascii");
      }
      return new Handshake(args);
    }
  }
  handshake = Handshake;
  return handshake;
}
var handshake_response;
var hasRequiredHandshake_response;
function requireHandshake_response() {
  if (hasRequiredHandshake_response) return handshake_response;
  hasRequiredHandshake_response = 1;
  const ClientConstants = requireClient();
  const CharsetToEncoding = requireCharset_encodings();
  const Packet = requirePacket();
  const auth41 = requireAuth_41();
  class HandshakeResponse {
    constructor(handshake2) {
      this.user = handshake2.user || "";
      this.database = handshake2.database || "";
      this.password = handshake2.password || "";
      this.passwordSha1 = handshake2.passwordSha1;
      this.authPluginData1 = handshake2.authPluginData1;
      this.authPluginData2 = handshake2.authPluginData2;
      this.compress = handshake2.compress;
      this.clientFlags = handshake2.flags;
      let authToken;
      if (this.passwordSha1) {
        authToken = auth41.calculateTokenFromPasswordSha(
          this.passwordSha1,
          this.authPluginData1,
          this.authPluginData2
        );
      } else {
        authToken = auth41.calculateToken(
          this.password,
          this.authPluginData1,
          this.authPluginData2
        );
      }
      this.authToken = authToken;
      this.charsetNumber = handshake2.charsetNumber;
      this.encoding = CharsetToEncoding[handshake2.charsetNumber];
      this.connectAttributes = handshake2.connectAttributes;
    }
    serializeResponse(buffer) {
      const isSet = (flag) => this.clientFlags & ClientConstants[flag];
      const packet2 = new Packet(0, buffer, 0, buffer.length);
      packet2.offset = 4;
      packet2.writeInt32(this.clientFlags);
      packet2.writeInt32(0);
      packet2.writeInt8(this.charsetNumber);
      packet2.skip(23);
      const encoding = this.encoding;
      packet2.writeNullTerminatedString(this.user, encoding);
      let k;
      if (isSet("PLUGIN_AUTH_LENENC_CLIENT_DATA")) {
        packet2.writeLengthCodedNumber(this.authToken.length);
        packet2.writeBuffer(this.authToken);
      } else if (isSet("SECURE_CONNECTION")) {
        packet2.writeInt8(this.authToken.length);
        packet2.writeBuffer(this.authToken);
      } else {
        packet2.writeBuffer(this.authToken);
        packet2.writeInt8(0);
      }
      if (isSet("CONNECT_WITH_DB")) {
        packet2.writeNullTerminatedString(this.database, encoding);
      }
      if (isSet("PLUGIN_AUTH")) {
        packet2.writeNullTerminatedString("mysql_native_password", "latin1");
      }
      if (isSet("CONNECT_ATTRS")) {
        const connectAttributes = this.connectAttributes || {};
        const attrNames = Object.keys(connectAttributes);
        let keysLength = 0;
        for (k = 0; k < attrNames.length; ++k) {
          keysLength += Packet.lengthCodedStringLength(attrNames[k], encoding);
          keysLength += Packet.lengthCodedStringLength(
            connectAttributes[attrNames[k]],
            encoding
          );
        }
        packet2.writeLengthCodedNumber(keysLength);
        for (k = 0; k < attrNames.length; ++k) {
          packet2.writeLengthCodedString(attrNames[k], encoding);
          packet2.writeLengthCodedString(
            connectAttributes[attrNames[k]],
            encoding
          );
        }
      }
      return packet2;
    }
    toPacket() {
      if (typeof this.user !== "string") {
        throw new Error('"user" connection config property must be a string');
      }
      if (typeof this.database !== "string") {
        throw new Error('"database" connection config property must be a string');
      }
      const p = this.serializeResponse(Packet.MockBuffer());
      return this.serializeResponse(Buffer.alloc(p.offset));
    }
    static fromPacket(packet2) {
      const args = {};
      args.clientFlags = packet2.readInt32();
      function isSet(flag) {
        return args.clientFlags & ClientConstants[flag];
      }
      args.maxPacketSize = packet2.readInt32();
      args.charsetNumber = packet2.readInt8();
      const encoding = CharsetToEncoding[args.charsetNumber];
      args.encoding = encoding;
      packet2.skip(23);
      args.user = packet2.readNullTerminatedString(encoding);
      let authTokenLength;
      if (isSet("PLUGIN_AUTH_LENENC_CLIENT_DATA")) {
        authTokenLength = packet2.readLengthCodedNumber(encoding);
        args.authToken = packet2.readBuffer(authTokenLength);
      } else if (isSet("SECURE_CONNECTION")) {
        authTokenLength = packet2.readInt8();
        args.authToken = packet2.readBuffer(authTokenLength);
      } else {
        args.authToken = packet2.readNullTerminatedString(encoding);
      }
      if (isSet("CONNECT_WITH_DB")) {
        args.database = packet2.readNullTerminatedString(encoding);
      }
      if (isSet("PLUGIN_AUTH")) {
        args.authPluginName = packet2.readNullTerminatedString(encoding);
      }
      if (isSet("CONNECT_ATTRS")) {
        const keysLength = packet2.readLengthCodedNumber(encoding);
        const keysEnd = packet2.offset + keysLength;
        const attrs = {};
        while (packet2.offset < keysEnd) {
          attrs[packet2.readLengthCodedString(encoding)] = packet2.readLengthCodedString(encoding);
        }
        args.connectAttributes = attrs;
      }
      return args;
    }
  }
  handshake_response = HandshakeResponse;
  return handshake_response;
}
var prepare_statement;
var hasRequiredPrepare_statement;
function requirePrepare_statement() {
  if (hasRequiredPrepare_statement) return prepare_statement;
  hasRequiredPrepare_statement = 1;
  const Packet = requirePacket();
  const CommandCodes = requireCommands$1();
  const StringParser = requireString();
  const CharsetToEncoding = requireCharset_encodings();
  class PrepareStatement {
    constructor(sql, charsetNumber) {
      this.query = sql;
      this.charsetNumber = charsetNumber;
      this.encoding = CharsetToEncoding[charsetNumber];
    }
    toPacket() {
      const buf = StringParser.encode(this.query, this.encoding);
      const length = 5 + buf.length;
      const buffer = Buffer.allocUnsafe(length);
      const packet2 = new Packet(0, buffer, 0, length);
      packet2.offset = 4;
      packet2.writeInt8(CommandCodes.STMT_PREPARE);
      packet2.writeBuffer(buf);
      return packet2;
    }
  }
  prepare_statement = PrepareStatement;
  return prepare_statement;
}
var prepared_statement_header;
var hasRequiredPrepared_statement_header;
function requirePrepared_statement_header() {
  if (hasRequiredPrepared_statement_header) return prepared_statement_header;
  hasRequiredPrepared_statement_header = 1;
  class PreparedStatementHeader {
    constructor(packet2) {
      packet2.skip(1);
      this.id = packet2.readInt32();
      this.fieldCount = packet2.readInt16();
      this.parameterCount = packet2.readInt16();
      packet2.skip(1);
      this.warningCount = packet2.readInt16();
    }
  }
  prepared_statement_header = PreparedStatementHeader;
  return prepared_statement_header;
}
var query$1;
var hasRequiredQuery$1;
function requireQuery$1() {
  if (hasRequiredQuery$1) return query$1;
  hasRequiredQuery$1 = 1;
  const Packet = requirePacket();
  const CommandCode = requireCommands$1();
  const StringParser = requireString();
  const CharsetToEncoding = requireCharset_encodings();
  class Query {
    constructor(sql, charsetNumber) {
      this.query = sql;
      this.charsetNumber = charsetNumber;
      this.encoding = CharsetToEncoding[charsetNumber];
    }
    toPacket() {
      const buf = StringParser.encode(this.query, this.encoding);
      const length = 5 + buf.length;
      const buffer = Buffer.allocUnsafe(length);
      const packet2 = new Packet(0, buffer, 0, length);
      packet2.offset = 4;
      packet2.writeInt8(CommandCode.QUERY);
      packet2.writeBuffer(buf);
      return packet2;
    }
  }
  query$1 = Query;
  return query$1;
}
var register_slave$1;
var hasRequiredRegister_slave$1;
function requireRegister_slave$1() {
  if (hasRequiredRegister_slave$1) return register_slave$1;
  hasRequiredRegister_slave$1 = 1;
  const Packet = requirePacket();
  const CommandCodes = requireCommands$1();
  class RegisterSlave {
    constructor(opts) {
      this.serverId = opts.serverId || 0;
      this.slaveHostname = opts.slaveHostname || "";
      this.slaveUser = opts.slaveUser || "";
      this.slavePassword = opts.slavePassword || "";
      this.slavePort = opts.slavePort || 0;
      this.replicationRank = opts.replicationRank || 0;
      this.masterId = opts.masterId || 0;
    }
    toPacket() {
      const length = 15 + // TODO: should be ascii?
      Buffer.byteLength(this.slaveHostname, "utf8") + Buffer.byteLength(this.slaveUser, "utf8") + Buffer.byteLength(this.slavePassword, "utf8") + 3 + 4;
      const buffer = Buffer.allocUnsafe(length);
      const packet2 = new Packet(0, buffer, 0, length);
      packet2.offset = 4;
      packet2.writeInt8(CommandCodes.REGISTER_SLAVE);
      packet2.writeInt32(this.serverId);
      packet2.writeInt8(Buffer.byteLength(this.slaveHostname, "utf8"));
      packet2.writeString(this.slaveHostname);
      packet2.writeInt8(Buffer.byteLength(this.slaveUser, "utf8"));
      packet2.writeString(this.slaveUser);
      packet2.writeInt8(Buffer.byteLength(this.slavePassword, "utf8"));
      packet2.writeString(this.slavePassword);
      packet2.writeInt16(this.slavePort);
      packet2.writeInt32(this.replicationRank);
      packet2.writeInt32(this.masterId);
      return packet2;
    }
  }
  register_slave$1 = RegisterSlave;
  return register_slave$1;
}
var server_status = {};
var hasRequiredServer_status;
function requireServer_status() {
  if (hasRequiredServer_status) return server_status;
  hasRequiredServer_status = 1;
  server_status.SERVER_STATUS_IN_TRANS = 1;
  server_status.SERVER_STATUS_AUTOCOMMIT = 2;
  server_status.SERVER_MORE_RESULTS_EXISTS = 8;
  server_status.SERVER_QUERY_NO_GOOD_INDEX_USED = 16;
  server_status.SERVER_QUERY_NO_INDEX_USED = 32;
  server_status.SERVER_STATUS_CURSOR_EXISTS = 64;
  server_status.SERVER_STATUS_LAST_ROW_SENT = 128;
  server_status.SERVER_STATUS_DB_DROPPED = 256;
  server_status.SERVER_STATUS_NO_BACKSLASH_ESCAPES = 512;
  server_status.SERVER_STATUS_METADATA_CHANGED = 1024;
  server_status.SERVER_QUERY_WAS_SLOW = 2048;
  server_status.SERVER_PS_OUT_PARAMS = 4096;
  server_status.SERVER_STATUS_IN_TRANS_READONLY = 8192;
  server_status.SERVER_SESSION_STATE_CHANGED = 16384;
  return server_status;
}
var encoding_charset;
var hasRequiredEncoding_charset;
function requireEncoding_charset() {
  if (hasRequiredEncoding_charset) return encoding_charset;
  hasRequiredEncoding_charset = 1;
  encoding_charset = {
    big5: 1,
    latin2: 2,
    dec8: 3,
    cp850: 4,
    latin1: 5,
    hp8: 6,
    koi8r: 7,
    swe7: 10,
    ascii: 11,
    eucjp: 12,
    sjis: 13,
    cp1251: 14,
    hebrew: 16,
    tis620: 18,
    euckr: 19,
    latin7: 20,
    koi8u: 22,
    gb2312: 24,
    greek: 25,
    cp1250: 26,
    gbk: 28,
    cp1257: 29,
    latin5: 30,
    armscii8: 32,
    cesu8: 33,
    ucs2: 35,
    cp866: 36,
    keybcs2: 37,
    macintosh: 38,
    macroman: 39,
    cp852: 40,
    utf8: 45,
    utf8mb4: 45,
    utf16: 54,
    utf16le: 56,
    cp1256: 57,
    utf32: 60,
    binary: 63,
    geostd8: 92,
    cp932: 95,
    eucjpms: 97,
    gb18030: 248,
    utf8mb3: 192
  };
  return encoding_charset;
}
var session_track = {};
var hasRequiredSession_track;
function requireSession_track() {
  if (hasRequiredSession_track) return session_track;
  hasRequiredSession_track = 1;
  (function(exports$1) {
    exports$1.SYSTEM_VARIABLES = 0;
    exports$1.SCHEMA = 1;
    exports$1.STATE_CHANGE = 2;
    exports$1.STATE_GTIDS = 3;
    exports$1.TRANSACTION_CHARACTERISTICS = 4;
    exports$1.TRANSACTION_STATE = 5;
    exports$1.FIRST_KEY = exports$1.SYSTEM_VARIABLES;
    exports$1.LAST_KEY = exports$1.TRANSACTION_STATE;
  })(session_track);
  return session_track;
}
var resultset_header;
var hasRequiredResultset_header;
function requireResultset_header() {
  if (hasRequiredResultset_header) return resultset_header;
  hasRequiredResultset_header = 1;
  const Packet = requirePacket();
  const ClientConstants = requireClient();
  const ServerSatusFlags = requireServer_status();
  const EncodingToCharset = requireEncoding_charset();
  const sessionInfoTypes = requireSession_track();
  class ResultSetHeader {
    constructor(packet2, connection2) {
      const bigNumberStrings = connection2.config.bigNumberStrings;
      const encoding = connection2.serverEncoding;
      const flags = connection2._handshakePacket.capabilityFlags;
      const isSet = function(flag) {
        return flags & ClientConstants[flag];
      };
      if (packet2.buffer[packet2.offset] !== 0) {
        this.fieldCount = packet2.readLengthCodedNumber();
        if (this.fieldCount === null) {
          this.infileName = packet2.readString(void 0, encoding);
        }
        return;
      }
      this.fieldCount = packet2.readInt8();
      this.affectedRows = packet2.readLengthCodedNumber(bigNumberStrings);
      this.insertId = packet2.readLengthCodedNumberSigned(bigNumberStrings);
      this.info = "";
      if (isSet("PROTOCOL_41")) {
        this.serverStatus = packet2.readInt16();
        this.warningStatus = packet2.readInt16();
      } else if (isSet("TRANSACTIONS")) {
        this.serverStatus = packet2.readInt16();
      }
      let stateChanges = null;
      if (isSet("SESSION_TRACK") && packet2.offset < packet2.end) {
        this.info = packet2.readLengthCodedString(encoding);
        if (this.serverStatus && ServerSatusFlags.SERVER_SESSION_STATE_CHANGED) {
          let len = packet2.offset < packet2.end ? packet2.readLengthCodedNumber() : 0;
          const end = packet2.offset + len;
          let type2, key, stateEnd;
          if (len > 0) {
            stateChanges = {
              systemVariables: {},
              schema: null,
              gtids: [],
              trackStateChange: null
            };
          }
          while (packet2.offset < end) {
            type2 = packet2.readInt8();
            len = packet2.readLengthCodedNumber();
            stateEnd = packet2.offset + len;
            if (type2 === sessionInfoTypes.SYSTEM_VARIABLES) {
              key = packet2.readLengthCodedString(encoding);
              const val = packet2.readLengthCodedString(encoding);
              stateChanges.systemVariables[key] = val;
              if (key === "character_set_client") {
                const charsetNumber = EncodingToCharset[val];
                if (typeof charsetNumber !== "undefined") {
                  connection2.config.charsetNumber = charsetNumber;
                }
              }
            } else if (type2 === sessionInfoTypes.SCHEMA) {
              key = packet2.readLengthCodedString(encoding);
              stateChanges.schema = key;
            } else if (type2 === sessionInfoTypes.STATE_CHANGE) {
              stateChanges.trackStateChange = packet2.readLengthCodedString(encoding);
            } else if (type2 === sessionInfoTypes.STATE_GTIDS) {
              packet2.readLengthCodedString(encoding);
              const gtid = packet2.readLengthCodedString(encoding);
              stateChanges.gtids = gtid.split(",");
            } else ;
            packet2.offset = stateEnd;
          }
        }
      } else {
        this.info = packet2.readString(void 0, encoding);
      }
      if (stateChanges) {
        this.stateChanges = stateChanges;
      }
      const m = this.info.match(/\schanged:\s*(\d+)/i);
      if (m !== null) {
        this.changedRows = parseInt(m[1], 10);
      } else {
        this.changedRows = 0;
      }
    }
    // TODO: should be consistent instance member, but it's just easier here to have just function
    static toPacket(fieldCount, insertId) {
      let length = 4 + Packet.lengthCodedNumberLength(fieldCount);
      if (typeof insertId !== "undefined") {
        length += Packet.lengthCodedNumberLength(insertId);
      }
      const buffer = Buffer.allocUnsafe(length);
      const packet2 = new Packet(0, buffer, 0, length);
      packet2.offset = 4;
      packet2.writeLengthCodedNumber(fieldCount);
      if (typeof insertId !== "undefined") {
        packet2.writeLengthCodedNumber(insertId);
      }
      return packet2;
    }
  }
  resultset_header = ResultSetHeader;
  return resultset_header;
}
var ssl_request;
var hasRequiredSsl_request;
function requireSsl_request() {
  if (hasRequiredSsl_request) return ssl_request;
  hasRequiredSsl_request = 1;
  const ClientConstants = requireClient();
  const Packet = requirePacket();
  class SSLRequest {
    constructor(flags, charset) {
      this.clientFlags = flags | ClientConstants.SSL;
      this.charset = charset;
    }
    toPacket() {
      const length = 36;
      const buffer = Buffer.allocUnsafe(length);
      const packet2 = new Packet(0, buffer, 0, length);
      buffer.fill(0);
      packet2.offset = 4;
      packet2.writeInt32(this.clientFlags);
      packet2.writeInt32(0);
      packet2.writeInt8(this.charset);
      return packet2;
    }
  }
  ssl_request = SSLRequest;
  return ssl_request;
}
var text_row;
var hasRequiredText_row;
function requireText_row() {
  if (hasRequiredText_row) return text_row;
  hasRequiredText_row = 1;
  const Packet = requirePacket();
  class TextRow {
    constructor(columns) {
      this.columns = columns || [];
    }
    static fromPacket(packet2) {
      const columns = [];
      while (packet2.haveMoreData()) {
        columns.push(packet2.readLengthCodedString());
      }
      return new TextRow(columns);
    }
    static toPacket(columns, encoding) {
      const sequenceId = 0;
      let length = 0;
      columns.forEach((val) => {
        if (val === null || typeof val === "undefined") {
          ++length;
          return;
        }
        length += Packet.lengthCodedStringLength(val.toString(10), encoding);
      });
      const buffer = Buffer.allocUnsafe(length + 4);
      const packet2 = new Packet(sequenceId, buffer, 0, length + 4);
      packet2.offset = 4;
      columns.forEach((val) => {
        if (val === null) {
          packet2.writeNull();
          return;
        }
        if (typeof val === "undefined") {
          packet2.writeInt8(0);
          return;
        }
        packet2.writeLengthCodedString(val.toString(10), encoding);
      });
      return packet2;
    }
  }
  text_row = TextRow;
  return text_row;
}
var hasRequiredPackets;
function requirePackets() {
  if (hasRequiredPackets) return packets.exports;
  hasRequiredPackets = 1;
  (function(module, exports$1) {
    const process2 = require$$0$6;
    const AuthNextFactor = requireAuth_next_factor();
    const AuthSwitchRequest = requireAuth_switch_request();
    const AuthSwitchRequestMoreData = requireAuth_switch_request_more_data();
    const AuthSwitchResponse = requireAuth_switch_response();
    const BinaryRow = requireBinary_row();
    const BinlogDump = requireBinlog_dump$1();
    const ChangeUser = requireChange_user$1();
    const CloseStatement = requireClose_statement$1();
    const ColumnDefinition = requireColumn_definition();
    const Execute = requireExecute$1();
    const Handshake = requireHandshake();
    const HandshakeResponse = requireHandshake_response();
    const PrepareStatement = requirePrepare_statement();
    const PreparedStatementHeader = requirePrepared_statement_header();
    const Query = requireQuery$1();
    const RegisterSlave = requireRegister_slave$1();
    const ResultSetHeader = requireResultset_header();
    const SSLRequest = requireSsl_request();
    const TextRow = requireText_row();
    const ctorMap = {
      AuthNextFactor,
      AuthSwitchRequest,
      AuthSwitchRequestMoreData,
      AuthSwitchResponse,
      BinaryRow,
      BinlogDump,
      ChangeUser,
      CloseStatement,
      ColumnDefinition,
      Execute,
      Handshake,
      HandshakeResponse,
      PrepareStatement,
      PreparedStatementHeader,
      Query,
      RegisterSlave,
      ResultSetHeader,
      SSLRequest,
      TextRow
    };
    Object.entries(ctorMap).forEach(([name, ctor]) => {
      module.exports[name] = ctor;
      if (process2.env.NODE_DEBUG) {
        if (ctor.prototype.toPacket) {
          const old = ctor.prototype.toPacket;
          ctor.prototype.toPacket = function() {
            const p = old.call(this);
            p._name = name;
            return p;
          };
        }
      }
    });
    const Packet = requirePacket();
    exports$1.Packet = Packet;
    class OK {
      static toPacket(args, encoding) {
        args = args || {};
        const affectedRows = args.affectedRows || 0;
        const insertId = args.insertId || 0;
        const serverStatus = args.serverStatus || 0;
        const warningCount = args.warningCount || 0;
        const message = args.message || "";
        let length = 9 + Packet.lengthCodedNumberLength(affectedRows);
        length += Packet.lengthCodedNumberLength(insertId);
        const buffer = Buffer.allocUnsafe(length);
        const packet2 = new Packet(0, buffer, 0, length);
        packet2.offset = 4;
        packet2.writeInt8(0);
        packet2.writeLengthCodedNumber(affectedRows);
        packet2.writeLengthCodedNumber(insertId);
        packet2.writeInt16(serverStatus);
        packet2.writeInt16(warningCount);
        packet2.writeString(message, encoding);
        packet2._name = "OK";
        return packet2;
      }
    }
    exports$1.OK = OK;
    class EOF {
      static toPacket(warnings, statusFlags) {
        if (typeof warnings === "undefined") {
          warnings = 0;
        }
        if (typeof statusFlags === "undefined") {
          statusFlags = 0;
        }
        const packet2 = new Packet(0, Buffer.allocUnsafe(9), 0, 9);
        packet2.offset = 4;
        packet2.writeInt8(254);
        packet2.writeInt16(warnings);
        packet2.writeInt16(statusFlags);
        packet2._name = "EOF";
        return packet2;
      }
    }
    exports$1.EOF = EOF;
    class Error2 {
      static toPacket(args, encoding) {
        const length = 13 + Buffer.byteLength(args.message, "utf8");
        const packet2 = new Packet(0, Buffer.allocUnsafe(length), 0, length);
        packet2.offset = 4;
        packet2.writeInt8(255);
        packet2.writeInt16(args.code);
        packet2.writeString("#_____", encoding);
        packet2.writeString(args.message, encoding);
        packet2._name = "Error";
        return packet2;
      }
      static fromPacket(packet2) {
        packet2.readInt8();
        const code = packet2.readInt16();
        packet2.readString(1, "ascii");
        packet2.readString(5, "ascii");
        const message = packet2.readNullTerminatedString("utf8");
        const error2 = new Error2();
        error2.message = message;
        error2.code = code;
        return error2;
      }
    }
    exports$1.Error = Error2;
  })(packets, packets.exports);
  return packets.exports;
}
var command;
var hasRequiredCommand;
function requireCommand() {
  if (hasRequiredCommand) return command;
  hasRequiredCommand = 1;
  const EventEmitter = require$$0$3.EventEmitter;
  const Timers = require$$1$8;
  class Command extends EventEmitter {
    constructor() {
      super();
      this.next = null;
    }
    // slow. debug only
    stateName() {
      const state = this.next;
      for (const i in this) {
        if (this[i] === state && i !== "next") {
          return i;
        }
      }
      return "unknown name";
    }
    execute(packet2, connection2) {
      if (!this.next) {
        this.next = this.start;
        connection2._resetSequenceId();
      }
      if (packet2 && packet2.isError()) {
        const err = packet2.asError(connection2.clientEncoding);
        err.sql = this.sql || this.query;
        if (this.queryTimeout) {
          Timers.clearTimeout(this.queryTimeout);
          this.queryTimeout = null;
        }
        if (this.onResult) {
          this.onResult(err);
          this.emit("end");
        } else {
          this.emit("error", err);
          this.emit("end");
        }
        return true;
      }
      this.next = this.next(packet2, connection2);
      if (this.next) {
        return false;
      }
      this.emit("end");
      return true;
    }
  }
  command = Command;
  return command;
}
var sha256_password;
var hasRequiredSha256_password;
function requireSha256_password() {
  if (hasRequiredSha256_password) return sha256_password;
  hasRequiredSha256_password = 1;
  const PLUGIN_NAME = "sha256_password";
  const crypto = require$$0$4;
  const { xorRotating } = requireAuth_41();
  const Tls = require$$2$3;
  const REQUEST_SERVER_KEY_PACKET = Buffer.from([1]);
  const STATE_INITIAL = 0;
  const STATE_WAIT_SERVER_KEY = 1;
  const STATE_FINAL = -1;
  function encrypt(password, scramble, key) {
    const stage1 = xorRotating(Buffer.from(`${password}\0`, "utf8"), scramble);
    return crypto.publicEncrypt(key, stage1);
  }
  sha256_password = (pluginOptions = {}) => ({ connection: connection2 }) => {
    let state = 0;
    let scramble = null;
    const password = connection2.config.password;
    const authWithKey = (serverKey) => {
      const _password = encrypt(password, scramble, serverKey);
      state = STATE_FINAL;
      return _password;
    };
    return (data) => {
      switch (state) {
        case STATE_INITIAL:
          if (connection2.stream instanceof Tls.TLSSocket && connection2.stream.encrypted === true) {
            return Buffer.from(`${password}\0`, "utf8");
          }
          scramble = data.slice(0, 20);
          if (pluginOptions.serverPublicKey) {
            return authWithKey(pluginOptions.serverPublicKey);
          }
          state = STATE_WAIT_SERVER_KEY;
          return REQUEST_SERVER_KEY_PACKET;
        case STATE_WAIT_SERVER_KEY:
          if (pluginOptions.onServerPublicKey) {
            pluginOptions.onServerPublicKey(data);
          }
          return authWithKey(data);
        case STATE_FINAL:
          throw new Error(
            `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_FINAL state.`
          );
      }
      throw new Error(
        `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in state ${state}`
      );
    };
  };
  return sha256_password;
}
var caching_sha2_password;
var hasRequiredCaching_sha2_password;
function requireCaching_sha2_password() {
  if (hasRequiredCaching_sha2_password) return caching_sha2_password;
  hasRequiredCaching_sha2_password = 1;
  const PLUGIN_NAME = "caching_sha2_password";
  const crypto = require$$0$4;
  const { xor, xorRotating } = requireAuth_41();
  const REQUEST_SERVER_KEY_PACKET = Buffer.from([2]);
  const FAST_AUTH_SUCCESS_PACKET = Buffer.from([3]);
  const PERFORM_FULL_AUTHENTICATION_PACKET = Buffer.from([4]);
  const STATE_INITIAL = 0;
  const STATE_TOKEN_SENT = 1;
  const STATE_WAIT_SERVER_KEY = 2;
  const STATE_FINAL = -1;
  function sha256(msg) {
    const hash = crypto.createHash("sha256");
    hash.update(msg);
    return hash.digest();
  }
  function calculateToken(password, scramble) {
    if (!password) {
      return Buffer.alloc(0);
    }
    const stage1 = sha256(Buffer.from(password));
    const stage2 = sha256(stage1);
    const stage3 = sha256(Buffer.concat([stage2, scramble]));
    return xor(stage1, stage3);
  }
  function encrypt(password, scramble, key) {
    const stage1 = xorRotating(Buffer.from(`${password}\0`, "utf8"), scramble);
    return crypto.publicEncrypt(
      {
        key,
        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
      },
      stage1
    );
  }
  caching_sha2_password = (pluginOptions = {}) => ({ connection: connection2 }) => {
    let state = 0;
    let scramble = null;
    const password = connection2.config.password;
    const authWithKey = (serverKey) => {
      const _password = encrypt(password, scramble, serverKey);
      state = STATE_FINAL;
      return _password;
    };
    return (data) => {
      switch (state) {
        case STATE_INITIAL:
          scramble = data.slice(0, 20);
          state = STATE_TOKEN_SENT;
          return calculateToken(password, scramble);
        case STATE_TOKEN_SENT:
          if (FAST_AUTH_SUCCESS_PACKET.equals(data)) {
            state = STATE_FINAL;
            return null;
          }
          if (PERFORM_FULL_AUTHENTICATION_PACKET.equals(data)) {
            const isSecureConnection = typeof pluginOptions.overrideIsSecure === "undefined" ? connection2.config.ssl || connection2.config.socketPath : pluginOptions.overrideIsSecure;
            if (isSecureConnection) {
              state = STATE_FINAL;
              return Buffer.from(`${password}\0`, "utf8");
            }
            if (pluginOptions.serverPublicKey) {
              return authWithKey(pluginOptions.serverPublicKey);
            }
            state = STATE_WAIT_SERVER_KEY;
            return REQUEST_SERVER_KEY_PACKET;
          }
          throw new Error(
            `Invalid AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_TOKEN_SENT state.`
          );
        case STATE_WAIT_SERVER_KEY:
          if (pluginOptions.onServerPublicKey) {
            pluginOptions.onServerPublicKey(data);
          }
          return authWithKey(data);
        case STATE_FINAL:
          throw new Error(
            `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_FINAL state.`
          );
      }
      throw new Error(
        `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in state ${state}`
      );
    };
  };
  return caching_sha2_password;
}
var mysql_native_password;
var hasRequiredMysql_native_password;
function requireMysql_native_password() {
  if (hasRequiredMysql_native_password) return mysql_native_password;
  hasRequiredMysql_native_password = 1;
  const auth41 = requireAuth_41();
  mysql_native_password = (pluginOptions) => ({ connection: connection2, command: command2 }) => {
    const password = command2.password || pluginOptions.password || connection2.config.password;
    const passwordSha1 = command2.passwordSha1 || pluginOptions.passwordSha1 || connection2.config.passwordSha1;
    return (data) => {
      const authPluginData1 = data.slice(0, 8);
      const authPluginData2 = data.slice(8, 20);
      let authToken;
      if (passwordSha1) {
        authToken = auth41.calculateTokenFromPasswordSha(
          passwordSha1,
          authPluginData1,
          authPluginData2
        );
      } else {
        authToken = auth41.calculateToken(
          password,
          authPluginData1,
          authPluginData2
        );
      }
      return authToken;
    };
  };
  return mysql_native_password;
}
var mysql_clear_password;
var hasRequiredMysql_clear_password;
function requireMysql_clear_password() {
  if (hasRequiredMysql_clear_password) return mysql_clear_password;
  hasRequiredMysql_clear_password = 1;
  function bufferFromStr(str2) {
    return Buffer.from(`${str2}\0`);
  }
  const create_mysql_clear_password_plugin = (pluginOptions) => function mysql_clear_password_plugin({ connection: connection2, command: command2 }) {
    const password = command2.password || pluginOptions.password || connection2.config.password;
    return function() {
      return bufferFromStr(password);
    };
  };
  mysql_clear_password = create_mysql_clear_password_plugin;
  return mysql_clear_password;
}
var auth_switch;
var hasRequiredAuth_switch;
function requireAuth_switch() {
  if (hasRequiredAuth_switch) return auth_switch;
  hasRequiredAuth_switch = 1;
  const Packets = requirePackets();
  const sha256_password2 = requireSha256_password();
  const caching_sha2_password2 = requireCaching_sha2_password();
  const mysql_native_password2 = requireMysql_native_password();
  const mysql_clear_password2 = requireMysql_clear_password();
  const standardAuthPlugins = {
    sha256_password: sha256_password2({}),
    caching_sha2_password: caching_sha2_password2({}),
    mysql_native_password: mysql_native_password2({}),
    mysql_clear_password: mysql_clear_password2({})
  };
  function warnLegacyAuthSwitch() {
    console.warn(
      "WARNING! authSwitchHandler api is deprecated, please use new authPlugins api"
    );
  }
  function authSwitchPluginError(error2, command2) {
    error2.code = "AUTH_SWITCH_PLUGIN_ERROR";
    error2.fatal = true;
    command2.emit("error", error2);
  }
  function authSwitchRequest(packet2, connection2, command2) {
    const { pluginName, pluginData } = Packets.AuthSwitchRequest.fromPacket(packet2);
    let authPlugin = connection2.config.authPlugins && connection2.config.authPlugins[pluginName];
    if (connection2.config.authSwitchHandler && pluginName !== "mysql_native_password") {
      const legacySwitchHandler = connection2.config.authSwitchHandler;
      warnLegacyAuthSwitch();
      legacySwitchHandler({ pluginName, pluginData }, (err, data) => {
        if (err) {
          return authSwitchPluginError(err, command2);
        }
        connection2.writePacket(new Packets.AuthSwitchResponse(data).toPacket());
      });
      return;
    }
    if (!authPlugin) {
      authPlugin = standardAuthPlugins[pluginName];
    }
    if (!authPlugin) {
      throw new Error(
        `Server requests authentication using unknown plugin ${pluginName}. See ${"TODO: add plugins doco here"} on how to configure or author authentication plugins.`
      );
    }
    connection2._authPlugin = authPlugin({ connection: connection2, command: command2 });
    Promise.resolve(connection2._authPlugin(pluginData)).then((data) => {
      if (data) {
        connection2.writePacket(new Packets.AuthSwitchResponse(data).toPacket());
      }
    }).catch((err) => {
      authSwitchPluginError(err, command2);
    });
  }
  function authSwitchRequestMoreData(packet2, connection2, command2) {
    const { data } = Packets.AuthSwitchRequestMoreData.fromPacket(packet2);
    if (connection2.config.authSwitchHandler) {
      const legacySwitchHandler = connection2.config.authSwitchHandler;
      warnLegacyAuthSwitch();
      legacySwitchHandler({ pluginData: data }, (err, data2) => {
        if (err) {
          return authSwitchPluginError(err, command2);
        }
        connection2.writePacket(new Packets.AuthSwitchResponse(data2).toPacket());
      });
      return;
    }
    if (!connection2._authPlugin) {
      throw new Error(
        "AuthPluginMoreData received but no auth plugin instance found"
      );
    }
    Promise.resolve(connection2._authPlugin(data)).then((data2) => {
      if (data2) {
        connection2.writePacket(new Packets.AuthSwitchResponse(data2).toPacket());
      }
    }).catch((err) => {
      authSwitchPluginError(err, command2);
    });
  }
  auth_switch = {
    authSwitchRequest,
    authSwitchRequestMoreData
  };
  return auth_switch;
}
var seqQueue$1 = { exports: {} };
var hasRequiredSeqQueue$1;
function requireSeqQueue$1() {
  if (hasRequiredSeqQueue$1) return seqQueue$1.exports;
  hasRequiredSeqQueue$1 = 1;
  (function(module) {
    var EventEmitter = require$$0$3.EventEmitter;
    var util2 = require$$1$1;
    var DEFAULT_TIMEOUT = 3e3;
    var INIT_ID = 0;
    var EVENT_CLOSED = "closed";
    var EVENT_DRAINED = "drained";
    var SeqQueue = function(timeout) {
      EventEmitter.call(this);
      if (timeout && timeout > 0) {
        this.timeout = timeout;
      } else {
        this.timeout = DEFAULT_TIMEOUT;
      }
      this.status = SeqQueueManager.STATUS_IDLE;
      this.curId = INIT_ID;
      this.queue = [];
    };
    util2.inherits(SeqQueue, EventEmitter);
    SeqQueue.prototype.push = function(fn, ontimeout, timeout) {
      if (this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {
        return false;
      }
      if (typeof fn !== "function") {
        throw new Error("fn should be a function.");
      }
      this.queue.push({ fn, ontimeout, timeout });
      if (this.status === SeqQueueManager.STATUS_IDLE) {
        this.status = SeqQueueManager.STATUS_BUSY;
        var self2 = this;
        process.nextTick(function() {
          self2._next(self2.curId);
        });
      }
      return true;
    };
    SeqQueue.prototype.close = function(force) {
      if (this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {
        return;
      }
      if (force) {
        this.status = SeqQueueManager.STATUS_DRAINED;
        if (this.timerId) {
          clearTimeout(this.timerId);
          this.timerId = void 0;
        }
        this.emit(EVENT_DRAINED);
      } else {
        this.status = SeqQueueManager.STATUS_CLOSED;
        this.emit(EVENT_CLOSED);
      }
    };
    SeqQueue.prototype._next = function(tid) {
      if (tid !== this.curId || this.status !== SeqQueueManager.STATUS_BUSY && this.status !== SeqQueueManager.STATUS_CLOSED) {
        return;
      }
      if (this.timerId) {
        clearTimeout(this.timerId);
        this.timerId = void 0;
      }
      var task = this.queue.shift();
      if (!task) {
        if (this.status === SeqQueueManager.STATUS_BUSY) {
          this.status = SeqQueueManager.STATUS_IDLE;
          this.curId++;
        } else {
          this.status = SeqQueueManager.STATUS_DRAINED;
          this.emit(EVENT_DRAINED);
        }
        return;
      }
      var self2 = this;
      task.id = ++this.curId;
      var timeout = task.timeout > 0 ? task.timeout : this.timeout;
      timeout = timeout > 0 ? timeout : DEFAULT_TIMEOUT;
      this.timerId = setTimeout(function() {
        process.nextTick(function() {
          self2._next(task.id);
        });
        self2.emit("timeout", task);
        if (task.ontimeout) {
          task.ontimeout();
        }
      }, timeout);
      try {
        task.fn({
          done: function() {
            var res = task.id === self2.curId;
            process.nextTick(function() {
              self2._next(task.id);
            });
            return res;
          }
        });
      } catch (err) {
        self2.emit("error", err, task);
        process.nextTick(function() {
          self2._next(task.id);
        });
      }
    };
    var SeqQueueManager = module.exports;
    SeqQueueManager.STATUS_IDLE = 0;
    SeqQueueManager.STATUS_BUSY = 1;
    SeqQueueManager.STATUS_CLOSED = 2;
    SeqQueueManager.STATUS_DRAINED = 3;
    SeqQueueManager.createQueue = function(timeout) {
      return new SeqQueue(timeout);
    };
  })(seqQueue$1);
  return seqQueue$1.exports;
}
var seqQueue;
var hasRequiredSeqQueue;
function requireSeqQueue() {
  if (hasRequiredSeqQueue) return seqQueue;
  hasRequiredSeqQueue = 1;
  seqQueue = requireSeqQueue$1();
  return seqQueue;
}
var compressed_protocol;
var hasRequiredCompressed_protocol;
function requireCompressed_protocol() {
  if (hasRequiredCompressed_protocol) return compressed_protocol;
  hasRequiredCompressed_protocol = 1;
  const zlib = require$$14;
  const PacketParser = requirePacket_parser();
  function handleCompressedPacket(packet2) {
    const connection2 = this;
    const deflatedLength = packet2.readInt24();
    const body = packet2.readBuffer();
    if (deflatedLength !== 0) {
      connection2.inflateQueue.push((task) => {
        zlib.inflate(body, (err, data) => {
          if (err) {
            connection2._handleNetworkError(err);
            return;
          }
          connection2._bumpCompressedSequenceId(packet2.numPackets);
          connection2._inflatedPacketsParser.execute(data);
          task.done();
        });
      });
    } else {
      connection2.inflateQueue.push((task) => {
        connection2._bumpCompressedSequenceId(packet2.numPackets);
        connection2._inflatedPacketsParser.execute(body);
        task.done();
      });
    }
  }
  function writeCompressed(buffer) {
    const MAX_COMPRESSED_LENGTH = 16777210;
    let start;
    if (buffer.length > MAX_COMPRESSED_LENGTH) {
      for (start = 0; start < buffer.length; start += MAX_COMPRESSED_LENGTH) {
        writeCompressed.call(
          // eslint-disable-next-line no-invalid-this
          this,
          buffer.slice(start, start + MAX_COMPRESSED_LENGTH)
        );
      }
      return;
    }
    const connection2 = this;
    let packetLen = buffer.length;
    const compressHeader = Buffer.allocUnsafe(7);
    (function(seqId) {
      connection2.deflateQueue.push((task) => {
        zlib.deflate(buffer, (err, compressed) => {
          if (err) {
            connection2._handleFatalError(err);
            return;
          }
          let compressedLength = compressed.length;
          if (compressedLength < packetLen) {
            compressHeader.writeUInt8(compressedLength & 255, 0);
            compressHeader.writeUInt16LE(compressedLength >> 8, 1);
            compressHeader.writeUInt8(seqId, 3);
            compressHeader.writeUInt8(packetLen & 255, 4);
            compressHeader.writeUInt16LE(packetLen >> 8, 5);
            connection2.writeUncompressed(compressHeader);
            connection2.writeUncompressed(compressed);
          } else {
            compressedLength = packetLen;
            packetLen = 0;
            compressHeader.writeUInt8(compressedLength & 255, 0);
            compressHeader.writeUInt16LE(compressedLength >> 8, 1);
            compressHeader.writeUInt8(seqId, 3);
            compressHeader.writeUInt8(packetLen & 255, 4);
            compressHeader.writeUInt16LE(packetLen >> 8, 5);
            connection2.writeUncompressed(compressHeader);
            connection2.writeUncompressed(buffer);
          }
          task.done();
        });
      });
    })(connection2.compressedSequenceId);
    connection2._bumpCompressedSequenceId(1);
  }
  function enableCompression(connection2) {
    connection2._lastWrittenPacketId = 0;
    connection2._lastReceivedPacketId = 0;
    connection2._handleCompressedPacket = handleCompressedPacket;
    connection2._inflatedPacketsParser = new PacketParser((p) => {
      connection2.handlePacket(p);
    }, 4);
    connection2._inflatedPacketsParser._lastPacket = 0;
    connection2.packetParser = new PacketParser((packet2) => {
      connection2._handleCompressedPacket(packet2);
    }, 7);
    connection2.writeUncompressed = connection2.write;
    connection2.write = writeCompressed;
    const seqqueue = requireSeqQueue();
    connection2.inflateQueue = seqqueue.createQueue();
    connection2.deflateQueue = seqqueue.createQueue();
  }
  compressed_protocol = {
    enableCompression
  };
  return compressed_protocol;
}
var client_handshake;
var hasRequiredClient_handshake;
function requireClient_handshake() {
  if (hasRequiredClient_handshake) return client_handshake;
  hasRequiredClient_handshake = 1;
  const Command = requireCommand();
  const Packets = requirePackets();
  const ClientConstants = requireClient();
  const CharsetToEncoding = requireCharset_encodings();
  const auth41 = requireAuth_41();
  function flagNames(flags) {
    const res = [];
    for (const c in ClientConstants) {
      if (flags & ClientConstants[c]) {
        res.push(c.replace(/_/g, " ").toLowerCase());
      }
    }
    return res;
  }
  class ClientHandshake extends Command {
    constructor(clientFlags) {
      super();
      this.handshake = null;
      this.clientFlags = clientFlags;
      this.authenticationFactor = 0;
    }
    start() {
      return ClientHandshake.prototype.handshakeInit;
    }
    sendSSLRequest(connection2) {
      const sslRequest = new Packets.SSLRequest(
        this.clientFlags,
        connection2.config.charsetNumber
      );
      connection2.writePacket(sslRequest.toPacket());
    }
    sendCredentials(connection2) {
      if (connection2.config.debug) {
        console.log(
          "Sending handshake packet: flags:%d=(%s)",
          this.clientFlags,
          flagNames(this.clientFlags).join(", ")
        );
      }
      this.user = connection2.config.user;
      this.password = connection2.config.password;
      this.password1 = connection2.config.password;
      this.password2 = connection2.config.password2;
      this.password3 = connection2.config.password3;
      this.passwordSha1 = connection2.config.passwordSha1;
      this.database = connection2.config.database;
      this.authPluginName = this.handshake.authPluginName;
      const handshakeResponse = new Packets.HandshakeResponse({
        flags: this.clientFlags,
        user: this.user,
        database: this.database,
        password: this.password,
        passwordSha1: this.passwordSha1,
        charsetNumber: connection2.config.charsetNumber,
        authPluginData1: this.handshake.authPluginData1,
        authPluginData2: this.handshake.authPluginData2,
        compress: connection2.config.compress,
        connectAttributes: connection2.config.connectAttributes
      });
      connection2.writePacket(handshakeResponse.toPacket());
    }
    calculateNativePasswordAuthToken(authPluginData) {
      const authPluginData1 = authPluginData.slice(0, 8);
      const authPluginData2 = authPluginData.slice(8, 20);
      let authToken;
      if (this.passwordSha1) {
        authToken = auth41.calculateTokenFromPasswordSha(
          this.passwordSha1,
          authPluginData1,
          authPluginData2
        );
      } else {
        authToken = auth41.calculateToken(
          this.password,
          authPluginData1,
          authPluginData2
        );
      }
      return authToken;
    }
    handshakeInit(helloPacket, connection2) {
      this.on("error", (e) => {
        connection2._fatalError = e;
        connection2._protocolError = e;
      });
      this.handshake = Packets.Handshake.fromPacket(helloPacket);
      if (connection2.config.debug) {
        console.log(
          "Server hello packet: capability flags:%d=(%s)",
          this.handshake.capabilityFlags,
          flagNames(this.handshake.capabilityFlags).join(", ")
        );
      }
      connection2.serverCapabilityFlags = this.handshake.capabilityFlags;
      connection2.serverEncoding = CharsetToEncoding[this.handshake.characterSet];
      connection2.connectionId = this.handshake.connectionId;
      const serverSSLSupport = this.handshake.capabilityFlags & ClientConstants.SSL;
      const multiFactorAuthentication = this.handshake.capabilityFlags & ClientConstants.MULTI_FACTOR_AUTHENTICATION;
      this.clientFlags = this.clientFlags | multiFactorAuthentication;
      connection2.config.compress = connection2.config.compress && this.handshake.capabilityFlags & ClientConstants.COMPRESS;
      this.clientFlags = this.clientFlags | connection2.config.compress;
      if (connection2.config.ssl) {
        if (!serverSSLSupport) {
          const err = new Error("Server does not support secure connection");
          err.code = "HANDSHAKE_NO_SSL_SUPPORT";
          err.fatal = true;
          this.emit("error", err);
          return false;
        }
        this.clientFlags |= ClientConstants.SSL;
        this.sendSSLRequest(connection2);
        connection2.startTLS((err) => {
          if (err) {
            err.code = "HANDSHAKE_SSL_ERROR";
            err.fatal = true;
            this.emit("error", err);
            return;
          }
          this.sendCredentials(connection2);
        });
      } else {
        this.sendCredentials(connection2);
      }
      if (multiFactorAuthentication) {
        this.authenticationFactor = 1;
      }
      return ClientHandshake.prototype.handshakeResult;
    }
    handshakeResult(packet2, connection2) {
      const marker = packet2.peekByte();
      if (marker === 254 || marker === 1 || marker === 2) {
        const authSwitch = requireAuth_switch();
        try {
          if (marker === 1) {
            authSwitch.authSwitchRequestMoreData(packet2, connection2, this);
          } else {
            if (this.authenticationFactor !== 0) {
              connection2.config.password = this[`password${this.authenticationFactor}`];
              this.authenticationFactor += 1;
            }
            authSwitch.authSwitchRequest(packet2, connection2, this);
          }
          return ClientHandshake.prototype.handshakeResult;
        } catch (err) {
          err.code = "AUTH_SWITCH_PLUGIN_ERROR";
          err.fatal = true;
          if (this.onResult) {
            this.onResult(err);
          } else {
            this.emit("error", err);
          }
          return null;
        }
      }
      if (marker !== 0) {
        const err = new Error("Unexpected packet during handshake phase");
        err.code = "HANDSHAKE_UNKNOWN_ERROR";
        err.fatal = true;
        if (this.onResult) {
          this.onResult(err);
        } else {
          this.emit("error", err);
        }
        return null;
      }
      if (!connection2.authorized) {
        connection2.authorized = true;
        if (connection2.config.compress) {
          const enableCompression = requireCompressed_protocol().enableCompression;
          enableCompression(connection2);
        }
      }
      if (this.onResult) {
        this.onResult(null);
      }
      return null;
    }
  }
  client_handshake = ClientHandshake;
  return client_handshake;
}
var server_handshake;
var hasRequiredServer_handshake;
function requireServer_handshake() {
  if (hasRequiredServer_handshake) return server_handshake;
  hasRequiredServer_handshake = 1;
  const CommandCode = requireCommands$1();
  const Errors = requireErrors();
  const Command = requireCommand();
  const Packets = requirePackets();
  class ServerHandshake extends Command {
    constructor(args) {
      super();
      this.args = args;
    }
    start(packet2, connection2) {
      const serverHelloPacket = new Packets.Handshake(this.args);
      this.serverHello = serverHelloPacket;
      serverHelloPacket.setScrambleData((err) => {
        if (err) {
          connection2.emit("error", new Error("Error generating random bytes"));
          return;
        }
        connection2.writePacket(serverHelloPacket.toPacket(0));
      });
      return ServerHandshake.prototype.readClientReply;
    }
    readClientReply(packet2, connection2) {
      const clientHelloReply = Packets.HandshakeResponse.fromPacket(packet2);
      connection2.clientHelloReply = clientHelloReply;
      if (this.args.authCallback) {
        this.args.authCallback(
          {
            user: clientHelloReply.user,
            database: clientHelloReply.database,
            address: connection2.stream.remoteAddress,
            authPluginData1: this.serverHello.authPluginData1,
            authPluginData2: this.serverHello.authPluginData2,
            authToken: clientHelloReply.authToken
          },
          (err, mysqlError) => {
            if (!mysqlError) {
              connection2.writeOk();
            } else {
              connection2.writeError({
                message: mysqlError.message || "",
                code: mysqlError.code || 1045
              });
              connection2.close();
            }
          }
        );
      } else {
        connection2.writeOk();
      }
      return ServerHandshake.prototype.dispatchCommands;
    }
    _isStatement(query2, name) {
      const firstWord = query2.split(" ")[0].toUpperCase();
      return firstWord === name;
    }
    dispatchCommands(packet2, connection2) {
      let knownCommand = true;
      const encoding = connection2.clientHelloReply.encoding;
      const commandCode = packet2.readInt8();
      switch (commandCode) {
        case CommandCode.STMT_PREPARE:
          if (connection2.listeners("stmt_prepare").length) {
            const query2 = packet2.readString(void 0, encoding);
            connection2.emit("stmt_prepare", query2);
          } else {
            connection2.writeError({
              code: Errors.HA_ERR_INTERNAL_ERROR,
              message: "No query handler for prepared statements."
            });
          }
          break;
        case CommandCode.STMT_EXECUTE:
          if (connection2.listeners("stmt_execute").length) {
            const { stmtId, flags, iterationCount, values } = Packets.Execute.fromPacket(packet2, encoding);
            connection2.emit(
              "stmt_execute",
              stmtId,
              flags,
              iterationCount,
              values
            );
          } else {
            connection2.writeError({
              code: Errors.HA_ERR_INTERNAL_ERROR,
              message: "No query handler for execute statements."
            });
          }
          break;
        case CommandCode.QUIT:
          if (connection2.listeners("quit").length) {
            connection2.emit("quit");
          } else {
            connection2.stream.end();
          }
          break;
        case CommandCode.INIT_DB:
          if (connection2.listeners("init_db").length) {
            const schemaName = packet2.readString(void 0, encoding);
            connection2.emit("init_db", schemaName);
          } else {
            connection2.writeOk();
          }
          break;
        case CommandCode.QUERY:
          if (connection2.listeners("query").length) {
            const query2 = packet2.readString(void 0, encoding);
            if (this._isStatement(query2, "PREPARE") || this._isStatement(query2, "SET")) {
              connection2.emit("stmt_prepare", query2);
            } else if (this._isStatement(query2, "EXECUTE")) {
              connection2.emit("stmt_execute", null, null, null, null, query2);
            } else connection2.emit("query", query2);
          } else {
            connection2.writeError({
              code: Errors.HA_ERR_INTERNAL_ERROR,
              message: "No query handler"
            });
          }
          break;
        case CommandCode.FIELD_LIST:
          if (connection2.listeners("field_list").length) {
            const table = packet2.readNullTerminatedString(encoding);
            const fields = packet2.readString(void 0, encoding);
            connection2.emit("field_list", table, fields);
          } else {
            connection2.writeError({
              code: Errors.ER_WARN_DEPRECATED_SYNTAX,
              message: "As of MySQL 5.7.11, COM_FIELD_LIST is deprecated and will be removed in a future version of MySQL."
            });
          }
          break;
        case CommandCode.PING:
          if (connection2.listeners("ping").length) {
            connection2.emit("ping");
          } else {
            connection2.writeOk();
          }
          break;
        default:
          knownCommand = false;
      }
      if (connection2.listeners("packet").length) {
        connection2.emit("packet", packet2.clone(), knownCommand, commandCode);
      } else if (!knownCommand) {
        console.log("Unknown command:", commandCode);
      }
      return ServerHandshake.prototype.dispatchCommands;
    }
  }
  server_handshake = ServerHandshake;
  return server_handshake;
}
var charsets = {};
var hasRequiredCharsets;
function requireCharsets() {
  if (hasRequiredCharsets) return charsets;
  hasRequiredCharsets = 1;
  (function(exports$1) {
    exports$1.BIG5_CHINESE_CI = 1;
    exports$1.LATIN2_CZECH_CS = 2;
    exports$1.DEC8_SWEDISH_CI = 3;
    exports$1.CP850_GENERAL_CI = 4;
    exports$1.LATIN1_GERMAN1_CI = 5;
    exports$1.HP8_ENGLISH_CI = 6;
    exports$1.KOI8R_GENERAL_CI = 7;
    exports$1.LATIN1_SWEDISH_CI = 8;
    exports$1.LATIN2_GENERAL_CI = 9;
    exports$1.SWE7_SWEDISH_CI = 10;
    exports$1.ASCII_GENERAL_CI = 11;
    exports$1.UJIS_JAPANESE_CI = 12;
    exports$1.SJIS_JAPANESE_CI = 13;
    exports$1.CP1251_BULGARIAN_CI = 14;
    exports$1.LATIN1_DANISH_CI = 15;
    exports$1.HEBREW_GENERAL_CI = 16;
    exports$1.TIS620_THAI_CI = 18;
    exports$1.EUCKR_KOREAN_CI = 19;
    exports$1.LATIN7_ESTONIAN_CS = 20;
    exports$1.LATIN2_HUNGARIAN_CI = 21;
    exports$1.KOI8U_GENERAL_CI = 22;
    exports$1.CP1251_UKRAINIAN_CI = 23;
    exports$1.GB2312_CHINESE_CI = 24;
    exports$1.GREEK_GENERAL_CI = 25;
    exports$1.CP1250_GENERAL_CI = 26;
    exports$1.LATIN2_CROATIAN_CI = 27;
    exports$1.GBK_CHINESE_CI = 28;
    exports$1.CP1257_LITHUANIAN_CI = 29;
    exports$1.LATIN5_TURKISH_CI = 30;
    exports$1.LATIN1_GERMAN2_CI = 31;
    exports$1.ARMSCII8_GENERAL_CI = 32;
    exports$1.UTF8_GENERAL_CI = 33;
    exports$1.CP1250_CZECH_CS = 34;
    exports$1.UCS2_GENERAL_CI = 35;
    exports$1.CP866_GENERAL_CI = 36;
    exports$1.KEYBCS2_GENERAL_CI = 37;
    exports$1.MACCE_GENERAL_CI = 38;
    exports$1.MACROMAN_GENERAL_CI = 39;
    exports$1.CP852_GENERAL_CI = 40;
    exports$1.LATIN7_GENERAL_CI = 41;
    exports$1.LATIN7_GENERAL_CS = 42;
    exports$1.MACCE_BIN = 43;
    exports$1.CP1250_CROATIAN_CI = 44;
    exports$1.UTF8MB4_GENERAL_CI = 45;
    exports$1.UTF8MB4_BIN = 46;
    exports$1.LATIN1_BIN = 47;
    exports$1.LATIN1_GENERAL_CI = 48;
    exports$1.LATIN1_GENERAL_CS = 49;
    exports$1.CP1251_BIN = 50;
    exports$1.CP1251_GENERAL_CI = 51;
    exports$1.CP1251_GENERAL_CS = 52;
    exports$1.MACROMAN_BIN = 53;
    exports$1.UTF16_GENERAL_CI = 54;
    exports$1.UTF16_BIN = 55;
    exports$1.UTF16LE_GENERAL_CI = 56;
    exports$1.CP1256_GENERAL_CI = 57;
    exports$1.CP1257_BIN = 58;
    exports$1.CP1257_GENERAL_CI = 59;
    exports$1.UTF32_GENERAL_CI = 60;
    exports$1.UTF32_BIN = 61;
    exports$1.UTF16LE_BIN = 62;
    exports$1.BINARY = 63;
    exports$1.ARMSCII8_BIN = 64;
    exports$1.ASCII_BIN = 65;
    exports$1.CP1250_BIN = 66;
    exports$1.CP1256_BIN = 67;
    exports$1.CP866_BIN = 68;
    exports$1.DEC8_BIN = 69;
    exports$1.GREEK_BIN = 70;
    exports$1.HEBREW_BIN = 71;
    exports$1.HP8_BIN = 72;
    exports$1.KEYBCS2_BIN = 73;
    exports$1.KOI8R_BIN = 74;
    exports$1.KOI8U_BIN = 75;
    exports$1.UTF8_TOLOWER_CI = 76;
    exports$1.LATIN2_BIN = 77;
    exports$1.LATIN5_BIN = 78;
    exports$1.LATIN7_BIN = 79;
    exports$1.CP850_BIN = 80;
    exports$1.CP852_BIN = 81;
    exports$1.SWE7_BIN = 82;
    exports$1.UTF8_BIN = 83;
    exports$1.BIG5_BIN = 84;
    exports$1.EUCKR_BIN = 85;
    exports$1.GB2312_BIN = 86;
    exports$1.GBK_BIN = 87;
    exports$1.SJIS_BIN = 88;
    exports$1.TIS620_BIN = 89;
    exports$1.UCS2_BIN = 90;
    exports$1.UJIS_BIN = 91;
    exports$1.GEOSTD8_GENERAL_CI = 92;
    exports$1.GEOSTD8_BIN = 93;
    exports$1.LATIN1_SPANISH_CI = 94;
    exports$1.CP932_JAPANESE_CI = 95;
    exports$1.CP932_BIN = 96;
    exports$1.EUCJPMS_JAPANESE_CI = 97;
    exports$1.EUCJPMS_BIN = 98;
    exports$1.CP1250_POLISH_CI = 99;
    exports$1.UTF16_UNICODE_CI = 101;
    exports$1.UTF16_ICELANDIC_CI = 102;
    exports$1.UTF16_LATVIAN_CI = 103;
    exports$1.UTF16_ROMANIAN_CI = 104;
    exports$1.UTF16_SLOVENIAN_CI = 105;
    exports$1.UTF16_POLISH_CI = 106;
    exports$1.UTF16_ESTONIAN_CI = 107;
    exports$1.UTF16_SPANISH_CI = 108;
    exports$1.UTF16_SWEDISH_CI = 109;
    exports$1.UTF16_TURKISH_CI = 110;
    exports$1.UTF16_CZECH_CI = 111;
    exports$1.UTF16_DANISH_CI = 112;
    exports$1.UTF16_LITHUANIAN_CI = 113;
    exports$1.UTF16_SLOVAK_CI = 114;
    exports$1.UTF16_SPANISH2_CI = 115;
    exports$1.UTF16_ROMAN_CI = 116;
    exports$1.UTF16_PERSIAN_CI = 117;
    exports$1.UTF16_ESPERANTO_CI = 118;
    exports$1.UTF16_HUNGARIAN_CI = 119;
    exports$1.UTF16_SINHALA_CI = 120;
    exports$1.UTF16_GERMAN2_CI = 121;
    exports$1.UTF16_CROATIAN_CI = 122;
    exports$1.UTF16_UNICODE_520_CI = 123;
    exports$1.UTF16_VIETNAMESE_CI = 124;
    exports$1.UCS2_UNICODE_CI = 128;
    exports$1.UCS2_ICELANDIC_CI = 129;
    exports$1.UCS2_LATVIAN_CI = 130;
    exports$1.UCS2_ROMANIAN_CI = 131;
    exports$1.UCS2_SLOVENIAN_CI = 132;
    exports$1.UCS2_POLISH_CI = 133;
    exports$1.UCS2_ESTONIAN_CI = 134;
    exports$1.UCS2_SPANISH_CI = 135;
    exports$1.UCS2_SWEDISH_CI = 136;
    exports$1.UCS2_TURKISH_CI = 137;
    exports$1.UCS2_CZECH_CI = 138;
    exports$1.UCS2_DANISH_CI = 139;
    exports$1.UCS2_LITHUANIAN_CI = 140;
    exports$1.UCS2_SLOVAK_CI = 141;
    exports$1.UCS2_SPANISH2_CI = 142;
    exports$1.UCS2_ROMAN_CI = 143;
    exports$1.UCS2_PERSIAN_CI = 144;
    exports$1.UCS2_ESPERANTO_CI = 145;
    exports$1.UCS2_HUNGARIAN_CI = 146;
    exports$1.UCS2_SINHALA_CI = 147;
    exports$1.UCS2_GERMAN2_CI = 148;
    exports$1.UCS2_CROATIAN_CI = 149;
    exports$1.UCS2_UNICODE_520_CI = 150;
    exports$1.UCS2_VIETNAMESE_CI = 151;
    exports$1.UCS2_GENERAL_MYSQL500_CI = 159;
    exports$1.UTF32_UNICODE_CI = 160;
    exports$1.UTF32_ICELANDIC_CI = 161;
    exports$1.UTF32_LATVIAN_CI = 162;
    exports$1.UTF32_ROMANIAN_CI = 163;
    exports$1.UTF32_SLOVENIAN_CI = 164;
    exports$1.UTF32_POLISH_CI = 165;
    exports$1.UTF32_ESTONIAN_CI = 166;
    exports$1.UTF32_SPANISH_CI = 167;
    exports$1.UTF32_SWEDISH_CI = 168;
    exports$1.UTF32_TURKISH_CI = 169;
    exports$1.UTF32_CZECH_CI = 170;
    exports$1.UTF32_DANISH_CI = 171;
    exports$1.UTF32_LITHUANIAN_CI = 172;
    exports$1.UTF32_SLOVAK_CI = 173;
    exports$1.UTF32_SPANISH2_CI = 174;
    exports$1.UTF32_ROMAN_CI = 175;
    exports$1.UTF32_PERSIAN_CI = 176;
    exports$1.UTF32_ESPERANTO_CI = 177;
    exports$1.UTF32_HUNGARIAN_CI = 178;
    exports$1.UTF32_SINHALA_CI = 179;
    exports$1.UTF32_GERMAN2_CI = 180;
    exports$1.UTF32_CROATIAN_CI = 181;
    exports$1.UTF32_UNICODE_520_CI = 182;
    exports$1.UTF32_VIETNAMESE_CI = 183;
    exports$1.UTF8_UNICODE_CI = 192;
    exports$1.UTF8_ICELANDIC_CI = 193;
    exports$1.UTF8_LATVIAN_CI = 194;
    exports$1.UTF8_ROMANIAN_CI = 195;
    exports$1.UTF8_SLOVENIAN_CI = 196;
    exports$1.UTF8_POLISH_CI = 197;
    exports$1.UTF8_ESTONIAN_CI = 198;
    exports$1.UTF8_SPANISH_CI = 199;
    exports$1.UTF8_SWEDISH_CI = 200;
    exports$1.UTF8_TURKISH_CI = 201;
    exports$1.UTF8_CZECH_CI = 202;
    exports$1.UTF8_DANISH_CI = 203;
    exports$1.UTF8_LITHUANIAN_CI = 204;
    exports$1.UTF8_SLOVAK_CI = 205;
    exports$1.UTF8_SPANISH2_CI = 206;
    exports$1.UTF8_ROMAN_CI = 207;
    exports$1.UTF8_PERSIAN_CI = 208;
    exports$1.UTF8_ESPERANTO_CI = 209;
    exports$1.UTF8_HUNGARIAN_CI = 210;
    exports$1.UTF8_SINHALA_CI = 211;
    exports$1.UTF8_GERMAN2_CI = 212;
    exports$1.UTF8_CROATIAN_CI = 213;
    exports$1.UTF8_UNICODE_520_CI = 214;
    exports$1.UTF8_VIETNAMESE_CI = 215;
    exports$1.UTF8_GENERAL_MYSQL500_CI = 223;
    exports$1.UTF8MB4_UNICODE_CI = 224;
    exports$1.UTF8MB4_ICELANDIC_CI = 225;
    exports$1.UTF8MB4_LATVIAN_CI = 226;
    exports$1.UTF8MB4_ROMANIAN_CI = 227;
    exports$1.UTF8MB4_SLOVENIAN_CI = 228;
    exports$1.UTF8MB4_POLISH_CI = 229;
    exports$1.UTF8MB4_ESTONIAN_CI = 230;
    exports$1.UTF8MB4_SPANISH_CI = 231;
    exports$1.UTF8MB4_SWEDISH_CI = 232;
    exports$1.UTF8MB4_TURKISH_CI = 233;
    exports$1.UTF8MB4_CZECH_CI = 234;
    exports$1.UTF8MB4_DANISH_CI = 235;
    exports$1.UTF8MB4_LITHUANIAN_CI = 236;
    exports$1.UTF8MB4_SLOVAK_CI = 237;
    exports$1.UTF8MB4_SPANISH2_CI = 238;
    exports$1.UTF8MB4_ROMAN_CI = 239;
    exports$1.UTF8MB4_PERSIAN_CI = 240;
    exports$1.UTF8MB4_ESPERANTO_CI = 241;
    exports$1.UTF8MB4_HUNGARIAN_CI = 242;
    exports$1.UTF8MB4_SINHALA_CI = 243;
    exports$1.UTF8MB4_GERMAN2_CI = 244;
    exports$1.UTF8MB4_CROATIAN_CI = 245;
    exports$1.UTF8MB4_UNICODE_520_CI = 246;
    exports$1.UTF8MB4_VIETNAMESE_CI = 247;
    exports$1.GB18030_CHINESE_CI = 248;
    exports$1.GB18030_BIN = 249;
    exports$1.GB18030_UNICODE_520_CI = 250;
    exports$1.UTF8_GENERAL50_CI = 253;
    exports$1.UTF8MB4_0900_AI_CI = 255;
    exports$1.UTF8MB4_DE_PB_0900_AI_CI = 256;
    exports$1.UTF8MB4_IS_0900_AI_CI = 257;
    exports$1.UTF8MB4_LV_0900_AI_CI = 258;
    exports$1.UTF8MB4_RO_0900_AI_CI = 259;
    exports$1.UTF8MB4_SL_0900_AI_CI = 260;
    exports$1.UTF8MB4_PL_0900_AI_CI = 261;
    exports$1.UTF8MB4_ET_0900_AI_CI = 262;
    exports$1.UTF8MB4_ES_0900_AI_CI = 263;
    exports$1.UTF8MB4_SV_0900_AI_CI = 264;
    exports$1.UTF8MB4_TR_0900_AI_CI = 265;
    exports$1.UTF8MB4_CS_0900_AI_CI = 266;
    exports$1.UTF8MB4_DA_0900_AI_CI = 267;
    exports$1.UTF8MB4_LT_0900_AI_CI = 268;
    exports$1.UTF8MB4_SK_0900_AI_CI = 269;
    exports$1.UTF8MB4_ES_TRAD_0900_AI_CI = 270;
    exports$1.UTF8MB4_LA_0900_AI_CI = 271;
    exports$1.UTF8MB4_EO_0900_AI_CI = 273;
    exports$1.UTF8MB4_HU_0900_AI_CI = 274;
    exports$1.UTF8MB4_HR_0900_AI_CI = 275;
    exports$1.UTF8MB4_VI_0900_AI_CI = 277;
    exports$1.UTF8MB4_0900_AS_CS = 278;
    exports$1.UTF8MB4_DE_PB_0900_AS_CS = 279;
    exports$1.UTF8MB4_IS_0900_AS_CS = 280;
    exports$1.UTF8MB4_LV_0900_AS_CS = 281;
    exports$1.UTF8MB4_RO_0900_AS_CS = 282;
    exports$1.UTF8MB4_SL_0900_AS_CS = 283;
    exports$1.UTF8MB4_PL_0900_AS_CS = 284;
    exports$1.UTF8MB4_ET_0900_AS_CS = 285;
    exports$1.UTF8MB4_ES_0900_AS_CS = 286;
    exports$1.UTF8MB4_SV_0900_AS_CS = 287;
    exports$1.UTF8MB4_TR_0900_AS_CS = 288;
    exports$1.UTF8MB4_CS_0900_AS_CS = 289;
    exports$1.UTF8MB4_DA_0900_AS_CS = 290;
    exports$1.UTF8MB4_LT_0900_AS_CS = 291;
    exports$1.UTF8MB4_SK_0900_AS_CS = 292;
    exports$1.UTF8MB4_ES_TRAD_0900_AS_CS = 293;
    exports$1.UTF8MB4_LA_0900_AS_CS = 294;
    exports$1.UTF8MB4_EO_0900_AS_CS = 296;
    exports$1.UTF8MB4_HU_0900_AS_CS = 297;
    exports$1.UTF8MB4_HR_0900_AS_CS = 298;
    exports$1.UTF8MB4_VI_0900_AS_CS = 300;
    exports$1.UTF8MB4_JA_0900_AS_CS = 303;
    exports$1.UTF8MB4_JA_0900_AS_CS_KS = 304;
    exports$1.UTF8MB4_0900_AS_CI = 305;
    exports$1.UTF8MB4_RU_0900_AI_CI = 306;
    exports$1.UTF8MB4_RU_0900_AS_CS = 307;
    exports$1.UTF8MB4_ZH_0900_AS_CS = 308;
    exports$1.UTF8MB4_0900_BIN = 309;
    exports$1.BIG5 = exports$1.BIG5_CHINESE_CI;
    exports$1.DEC8 = exports$1.DEC8_SWEDISH_CI;
    exports$1.CP850 = exports$1.CP850_GENERAL_CI;
    exports$1.HP8 = exports$1.HP8_ENGLISH_CI;
    exports$1.KOI8R = exports$1.KOI8R_GENERAL_CI;
    exports$1.LATIN1 = exports$1.LATIN1_SWEDISH_CI;
    exports$1.LATIN2 = exports$1.LATIN2_GENERAL_CI;
    exports$1.SWE7 = exports$1.SWE7_SWEDISH_CI;
    exports$1.ASCII = exports$1.ASCII_GENERAL_CI;
    exports$1.UJIS = exports$1.UJIS_JAPANESE_CI;
    exports$1.SJIS = exports$1.SJIS_JAPANESE_CI;
    exports$1.HEBREW = exports$1.HEBREW_GENERAL_CI;
    exports$1.TIS620 = exports$1.TIS620_THAI_CI;
    exports$1.EUCKR = exports$1.EUCKR_KOREAN_CI;
    exports$1.KOI8U = exports$1.KOI8U_GENERAL_CI;
    exports$1.GB2312 = exports$1.GB2312_CHINESE_CI;
    exports$1.GREEK = exports$1.GREEK_GENERAL_CI;
    exports$1.CP1250 = exports$1.CP1250_GENERAL_CI;
    exports$1.GBK = exports$1.GBK_CHINESE_CI;
    exports$1.LATIN5 = exports$1.LATIN5_TURKISH_CI;
    exports$1.ARMSCII8 = exports$1.ARMSCII8_GENERAL_CI;
    exports$1.UTF8 = exports$1.UTF8_GENERAL_CI;
    exports$1.UCS2 = exports$1.UCS2_GENERAL_CI;
    exports$1.CP866 = exports$1.CP866_GENERAL_CI;
    exports$1.KEYBCS2 = exports$1.KEYBCS2_GENERAL_CI;
    exports$1.MACCE = exports$1.MACCE_GENERAL_CI;
    exports$1.MACROMAN = exports$1.MACROMAN_GENERAL_CI;
    exports$1.CP852 = exports$1.CP852_GENERAL_CI;
    exports$1.LATIN7 = exports$1.LATIN7_GENERAL_CI;
    exports$1.UTF8MB4 = exports$1.UTF8MB4_GENERAL_CI;
    exports$1.CP1251 = exports$1.CP1251_GENERAL_CI;
    exports$1.UTF16 = exports$1.UTF16_GENERAL_CI;
    exports$1.UTF16LE = exports$1.UTF16LE_GENERAL_CI;
    exports$1.CP1256 = exports$1.CP1256_GENERAL_CI;
    exports$1.CP1257 = exports$1.CP1257_GENERAL_CI;
    exports$1.UTF32 = exports$1.UTF32_GENERAL_CI;
    exports$1.CP932 = exports$1.CP932_JAPANESE_CI;
    exports$1.EUCJPMS = exports$1.EUCJPMS_JAPANESE_CI;
    exports$1.GB18030 = exports$1.GB18030_CHINESE_CI;
    exports$1.GEOSTD8 = exports$1.GEOSTD8_GENERAL_CI;
  })(charsets);
  return charsets;
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var helpers = {};
var hasRequiredHelpers;
function requireHelpers() {
  if (hasRequiredHelpers) return helpers;
  hasRequiredHelpers = 1;
  function srcEscape(str2) {
    return JSON.stringify({
      [str2]: 1
    }).slice(1, -3);
  }
  helpers.srcEscape = srcEscape;
  let highlightFn;
  let cardinalRecommended = false;
  try {
    const REQUIRE_TERMINATOR = "";
    highlightFn = commonjsRequire(`cardinal${REQUIRE_TERMINATOR}`).highlight;
  } catch {
    highlightFn = (text) => {
      if (!cardinalRecommended) {
        console.log("For nicer debug output consider install cardinal@^2.0.0");
        cardinalRecommended = true;
      }
      return text;
    };
  }
  function printDebugWithCode(msg, code) {
    console.log(`

${msg}:
`);
    console.log(`${highlightFn(code)}
`);
  }
  helpers.printDebugWithCode = printDebugWithCode;
  function typeMatch(type2, list, Types) {
    if (Array.isArray(list)) {
      return list.some((t) => type2 === Types[t]);
    }
    return !!list;
  }
  helpers.typeMatch = typeMatch;
  const privateObjectProps = /* @__PURE__ */ new Set([
    "__defineGetter__",
    "__defineSetter__",
    "__lookupGetter__",
    "__lookupSetter__",
    "__proto__"
  ]);
  helpers.privateObjectProps = privateObjectProps;
  const fieldEscape = (field, isEval = true) => {
    if (privateObjectProps.has(field)) {
      throw new Error(
        `The field name (${field}) can't be the same as an object's private property.`
      );
    }
    return isEval ? srcEscape(field) : field;
  };
  helpers.fieldEscape = fieldEscape;
  return helpers;
}
var isProperty_1;
var hasRequiredIsProperty;
function requireIsProperty() {
  if (hasRequiredIsProperty) return isProperty_1;
  hasRequiredIsProperty = 1;
  function isProperty(str2) {
    return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str2);
  }
  isProperty_1 = isProperty;
  return isProperty_1;
}
var generateFunction;
var hasRequiredGenerateFunction;
function requireGenerateFunction() {
  if (hasRequiredGenerateFunction) return generateFunction;
  hasRequiredGenerateFunction = 1;
  var util2 = require$$1$1;
  var isProperty = requireIsProperty();
  var INDENT_START = /[\{\[]/;
  var INDENT_END = /[\}\]]/;
  var RESERVED = [
    "do",
    "if",
    "in",
    "for",
    "let",
    "new",
    "try",
    "var",
    "case",
    "else",
    "enum",
    "eval",
    "null",
    "this",
    "true",
    "void",
    "with",
    "await",
    "break",
    "catch",
    "class",
    "const",
    "false",
    "super",
    "throw",
    "while",
    "yield",
    "delete",
    "export",
    "import",
    "public",
    "return",
    "static",
    "switch",
    "typeof",
    "default",
    "extends",
    "finally",
    "package",
    "private",
    "continue",
    "debugger",
    "function",
    "arguments",
    "interface",
    "protected",
    "implements",
    "instanceof",
    "NaN",
    "undefined"
  ];
  var RESERVED_MAP = {};
  for (var i = 0; i < RESERVED.length; i++) {
    RESERVED_MAP[RESERVED[i]] = true;
  }
  var isVariable = function(name) {
    return isProperty(name) && !RESERVED_MAP.hasOwnProperty(name);
  };
  var formats = {
    s: function(s) {
      return "" + s;
    },
    d: function(d) {
      return "" + Number(d);
    },
    o: function(o) {
      return JSON.stringify(o);
    }
  };
  var genfun = function() {
    var lines = [];
    var indent = 0;
    var vars = {};
    var push = function(str2) {
      var spaces = "";
      while (spaces.length < indent * 2) spaces += "  ";
      lines.push(spaces + str2);
    };
    var pushLine = function(line2) {
      if (INDENT_END.test(line2.trim()[0]) && INDENT_START.test(line2[line2.length - 1])) {
        indent--;
        push(line2);
        indent++;
        return;
      }
      if (INDENT_START.test(line2[line2.length - 1])) {
        push(line2);
        indent++;
        return;
      }
      if (INDENT_END.test(line2.trim()[0])) {
        indent--;
        push(line2);
        return;
      }
      push(line2);
    };
    var line = function(fmt) {
      if (!fmt) return line;
      if (arguments.length === 1 && fmt.indexOf("\n") > -1) {
        var lines2 = fmt.trim().split("\n");
        for (var i2 = 0; i2 < lines2.length; i2++) {
          pushLine(lines2[i2].trim());
        }
      } else {
        pushLine(util2.format.apply(util2, arguments));
      }
      return line;
    };
    line.scope = {};
    line.formats = formats;
    line.sym = function(name) {
      if (!name || !isVariable(name)) name = "tmp";
      if (!vars[name]) vars[name] = 0;
      return name + (vars[name]++ || "");
    };
    line.property = function(obj, name) {
      if (arguments.length === 1) {
        name = obj;
        obj = "";
      }
      name = name + "";
      if (isProperty(name)) return obj ? obj + "." + name : name;
      return obj ? obj + "[" + JSON.stringify(name) + "]" : JSON.stringify(name);
    };
    line.toString = function() {
      return lines.join("\n");
    };
    line.toFunction = function(scope) {
      if (!scope) scope = {};
      var src2 = "return (" + line.toString() + ")";
      Object.keys(line.scope).forEach(function(key) {
        if (!scope[key]) scope[key] = line.scope[key];
      });
      var keys = Object.keys(scope).map(function(key) {
        return key;
      });
      var vals = keys.map(function(key) {
        return scope[key];
      });
      return Function.apply(null, keys.concat(src2)).apply(null, vals);
    };
    if (arguments.length) line.apply(null, arguments);
    return line;
  };
  genfun.formats = formats;
  generateFunction = genfun;
  return generateFunction;
}
var text_parser;
var hasRequiredText_parser;
function requireText_parser() {
  if (hasRequiredText_parser) return text_parser;
  hasRequiredText_parser = 1;
  const Types = requireTypes();
  const Charsets = requireCharsets();
  const helpers2 = requireHelpers();
  const genFunc = requireGenerateFunction();
  const parserCache = requireParser_cache();
  const typeNames = [];
  for (const t in Types) {
    typeNames[Types[t]] = t;
  }
  function readCodeFor(type2, charset, encodingExpr, config, options) {
    const supportBigNumbers = Boolean(
      options.supportBigNumbers || config.supportBigNumbers
    );
    const bigNumberStrings = Boolean(
      options.bigNumberStrings || config.bigNumberStrings
    );
    const timezone = options.timezone || config.timezone;
    const dateStrings = options.dateStrings || config.dateStrings;
    switch (type2) {
      case Types.TINY:
      case Types.SHORT:
      case Types.LONG:
      case Types.INT24:
      case Types.YEAR:
        return "packet.parseLengthCodedIntNoBigCheck()";
      case Types.LONGLONG:
        if (supportBigNumbers && bigNumberStrings) {
          return "packet.parseLengthCodedIntString()";
        }
        return `packet.parseLengthCodedInt(${supportBigNumbers})`;
      case Types.FLOAT:
      case Types.DOUBLE:
        return "packet.parseLengthCodedFloat()";
      case Types.NULL:
        return "packet.readLengthCodedNumber()";
      case Types.DECIMAL:
      case Types.NEWDECIMAL:
        if (config.decimalNumbers) {
          return "packet.parseLengthCodedFloat()";
        }
        return 'packet.readLengthCodedString("ascii")';
      case Types.DATE:
        if (helpers2.typeMatch(type2, dateStrings, Types)) {
          return 'packet.readLengthCodedString("ascii")';
        }
        return `packet.parseDate(${helpers2.srcEscape(timezone)})`;
      case Types.DATETIME:
      case Types.TIMESTAMP:
        if (helpers2.typeMatch(type2, dateStrings, Types)) {
          return 'packet.readLengthCodedString("ascii")';
        }
        return `packet.parseDateTime(${helpers2.srcEscape(timezone)})`;
      case Types.TIME:
        return 'packet.readLengthCodedString("ascii")';
      case Types.GEOMETRY:
        return "packet.parseGeometryValue()";
      case Types.VECTOR:
        return "packet.parseVector()";
      case Types.JSON:
        return config.jsonStrings ? 'packet.readLengthCodedString("utf8")' : 'JSON.parse(packet.readLengthCodedString("utf8"))';
      default:
        if (charset === Charsets.BINARY) {
          return "packet.readLengthCodedBuffer()";
        }
        return `packet.readLengthCodedString(${encodingExpr})`;
    }
  }
  function compile(fields, options, config) {
    if (typeof config.typeCast === "function" && typeof options.typeCast !== "function") {
      options.typeCast = config.typeCast;
    }
    function wrap(field, _this) {
      return {
        type: typeNames[field.columnType],
        length: field.columnLength,
        db: field.schema,
        table: field.table,
        name: field.name,
        string: function(encoding = field.encoding) {
          if (field.columnType === Types.JSON && encoding === field.encoding) {
            console.warn(
              `typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``
            );
          }
          return _this.packet.readLengthCodedString(encoding);
        },
        buffer: function() {
          return _this.packet.readLengthCodedBuffer();
        },
        geometry: function() {
          return _this.packet.parseGeometryValue();
        }
      };
    }
    const parserFn = genFunc();
    parserFn("(function () {")("return class TextRow {");
    parserFn("constructor(fields) {");
    if (typeof options.typeCast === "function") {
      parserFn("const _this = this;");
      parserFn("for(let i=0; i<fields.length; ++i) {");
      parserFn("this[`wrap${i}`] = wrap(fields[i], _this);");
      parserFn("}");
    }
    parserFn("}");
    parserFn("next(packet, fields, options) {");
    parserFn("this.packet = packet;");
    if (options.rowsAsArray) {
      parserFn(`const result = new Array(${fields.length});`);
    } else {
      parserFn("const result = {};");
    }
    const resultTables = {};
    let resultTablesArray = [];
    if (options.nestTables === true) {
      for (let i = 0; i < fields.length; i++) {
        resultTables[fields[i].table] = 1;
      }
      resultTablesArray = Object.keys(resultTables);
      for (let i = 0; i < resultTablesArray.length; i++) {
        parserFn(`result[${helpers2.fieldEscape(resultTablesArray[i])}] = {};`);
      }
    }
    let lvalue = "";
    let fieldName = "";
    let tableName = "";
    for (let i = 0; i < fields.length; i++) {
      fieldName = helpers2.fieldEscape(fields[i].name);
      if (typeof options.nestTables === "string") {
        lvalue = `result[${helpers2.fieldEscape(fields[i].table + options.nestTables + fields[i].name)}]`;
      } else if (options.nestTables === true) {
        tableName = helpers2.fieldEscape(fields[i].table);
        parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);
        lvalue = `result[${tableName}][${fieldName}]`;
      } else if (options.rowsAsArray) {
        lvalue = `result[${i.toString(10)}]`;
      } else {
        lvalue = `result[${fieldName}]`;
      }
      if (options.typeCast === false) {
        parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);
      } else {
        const encodingExpr = `fields[${i}].encoding`;
        const readCode = readCodeFor(
          fields[i].columnType,
          fields[i].characterSet,
          encodingExpr,
          config,
          options
        );
        if (typeof options.typeCast === "function") {
          parserFn(
            `${lvalue} = options.typeCast(this.wrap${i}, function() { return ${readCode} });`
          );
        } else {
          parserFn(`${lvalue} = ${readCode};`);
        }
      }
    }
    parserFn("return result;");
    parserFn("}");
    parserFn("};")("})()");
    if (config.debug) {
      helpers2.printDebugWithCode(
        "Compiled text protocol row parser",
        parserFn.toString()
      );
    }
    if (typeof options.typeCast === "function") {
      return parserFn.toFunction({ wrap });
    }
    return parserFn.toFunction();
  }
  function getTextParser(fields, options, config) {
    return parserCache.getParser("text", fields, options, config, compile);
  }
  text_parser = getTextParser;
  return text_parser;
}
var static_text_parser;
var hasRequiredStatic_text_parser;
function requireStatic_text_parser() {
  if (hasRequiredStatic_text_parser) return static_text_parser;
  hasRequiredStatic_text_parser = 1;
  const Types = requireTypes();
  const Charsets = requireCharsets();
  const helpers2 = requireHelpers();
  const typeNames = [];
  for (const t in Types) {
    typeNames[Types[t]] = t;
  }
  function readField({ packet: packet2, type: type2, charset, encoding, config, options }) {
    const supportBigNumbers = Boolean(
      options.supportBigNumbers || config.supportBigNumbers
    );
    const bigNumberStrings = Boolean(
      options.bigNumberStrings || config.bigNumberStrings
    );
    const timezone = options.timezone || config.timezone;
    const dateStrings = options.dateStrings || config.dateStrings;
    switch (type2) {
      case Types.TINY:
      case Types.SHORT:
      case Types.LONG:
      case Types.INT24:
      case Types.YEAR:
        return packet2.parseLengthCodedIntNoBigCheck();
      case Types.LONGLONG:
        if (supportBigNumbers && bigNumberStrings) {
          return packet2.parseLengthCodedIntString();
        }
        return packet2.parseLengthCodedInt(supportBigNumbers);
      case Types.FLOAT:
      case Types.DOUBLE:
        return packet2.parseLengthCodedFloat();
      case Types.NULL:
      case Types.DECIMAL:
      case Types.NEWDECIMAL:
        if (config.decimalNumbers) {
          return packet2.parseLengthCodedFloat();
        }
        return packet2.readLengthCodedString("ascii");
      case Types.DATE:
        if (helpers2.typeMatch(type2, dateStrings, Types)) {
          return packet2.readLengthCodedString("ascii");
        }
        return packet2.parseDate(timezone);
      case Types.DATETIME:
      case Types.TIMESTAMP:
        if (helpers2.typeMatch(type2, dateStrings, Types)) {
          return packet2.readLengthCodedString("ascii");
        }
        return packet2.parseDateTime(timezone);
      case Types.TIME:
        return packet2.readLengthCodedString("ascii");
      case Types.GEOMETRY:
        return packet2.parseGeometryValue();
      case Types.VECTOR:
        return packet2.parseVector();
      case Types.JSON:
        return config.jsonStrings ? packet2.readLengthCodedString("utf8") : JSON.parse(packet2.readLengthCodedString("utf8"));
      default:
        if (charset === Charsets.BINARY) {
          return packet2.readLengthCodedBuffer();
        }
        return packet2.readLengthCodedString(encoding);
    }
  }
  function createTypecastField(field, packet2) {
    return {
      type: typeNames[field.columnType],
      length: field.columnLength,
      db: field.schema,
      table: field.table,
      name: field.name,
      string: function(encoding = field.encoding) {
        if (field.columnType === Types.JSON && encoding === field.encoding) {
          console.warn(
            `typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``
          );
        }
        return packet2.readLengthCodedString(encoding);
      },
      buffer: function() {
        return packet2.readLengthCodedBuffer();
      },
      geometry: function() {
        return packet2.parseGeometryValue();
      }
    };
  }
  function getTextParser(_fields, _options, config) {
    return {
      next(packet2, fields, options) {
        const result = options.rowsAsArray ? [] : {};
        for (let i = 0; i < fields.length; i++) {
          const field = fields[i];
          const typeCast = options.typeCast ? options.typeCast : config.typeCast;
          const next = () => readField({
            packet: packet2,
            type: field.columnType,
            encoding: field.encoding,
            charset: field.characterSet,
            config,
            options
          });
          let value;
          if (options.typeCast === false) {
            value = packet2.readLengthCodedBuffer();
          } else if (typeof typeCast === "function") {
            value = typeCast(createTypecastField(field, packet2), next);
          } else {
            value = next();
          }
          if (options.rowsAsArray) {
            result.push(value);
          } else if (typeof options.nestTables === "string") {
            result[`${helpers2.fieldEscape(field.table, false)}${options.nestTables}${helpers2.fieldEscape(field.name, false)}`] = value;
          } else if (options.nestTables) {
            const tableName = helpers2.fieldEscape(field.table, false);
            if (!result[tableName]) {
              result[tableName] = {};
            }
            result[tableName][helpers2.fieldEscape(field.name, false)] = value;
          } else {
            result[helpers2.fieldEscape(field.name, false)] = value;
          }
        }
        return result;
      }
    };
  }
  static_text_parser = getTextParser;
  return static_text_parser;
}
var query;
var hasRequiredQuery;
function requireQuery() {
  if (hasRequiredQuery) return query;
  hasRequiredQuery = 1;
  const process2 = require$$0$6;
  const Timers = require$$1$8;
  const Readable = require$$0$2.Readable;
  const Command = requireCommand();
  const Packets = requirePackets();
  const getTextParser = requireText_parser();
  const staticParser = requireStatic_text_parser();
  const ServerStatus = requireServer_status();
  const EmptyPacket = new Packets.Packet(0, Buffer.allocUnsafe(4), 0, 4);
  class Query extends Command {
    constructor(options, callback) {
      super();
      this.sql = options.sql;
      this.values = options.values;
      this._queryOptions = options;
      this.namedPlaceholders = options.namedPlaceholders || false;
      this.onResult = callback;
      this.timeout = options.timeout;
      this.queryTimeout = null;
      this._fieldCount = 0;
      this._rowParser = null;
      this._fields = [];
      this._rows = [];
      this._receivedFieldsCount = 0;
      this._resultIndex = 0;
      this._localStream = null;
      this._unpipeStream = function() {
      };
      this._streamFactory = options.infileStreamFactory;
      this._connection = null;
    }
    then() {
      const err = "You have tried to call .then(), .catch(), or invoked await on the result of query that is not a promise, which is a programming error. Try calling con.promise().query(), or require('mysql2/promise') instead of 'mysql2' for a promise-compatible version of the query interface. To learn how to use async/await or Promises check out documentation at https://sidorares.github.io/node-mysql2/docs#using-promise-wrapper, or the mysql2 documentation at https://sidorares.github.io/node-mysql2/docs/documentation/promise-wrapper";
      console.log(err);
      throw new Error(err);
    }
    /* eslint no-unused-vars: ["error", { "argsIgnorePattern": "^_" }] */
    start(_packet, connection2) {
      if (connection2.config.debug) {
        console.log("        Sending query command: %s", this.sql);
      }
      this._connection = connection2;
      this.options = Object.assign({}, connection2.config, this._queryOptions);
      this._setTimeout();
      const cmdPacket = new Packets.Query(
        this.sql,
        connection2.config.charsetNumber
      );
      connection2.writePacket(cmdPacket.toPacket(1));
      return Query.prototype.resultsetHeader;
    }
    done() {
      this._unpipeStream();
      if (this.timeout && !this.queryTimeout) {
        return null;
      }
      if (this.queryTimeout) {
        Timers.clearTimeout(this.queryTimeout);
        this.queryTimeout = null;
      }
      if (this.onResult) {
        let rows, fields;
        if (this._resultIndex === 0) {
          rows = this._rows[0];
          fields = this._fields[0];
        } else {
          rows = this._rows;
          fields = this._fields;
        }
        if (fields) {
          process2.nextTick(() => {
            this.onResult(null, rows, fields);
          });
        } else {
          process2.nextTick(() => {
            this.onResult(null, rows);
          });
        }
      }
      return null;
    }
    doneInsert(rs) {
      if (this._localStreamError) {
        if (this.onResult) {
          this.onResult(this._localStreamError, rs);
        } else {
          this.emit("error", this._localStreamError);
        }
        return null;
      }
      this._rows.push(rs);
      this._fields.push(void 0);
      this.emit("fields", void 0);
      this.emit("result", rs);
      if (rs.serverStatus & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {
        this._resultIndex++;
        return this.resultsetHeader;
      }
      return this.done();
    }
    resultsetHeader(packet2, connection2) {
      const rs = new Packets.ResultSetHeader(packet2, connection2);
      this._fieldCount = rs.fieldCount;
      if (connection2.config.debug) {
        console.log(
          `        Resultset header received, expecting ${rs.fieldCount} column definition packets`
        );
      }
      if (this._fieldCount === 0) {
        return this.doneInsert(rs);
      }
      if (this._fieldCount === null) {
        return this._streamLocalInfile(connection2, rs.infileName);
      }
      this._receivedFieldsCount = 0;
      this._rows.push([]);
      this._fields.push([]);
      return this.readField;
    }
    _streamLocalInfile(connection2, path) {
      if (this._streamFactory) {
        this._localStream = this._streamFactory(path);
      } else {
        this._localStreamError = new Error(
          `As a result of LOCAL INFILE command server wants to read ${path} file, but as of v2.0 you must provide streamFactory option returning ReadStream.`
        );
        connection2.writePacket(EmptyPacket);
        return this.infileOk;
      }
      const onConnectionError = () => {
        this._unpipeStream();
      };
      const onDrain = () => {
        this._localStream.resume();
      };
      const onPause = () => {
        this._localStream.pause();
      };
      const onData = function(data) {
        const dataWithHeader = Buffer.allocUnsafe(data.length + 4);
        data.copy(dataWithHeader, 4);
        connection2.writePacket(
          new Packets.Packet(0, dataWithHeader, 0, dataWithHeader.length)
        );
      };
      const onEnd = () => {
        connection2.removeListener("error", onConnectionError);
        connection2.writePacket(EmptyPacket);
      };
      const onError = (err) => {
        this._localStreamError = err;
        connection2.removeListener("error", onConnectionError);
        connection2.writePacket(EmptyPacket);
      };
      this._unpipeStream = () => {
        connection2.stream.removeListener("pause", onPause);
        connection2.stream.removeListener("drain", onDrain);
        this._localStream.removeListener("data", onData);
        this._localStream.removeListener("end", onEnd);
        this._localStream.removeListener("error", onError);
      };
      connection2.stream.on("pause", onPause);
      connection2.stream.on("drain", onDrain);
      this._localStream.on("data", onData);
      this._localStream.on("end", onEnd);
      this._localStream.on("error", onError);
      connection2.once("error", onConnectionError);
      return this.infileOk;
    }
    readField(packet2, connection2) {
      this._receivedFieldsCount++;
      if (this._fields[this._resultIndex].length !== this._fieldCount) {
        const field = new Packets.ColumnDefinition(
          packet2,
          connection2.clientEncoding
        );
        this._fields[this._resultIndex].push(field);
        if (connection2.config.debug) {
          console.log("        Column definition:");
          console.log(`          name: ${field.name}`);
          console.log(`          type: ${field.columnType}`);
          console.log(`         flags: ${field.flags}`);
        }
      }
      if (this._receivedFieldsCount === this._fieldCount) {
        const fields = this._fields[this._resultIndex];
        this.emit("fields", fields);
        if (this.options.disableEval) {
          this._rowParser = staticParser(fields, this.options, connection2.config);
        } else {
          this._rowParser = new (getTextParser(
            fields,
            this.options,
            connection2.config
          ))(fields);
        }
        return Query.prototype.fieldsEOF;
      }
      return Query.prototype.readField;
    }
    fieldsEOF(packet2, connection2) {
      if (!packet2.isEOF()) {
        return connection2.protocolError("Expected EOF packet");
      }
      return this.row;
    }
    row(packet2, _connection) {
      if (packet2.isEOF()) {
        const status = packet2.eofStatusFlags();
        const moreResults = status & ServerStatus.SERVER_MORE_RESULTS_EXISTS;
        if (moreResults) {
          this._resultIndex++;
          return Query.prototype.resultsetHeader;
        }
        return this.done();
      }
      let row;
      try {
        row = this._rowParser.next(
          packet2,
          this._fields[this._resultIndex],
          this.options
        );
      } catch (err) {
        this._localStreamError = err;
        return this.doneInsert(null);
      }
      if (this.onResult) {
        this._rows[this._resultIndex].push(row);
      } else {
        this.emit("result", row, this._resultIndex);
      }
      return Query.prototype.row;
    }
    infileOk(packet2, connection2) {
      const rs = new Packets.ResultSetHeader(packet2, connection2);
      return this.doneInsert(rs);
    }
    stream(options) {
      options = options || /* @__PURE__ */ Object.create(null);
      options.objectMode = true;
      const stream = new Readable({
        ...options,
        emitClose: true,
        autoDestroy: true,
        read: () => {
          this._connection && this._connection.resume();
        }
      });
      stream.once("close", () => {
        if (!stream.readableEnded) {
          stream.emit("end");
        }
      });
      const onResult = (row, index) => {
        if (stream.destroyed) return;
        if (!stream.push(row)) {
          this._connection && this._connection.pause();
        }
        stream.emit("result", row, index);
      };
      const onFields = (fields) => {
        if (stream.destroyed) return;
        stream.emit("fields", fields);
      };
      const onEnd = () => {
        if (stream.destroyed) return;
        stream.push(null);
      };
      const onError = (err) => {
        stream.destroy(err);
      };
      stream._destroy = (err, cb) => {
        this._connection && this._connection.resume();
        this.removeListener("result", onResult);
        this.removeListener("fields", onFields);
        this.removeListener("end", onEnd);
        this.removeListener("error", onError);
        cb(err);
      };
      this.on("result", onResult);
      this.on("fields", onFields);
      this.on("end", onEnd);
      this.on("error", onError);
      return stream;
    }
    _setTimeout() {
      if (this.timeout) {
        const timeoutHandler = this._handleTimeoutError.bind(this);
        this.queryTimeout = Timers.setTimeout(timeoutHandler, this.timeout);
      }
    }
    _handleTimeoutError() {
      if (this.queryTimeout) {
        Timers.clearTimeout(this.queryTimeout);
        this.queryTimeout = null;
      }
      const err = new Error("Query inactivity timeout");
      err.errorno = "PROTOCOL_SEQUENCE_TIMEOUT";
      err.code = "PROTOCOL_SEQUENCE_TIMEOUT";
      err.syscall = "query";
      if (this.onResult) {
        this.onResult(err);
      } else {
        this.emit("error", err);
      }
    }
  }
  Query.prototype.catch = Query.prototype.then;
  query = Query;
  return query;
}
var close_statement;
var hasRequiredClose_statement;
function requireClose_statement() {
  if (hasRequiredClose_statement) return close_statement;
  hasRequiredClose_statement = 1;
  const Command = requireCommand();
  const Packets = requirePackets();
  class CloseStatement extends Command {
    constructor(id) {
      super();
      this.id = id;
    }
    start(packet2, connection2) {
      connection2.writePacket(new Packets.CloseStatement(this.id).toPacket(1));
      return null;
    }
  }
  close_statement = CloseStatement;
  return close_statement;
}
var binary_parser;
var hasRequiredBinary_parser;
function requireBinary_parser() {
  if (hasRequiredBinary_parser) return binary_parser;
  hasRequiredBinary_parser = 1;
  const FieldFlags = requireField_flags();
  const Charsets = requireCharsets();
  const Types = requireTypes();
  const helpers2 = requireHelpers();
  const genFunc = requireGenerateFunction();
  const parserCache = requireParser_cache();
  const typeNames = [];
  for (const t in Types) {
    typeNames[Types[t]] = t;
  }
  function readCodeFor(field, config, options, fieldNum) {
    const supportBigNumbers = Boolean(
      options.supportBigNumbers || config.supportBigNumbers
    );
    const bigNumberStrings = Boolean(
      options.bigNumberStrings || config.bigNumberStrings
    );
    const timezone = options.timezone || config.timezone;
    const dateStrings = options.dateStrings || config.dateStrings;
    const unsigned = field.flags & FieldFlags.UNSIGNED;
    switch (field.columnType) {
      case Types.TINY:
        return unsigned ? "packet.readInt8();" : "packet.readSInt8();";
      case Types.SHORT:
        return unsigned ? "packet.readInt16();" : "packet.readSInt16();";
      case Types.LONG:
      case Types.INT24:
        return unsigned ? "packet.readInt32();" : "packet.readSInt32();";
      case Types.YEAR:
        return "packet.readInt16()";
      case Types.FLOAT:
        return "packet.readFloat();";
      case Types.DOUBLE:
        return "packet.readDouble();";
      case Types.NULL:
        return "null;";
      case Types.DATE:
      case Types.DATETIME:
      case Types.TIMESTAMP:
      case Types.NEWDATE:
        if (helpers2.typeMatch(field.columnType, dateStrings, Types)) {
          return `packet.readDateTimeString(${parseInt(field.decimals, 10)}, ${null}, ${field.columnType});`;
        }
        return `packet.readDateTime(${helpers2.srcEscape(timezone)});`;
      case Types.TIME:
        return "packet.readTimeString()";
      case Types.DECIMAL:
      case Types.NEWDECIMAL:
        if (config.decimalNumbers) {
          return "packet.parseLengthCodedFloat();";
        }
        return 'packet.readLengthCodedString("ascii");';
      case Types.GEOMETRY:
        return "packet.parseGeometryValue();";
      case Types.VECTOR:
        return "packet.parseVector()";
      case Types.JSON:
        return config.jsonStrings ? 'packet.readLengthCodedString("utf8")' : 'JSON.parse(packet.readLengthCodedString("utf8"));';
      case Types.LONGLONG:
        if (!supportBigNumbers) {
          return unsigned ? "packet.readInt64JSNumber();" : "packet.readSInt64JSNumber();";
        }
        if (bigNumberStrings) {
          return unsigned ? "packet.readInt64String();" : "packet.readSInt64String();";
        }
        return unsigned ? "packet.readInt64();" : "packet.readSInt64();";
      default:
        if (field.characterSet === Charsets.BINARY) {
          return "packet.readLengthCodedBuffer();";
        }
        return `packet.readLengthCodedString(fields[${fieldNum}].encoding)`;
    }
  }
  function compile(fields, options, config) {
    const parserFn = genFunc();
    const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);
    function wrap(field, packet2) {
      return {
        type: typeNames[field.columnType],
        length: field.columnLength,
        db: field.schema,
        table: field.table,
        name: field.name,
        string: function(encoding = field.encoding) {
          if (field.columnType === Types.JSON && encoding === field.encoding) {
            console.warn(
              `typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``
            );
          }
          if ([Types.DATETIME, Types.NEWDATE, Types.TIMESTAMP, Types.DATE].includes(
            field.columnType
          )) {
            return packet2.readDateTimeString(
              parseInt(field.decimals, 10),
              " ",
              field.columnType
            );
          }
          if (field.columnType === Types.TINY) {
            const unsigned = field.flags & FieldFlags.UNSIGNED;
            return String(unsigned ? packet2.readInt8() : packet2.readSInt8());
          }
          if (field.columnType === Types.TIME) {
            return packet2.readTimeString();
          }
          return packet2.readLengthCodedString(encoding);
        },
        buffer: function() {
          return packet2.readLengthCodedBuffer();
        },
        geometry: function() {
          return packet2.parseGeometryValue();
        }
      };
    }
    parserFn("(function(){");
    parserFn("return class BinaryRow {");
    parserFn("constructor() {");
    parserFn("}");
    parserFn("next(packet, fields, options) {");
    if (options.rowsAsArray) {
      parserFn(`const result = new Array(${fields.length});`);
    } else {
      parserFn("const result = {};");
    }
    if (typeof config.typeCast === "function" && typeof options.typeCast !== "function") {
      options.typeCast = config.typeCast;
    }
    parserFn("packet.readInt8();");
    for (let i = 0; i < nullBitmapLength; ++i) {
      parserFn(`const nullBitmaskByte${i} = packet.readInt8();`);
    }
    let lvalue = "";
    let currentFieldNullBit = 4;
    let nullByteIndex = 0;
    let fieldName = "";
    let tableName = "";
    for (let i = 0; i < fields.length; i++) {
      fieldName = helpers2.fieldEscape(fields[i].name);
      if (typeof options.nestTables === "string") {
        lvalue = `result[${helpers2.fieldEscape(fields[i].table + options.nestTables + fields[i].name)}]`;
      } else if (options.nestTables === true) {
        tableName = helpers2.fieldEscape(fields[i].table);
        parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);
        lvalue = `result[${tableName}][${fieldName}]`;
      } else if (options.rowsAsArray) {
        lvalue = `result[${i.toString(10)}]`;
      } else {
        lvalue = `result[${fieldName}]`;
      }
      parserFn(`if (nullBitmaskByte${nullByteIndex} & ${currentFieldNullBit}) `);
      parserFn(`${lvalue} = null;`);
      parserFn("else {");
      if (options.typeCast === false) {
        parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);
      } else {
        const fieldWrapperVar = `fieldWrapper${i}`;
        parserFn(`const ${fieldWrapperVar} = wrap(fields[${i}], packet);`);
        const readCode = readCodeFor(fields[i], config, options, i);
        if (typeof options.typeCast === "function") {
          parserFn(
            `${lvalue} = options.typeCast(${fieldWrapperVar}, function() { return ${readCode} });`
          );
        } else {
          parserFn(`${lvalue} = ${readCode};`);
        }
      }
      parserFn("}");
      currentFieldNullBit *= 2;
      if (currentFieldNullBit === 256) {
        currentFieldNullBit = 1;
        nullByteIndex++;
      }
    }
    parserFn("return result;");
    parserFn("}");
    parserFn("};")("})()");
    if (config.debug) {
      helpers2.printDebugWithCode(
        "Compiled binary protocol row parser",
        parserFn.toString()
      );
    }
    return parserFn.toFunction({ wrap });
  }
  function getBinaryParser(fields, options, config) {
    return parserCache.getParser("binary", fields, options, config, compile);
  }
  binary_parser = getBinaryParser;
  return binary_parser;
}
var static_binary_parser;
var hasRequiredStatic_binary_parser;
function requireStatic_binary_parser() {
  if (hasRequiredStatic_binary_parser) return static_binary_parser;
  hasRequiredStatic_binary_parser = 1;
  const FieldFlags = requireField_flags();
  const Charsets = requireCharsets();
  const Types = requireTypes();
  const helpers2 = requireHelpers();
  const typeNames = [];
  for (const t in Types) {
    typeNames[Types[t]] = t;
  }
  function getBinaryParser(fields, _options, config) {
    function readCode(field, config2, options, fieldNum, packet2) {
      const supportBigNumbers = Boolean(
        options.supportBigNumbers || config2.supportBigNumbers
      );
      const bigNumberStrings = Boolean(
        options.bigNumberStrings || config2.bigNumberStrings
      );
      const timezone = options.timezone || config2.timezone;
      const dateStrings = options.dateStrings || config2.dateStrings;
      const unsigned = field.flags & FieldFlags.UNSIGNED;
      switch (field.columnType) {
        case Types.TINY:
          return unsigned ? packet2.readInt8() : packet2.readSInt8();
        case Types.SHORT:
          return unsigned ? packet2.readInt16() : packet2.readSInt16();
        case Types.LONG:
        case Types.INT24:
          return unsigned ? packet2.readInt32() : packet2.readSInt32();
        case Types.YEAR:
          return packet2.readInt16();
        case Types.FLOAT:
          return packet2.readFloat();
        case Types.DOUBLE:
          return packet2.readDouble();
        case Types.NULL:
          return null;
        case Types.DATE:
        case Types.DATETIME:
        case Types.TIMESTAMP:
        case Types.NEWDATE:
          return helpers2.typeMatch(field.columnType, dateStrings, Types) ? packet2.readDateTimeString(
            parseInt(field.decimals, 10),
            null,
            field.columnType
          ) : packet2.readDateTime(timezone);
        case Types.TIME:
          return packet2.readTimeString();
        case Types.DECIMAL:
        case Types.NEWDECIMAL:
          return config2.decimalNumbers ? packet2.parseLengthCodedFloat() : packet2.readLengthCodedString("ascii");
        case Types.GEOMETRY:
          return packet2.parseGeometryValue();
        case Types.VECTOR:
          return packet2.parseVector();
        case Types.JSON:
          return config2.jsonStrings ? packet2.readLengthCodedString("utf8") : JSON.parse(packet2.readLengthCodedString("utf8"));
        case Types.LONGLONG:
          if (!supportBigNumbers)
            return unsigned ? packet2.readInt64JSNumber() : packet2.readSInt64JSNumber();
          return bigNumberStrings ? unsigned ? packet2.readInt64String() : packet2.readSInt64String() : unsigned ? packet2.readInt64() : packet2.readSInt64();
        default:
          return field.characterSet === Charsets.BINARY ? packet2.readLengthCodedBuffer() : packet2.readLengthCodedString(fields[fieldNum].encoding);
      }
    }
    return class BinaryRow {
      constructor() {
      }
      next(packet2, fields2, options) {
        packet2.readInt8();
        const nullBitmapLength = Math.floor((fields2.length + 7 + 2) / 8);
        const nullBitmaskBytes = new Array(nullBitmapLength);
        for (let i = 0; i < nullBitmapLength; i++) {
          nullBitmaskBytes[i] = packet2.readInt8();
        }
        const result = options.rowsAsArray ? new Array(fields2.length) : {};
        let currentFieldNullBit = 4;
        let nullByteIndex = 0;
        for (let i = 0; i < fields2.length; i++) {
          const field = fields2[i];
          const typeCast = options.typeCast !== void 0 ? options.typeCast : config.typeCast;
          let value;
          if (nullBitmaskBytes[nullByteIndex] & currentFieldNullBit) {
            value = null;
          } else if (options.typeCast === false) {
            value = packet2.readLengthCodedBuffer();
          } else {
            const next = () => readCode(field, config, options, i, packet2);
            value = typeof typeCast === "function" ? typeCast(
              {
                type: typeNames[field.columnType],
                length: field.columnLength,
                db: field.schema,
                table: field.table,
                name: field.name,
                string: function(encoding = field.encoding) {
                  if (field.columnType === Types.JSON && encoding === field.encoding) {
                    console.warn(
                      `typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``
                    );
                  }
                  if ([
                    Types.DATETIME,
                    Types.NEWDATE,
                    Types.TIMESTAMP,
                    Types.DATE
                  ].includes(field.columnType)) {
                    return packet2.readDateTimeString(
                      parseInt(field.decimals, 10),
                      " ",
                      field.columnType
                    );
                  }
                  if (field.columnType === Types.TINY) {
                    const unsigned = field.flags & FieldFlags.UNSIGNED;
                    return String(
                      unsigned ? packet2.readInt8() : packet2.readSInt8()
                    );
                  }
                  if (field.columnType === Types.TIME) {
                    return packet2.readTimeString();
                  }
                  return packet2.readLengthCodedString(encoding);
                },
                buffer: function() {
                  return packet2.readLengthCodedBuffer();
                },
                geometry: function() {
                  return packet2.parseGeometryValue();
                }
              },
              next
            ) : next();
          }
          if (options.rowsAsArray) {
            result[i] = value;
          } else if (typeof options.nestTables === "string") {
            const key = helpers2.fieldEscape(
              field.table + options.nestTables + field.name,
              false
            );
            result[key] = value;
          } else if (options.nestTables === true) {
            const tableName = helpers2.fieldEscape(field.table, false);
            if (!result[tableName]) {
              result[tableName] = {};
            }
            const fieldName = helpers2.fieldEscape(field.name, false);
            result[tableName][fieldName] = value;
          } else {
            const key = helpers2.fieldEscape(field.name, false);
            result[key] = value;
          }
          currentFieldNullBit *= 2;
          if (currentFieldNullBit === 256) {
            currentFieldNullBit = 1;
            nullByteIndex++;
          }
        }
        return result;
      }
    };
  }
  static_binary_parser = getBinaryParser;
  return static_binary_parser;
}
var execute;
var hasRequiredExecute;
function requireExecute() {
  if (hasRequiredExecute) return execute;
  hasRequiredExecute = 1;
  const Command = requireCommand();
  const Query = requireQuery();
  const Packets = requirePackets();
  const getBinaryParser = requireBinary_parser();
  const getStaticBinaryParser = requireStatic_binary_parser();
  class Execute extends Command {
    constructor(options, callback) {
      super();
      this.statement = options.statement;
      this.sql = options.sql;
      this.values = options.values;
      this.onResult = callback;
      this.parameters = options.values;
      this.insertId = 0;
      this.timeout = options.timeout;
      this.queryTimeout = null;
      this._rows = [];
      this._fields = [];
      this._result = [];
      this._fieldCount = 0;
      this._rowParser = null;
      this._executeOptions = options;
      this._resultIndex = 0;
      this._localStream = null;
      this._unpipeStream = function() {
      };
      this._streamFactory = options.infileStreamFactory;
      this._connection = null;
    }
    buildParserFromFields(fields, connection2) {
      if (this.options.disableEval) {
        return getStaticBinaryParser(fields, this.options, connection2.config);
      }
      return getBinaryParser(fields, this.options, connection2.config);
    }
    start(packet2, connection2) {
      this._connection = connection2;
      this.options = Object.assign({}, connection2.config, this._executeOptions);
      this._setTimeout();
      const executePacket = new Packets.Execute(
        this.statement.id,
        this.parameters,
        connection2.config.charsetNumber,
        connection2.config.timezone
      );
      try {
        connection2.writePacket(executePacket.toPacket(1));
      } catch (error2) {
        this.onResult(error2);
      }
      return Execute.prototype.resultsetHeader;
    }
    readField(packet2, connection2) {
      let fields;
      const field = new Packets.ColumnDefinition(
        packet2,
        connection2.clientEncoding
      );
      this._receivedFieldsCount++;
      this._fields[this._resultIndex].push(field);
      if (this._receivedFieldsCount === this._fieldCount) {
        fields = this._fields[this._resultIndex];
        this.emit("fields", fields, this._resultIndex);
        return Execute.prototype.fieldsEOF;
      }
      return Execute.prototype.readField;
    }
    fieldsEOF(packet2, connection2) {
      if (!packet2.isEOF()) {
        return connection2.protocolError("Expected EOF packet");
      }
      this._rowParser = new (this.buildParserFromFields(
        this._fields[this._resultIndex],
        connection2
      ))();
      return Execute.prototype.row;
    }
  }
  Execute.prototype.done = Query.prototype.done;
  Execute.prototype.doneInsert = Query.prototype.doneInsert;
  Execute.prototype.resultsetHeader = Query.prototype.resultsetHeader;
  Execute.prototype._findOrCreateReadStream = Query.prototype._findOrCreateReadStream;
  Execute.prototype._streamLocalInfile = Query.prototype._streamLocalInfile;
  Execute.prototype._setTimeout = Query.prototype._setTimeout;
  Execute.prototype._handleTimeoutError = Query.prototype._handleTimeoutError;
  Execute.prototype.row = Query.prototype.row;
  Execute.prototype.stream = Query.prototype.stream;
  execute = Execute;
  return execute;
}
var prepare;
var hasRequiredPrepare;
function requirePrepare() {
  if (hasRequiredPrepare) return prepare;
  hasRequiredPrepare = 1;
  const Packets = requirePackets();
  const Command = requireCommand();
  const CloseStatement = requireClose_statement();
  const Execute = requireExecute();
  class PreparedStatementInfo {
    constructor(query2, id, columns, parameters, connection2) {
      this.query = query2;
      this.id = id;
      this.columns = columns;
      this.parameters = parameters;
      this.rowParser = null;
      this._connection = connection2;
    }
    close() {
      return this._connection.addCommand(new CloseStatement(this.id));
    }
    execute(parameters, callback) {
      if (typeof parameters === "function") {
        callback = parameters;
        parameters = [];
      }
      return this._connection.addCommand(
        new Execute({ statement: this, values: parameters }, callback)
      );
    }
  }
  class Prepare extends Command {
    constructor(options, callback) {
      super();
      this.query = options.sql;
      this.onResult = callback;
      this.id = 0;
      this.fieldCount = 0;
      this.parameterCount = 0;
      this.fields = [];
      this.parameterDefinitions = [];
      this.options = options;
    }
    start(packet2, connection2) {
      const Connection = connection2.constructor;
      this.key = Connection.statementKey(this.options);
      const statement = connection2._statements.get(this.key);
      if (statement) {
        if (this.onResult) {
          this.onResult(null, statement);
        }
        return null;
      }
      const cmdPacket = new Packets.PrepareStatement(
        this.query,
        connection2.config.charsetNumber,
        this.options.values
      );
      connection2.writePacket(cmdPacket.toPacket(1));
      return Prepare.prototype.prepareHeader;
    }
    prepareHeader(packet2, connection2) {
      const header = new Packets.PreparedStatementHeader(packet2);
      this.id = header.id;
      this.fieldCount = header.fieldCount;
      this.parameterCount = header.parameterCount;
      if (this.parameterCount > 0) {
        return Prepare.prototype.readParameter;
      }
      if (this.fieldCount > 0) {
        return Prepare.prototype.readField;
      }
      return this.prepareDone(connection2);
    }
    readParameter(packet2, connection2) {
      if (packet2.isEOF()) {
        if (this.fieldCount > 0) {
          return Prepare.prototype.readField;
        }
        return this.prepareDone(connection2);
      }
      const def = new Packets.ColumnDefinition(packet2, connection2.clientEncoding);
      this.parameterDefinitions.push(def);
      if (this.parameterDefinitions.length === this.parameterCount) {
        return Prepare.prototype.parametersEOF;
      }
      return this.readParameter;
    }
    readField(packet2, connection2) {
      if (packet2.isEOF()) {
        return this.prepareDone(connection2);
      }
      const def = new Packets.ColumnDefinition(packet2, connection2.clientEncoding);
      this.fields.push(def);
      if (this.fields.length === this.fieldCount) {
        return Prepare.prototype.fieldsEOF;
      }
      return Prepare.prototype.readField;
    }
    parametersEOF(packet2, connection2) {
      if (!packet2.isEOF()) {
        return connection2.protocolError("Expected EOF packet after parameters");
      }
      if (this.fieldCount > 0) {
        return Prepare.prototype.readField;
      }
      return this.prepareDone(connection2);
    }
    fieldsEOF(packet2, connection2) {
      if (!packet2.isEOF()) {
        return connection2.protocolError("Expected EOF packet after fields");
      }
      return this.prepareDone(connection2);
    }
    prepareDone(connection2) {
      const statement = new PreparedStatementInfo(
        this.query,
        this.id,
        this.fields,
        this.parameterDefinitions,
        connection2
      );
      connection2._statements.set(this.key, statement);
      if (this.onResult) {
        this.onResult(null, statement);
      }
      return null;
    }
  }
  prepare = Prepare;
  return prepare;
}
var ping;
var hasRequiredPing;
function requirePing() {
  if (hasRequiredPing) return ping;
  hasRequiredPing = 1;
  const Command = requireCommand();
  const CommandCode = requireCommands$1();
  const Packet = requirePacket();
  class Ping extends Command {
    constructor(callback) {
      super();
      this.onResult = callback;
    }
    start(packet2, connection2) {
      const ping2 = new Packet(
        0,
        Buffer.from([1, 0, 0, 0, CommandCode.PING]),
        0,
        5
      );
      connection2.writePacket(ping2);
      return Ping.prototype.pingResponse;
    }
    pingResponse() {
      if (this.onResult) {
        process.nextTick(this.onResult.bind(this));
      }
      return null;
    }
  }
  ping = Ping;
  return ping;
}
var register_slave;
var hasRequiredRegister_slave;
function requireRegister_slave() {
  if (hasRequiredRegister_slave) return register_slave;
  hasRequiredRegister_slave = 1;
  const Command = requireCommand();
  const Packets = requirePackets();
  class RegisterSlave extends Command {
    constructor(opts, callback) {
      super();
      this.onResult = callback;
      this.opts = opts;
    }
    start(packet2, connection2) {
      const newPacket = new Packets.RegisterSlave(this.opts);
      connection2.writePacket(newPacket.toPacket(1));
      return RegisterSlave.prototype.registerResponse;
    }
    registerResponse() {
      if (this.onResult) {
        process.nextTick(this.onResult.bind(this));
      }
      return null;
    }
  }
  register_slave = RegisterSlave;
  return register_slave;
}
var binlog_query_statusvars;
var hasRequiredBinlog_query_statusvars;
function requireBinlog_query_statusvars() {
  if (hasRequiredBinlog_query_statusvars) return binlog_query_statusvars;
  hasRequiredBinlog_query_statusvars = 1;
  const keys = {
    FLAGS2: 0,
    SQL_MODE: 1,
    CATALOG: 2,
    CHARSET: 4,
    TIME_ZONE: 5,
    CATALOG_NZ: 6,
    LC_TIME_NAMES: 7,
    CHARSET_DATABASE: 8,
    TABLE_MAP_FOR_UPDATE: 9,
    MASTER_DATA_WRITTEN: 10,
    INVOKERS: 11,
    UPDATED_DB_NAMES: 12,
    MICROSECONDS: 3
  };
  binlog_query_statusvars = function parseStatusVars(buffer) {
    const result = {};
    let offset = 0;
    let key, length, prevOffset;
    while (offset < buffer.length) {
      key = buffer[offset++];
      switch (key) {
        case keys.FLAGS2:
          result.flags = buffer.readUInt32LE(offset);
          offset += 4;
          break;
        case keys.SQL_MODE:
          result.sqlMode = buffer.readUInt32LE(offset);
          offset += 8;
          break;
        case keys.CATALOG:
          length = buffer[offset++];
          result.catalog = buffer.toString("utf8", offset, offset + length);
          offset += length + 1;
          break;
        case keys.CHARSET:
          result.clientCharset = buffer.readUInt16LE(offset);
          result.connectionCollation = buffer.readUInt16LE(offset + 2);
          result.serverCharset = buffer.readUInt16LE(offset + 4);
          offset += 6;
          break;
        case keys.TIME_ZONE:
          length = buffer[offset++];
          result.timeZone = buffer.toString("utf8", offset, offset + length);
          offset += length;
          break;
        case keys.CATALOG_NZ:
          length = buffer[offset++];
          result.catalogNz = buffer.toString("utf8", offset, offset + length);
          offset += length;
          break;
        case keys.LC_TIME_NAMES:
          result.lcTimeNames = buffer.readUInt16LE(offset);
          offset += 2;
          break;
        case keys.CHARSET_DATABASE:
          result.schemaCharset = buffer.readUInt16LE(offset);
          offset += 2;
          break;
        case keys.TABLE_MAP_FOR_UPDATE:
          result.mapForUpdate1 = buffer.readUInt32LE(offset);
          result.mapForUpdate2 = buffer.readUInt32LE(offset + 4);
          offset += 8;
          break;
        case keys.MASTER_DATA_WRITTEN:
          result.masterDataWritten = buffer.readUInt32LE(offset);
          offset += 4;
          break;
        case keys.INVOKERS:
          length = buffer[offset++];
          result.invokerUsername = buffer.toString(
            "utf8",
            offset,
            offset + length
          );
          offset += length;
          length = buffer[offset++];
          result.invokerHostname = buffer.toString(
            "utf8",
            offset,
            offset + length
          );
          offset += length;
          break;
        case keys.UPDATED_DB_NAMES:
          length = buffer[offset++];
          result.updatedDBs = [];
          for (; length; --length) {
            prevOffset = offset;
            while (buffer[offset++] && offset < buffer.length) {
            }
            result.updatedDBs.push(
              buffer.toString("utf8", prevOffset, offset - 1)
            );
          }
          break;
        case keys.MICROSECONDS:
          result.microseconds = // REVIEW: INVALID UNKNOWN VARIABLE!
          buffer.readInt16LE(offset) + (buffer[offset + 2] << 16);
          offset += 3;
      }
    }
    return result;
  };
  return binlog_query_statusvars;
}
var binlog_dump;
var hasRequiredBinlog_dump;
function requireBinlog_dump() {
  if (hasRequiredBinlog_dump) return binlog_dump;
  hasRequiredBinlog_dump = 1;
  const Command = requireCommand();
  const Packets = requirePackets();
  const eventParsers = [];
  class BinlogEventHeader {
    constructor(packet2) {
      this.timestamp = packet2.readInt32();
      this.eventType = packet2.readInt8();
      this.serverId = packet2.readInt32();
      this.eventSize = packet2.readInt32();
      this.logPos = packet2.readInt32();
      this.flags = packet2.readInt16();
    }
  }
  class BinlogDump extends Command {
    constructor(opts) {
      super();
      this.opts = opts;
    }
    start(packet2, connection2) {
      const newPacket = new Packets.BinlogDump(this.opts);
      connection2.writePacket(newPacket.toPacket(1));
      return BinlogDump.prototype.binlogData;
    }
    binlogData(packet2) {
      if (packet2.isEOF()) {
        this.emit("eof");
        return null;
      }
      packet2.readInt8();
      const header = new BinlogEventHeader(packet2);
      const EventParser = eventParsers[header.eventType];
      let event;
      if (EventParser) {
        event = new EventParser(packet2);
      } else {
        event = {
          name: "UNKNOWN"
        };
      }
      event.header = header;
      this.emit("event", event);
      return BinlogDump.prototype.binlogData;
    }
  }
  class RotateEvent {
    constructor(packet2) {
      this.pposition = packet2.readInt32();
      packet2.readInt32();
      this.nextBinlog = packet2.readString();
      this.name = "RotateEvent";
    }
  }
  class FormatDescriptionEvent {
    constructor(packet2) {
      this.binlogVersion = packet2.readInt16();
      this.serverVersion = packet2.readString(50).replace(/\u0000.*/, "");
      this.createTimestamp = packet2.readInt32();
      this.eventHeaderLength = packet2.readInt8();
      this.eventsLength = packet2.readBuffer();
      this.name = "FormatDescriptionEvent";
    }
  }
  class QueryEvent {
    constructor(packet2) {
      const parseStatusVars = requireBinlog_query_statusvars();
      this.slaveProxyId = packet2.readInt32();
      this.executionTime = packet2.readInt32();
      const schemaLength = packet2.readInt8();
      this.errorCode = packet2.readInt16();
      const statusVarsLength = packet2.readInt16();
      const statusVars = packet2.readBuffer(statusVarsLength);
      this.schema = packet2.readString(schemaLength);
      packet2.readInt8();
      this.statusVars = parseStatusVars(statusVars);
      this.query = packet2.readString();
      this.name = "QueryEvent";
    }
  }
  class XidEvent {
    constructor(packet2) {
      this.binlogVersion = packet2.readInt16();
      this.xid = packet2.readInt64();
      this.name = "XidEvent";
    }
  }
  eventParsers[2] = QueryEvent;
  eventParsers[4] = RotateEvent;
  eventParsers[15] = FormatDescriptionEvent;
  eventParsers[16] = XidEvent;
  binlog_dump = BinlogDump;
  return binlog_dump;
}
var change_user;
var hasRequiredChange_user;
function requireChange_user() {
  if (hasRequiredChange_user) return change_user;
  hasRequiredChange_user = 1;
  const Command = requireCommand();
  const Packets = requirePackets();
  const ClientConstants = requireClient();
  const ClientHandshake = requireClient_handshake();
  const CharsetToEncoding = requireCharset_encodings();
  class ChangeUser extends Command {
    constructor(options, callback) {
      super();
      this.onResult = callback;
      this.user = options.user;
      this.password = options.password;
      this.password1 = options.password;
      this.password2 = options.password2;
      this.password3 = options.password3;
      this.database = options.database;
      this.passwordSha1 = options.passwordSha1;
      this.charsetNumber = options.charsetNumber;
      this.currentConfig = options.currentConfig;
      this.authenticationFactor = 0;
    }
    start(packet2, connection2) {
      const newPacket = new Packets.ChangeUser({
        flags: connection2.config.clientFlags,
        user: this.user,
        database: this.database,
        charsetNumber: this.charsetNumber,
        password: this.password,
        passwordSha1: this.passwordSha1,
        authPluginData1: connection2._handshakePacket.authPluginData1,
        authPluginData2: connection2._handshakePacket.authPluginData2
      });
      this.currentConfig.user = this.user;
      this.currentConfig.password = this.password;
      this.currentConfig.database = this.database;
      this.currentConfig.charsetNumber = this.charsetNumber;
      connection2.clientEncoding = CharsetToEncoding[this.charsetNumber];
      connection2._statements.clear();
      connection2.writePacket(newPacket.toPacket());
      const multiFactorAuthentication = connection2.serverCapabilityFlags & ClientConstants.MULTI_FACTOR_AUTHENTICATION;
      if (multiFactorAuthentication) {
        this.authenticationFactor = 1;
      }
      return ChangeUser.prototype.handshakeResult;
    }
  }
  ChangeUser.prototype.handshakeResult = ClientHandshake.prototype.handshakeResult;
  ChangeUser.prototype.calculateNativePasswordAuthToken = ClientHandshake.prototype.calculateNativePasswordAuthToken;
  change_user = ChangeUser;
  return change_user;
}
var quit;
var hasRequiredQuit;
function requireQuit() {
  if (hasRequiredQuit) return quit;
  hasRequiredQuit = 1;
  const Command = requireCommand();
  const CommandCode = requireCommands$1();
  const Packet = requirePacket();
  class Quit extends Command {
    constructor(callback) {
      super();
      this.onResult = callback;
    }
    start(packet2, connection2) {
      connection2._closing = true;
      const quit2 = new Packet(
        0,
        Buffer.from([1, 0, 0, 0, CommandCode.QUIT]),
        0,
        5
      );
      if (this.onResult) {
        this.onResult();
      }
      connection2.writePacket(quit2);
      return null;
    }
  }
  quit = Quit;
  return quit;
}
var commands;
var hasRequiredCommands;
function requireCommands() {
  if (hasRequiredCommands) return commands;
  hasRequiredCommands = 1;
  const ClientHandshake = requireClient_handshake();
  const ServerHandshake = requireServer_handshake();
  const Query = requireQuery();
  const Prepare = requirePrepare();
  const CloseStatement = requireClose_statement();
  const Execute = requireExecute();
  const Ping = requirePing();
  const RegisterSlave = requireRegister_slave();
  const BinlogDump = requireBinlog_dump();
  const ChangeUser = requireChange_user();
  const Quit = requireQuit();
  commands = {
    ClientHandshake,
    ServerHandshake,
    Query,
    Prepare,
    CloseStatement,
    Execute,
    Ping,
    RegisterSlave,
    BinlogDump,
    ChangeUser,
    Quit
  };
  return commands;
}
const version = "3.16.2";
const require$$3 = {
  version
};
var ssl_profiles = {};
var lib$1 = { exports: {} };
var defaults = {};
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults) return defaults;
  hasRequiredDefaults = 1;
  Object.defineProperty(defaults, "__esModule", { value: true });
  defaults.defaults = void 0;
  defaults.defaults = [
    "-----BEGIN CERTIFICATE-----\nMIIEEjCCAvqgAwIBAgIJAM2ZN/+nPi27MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD\nVQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\nMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\nem9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBhZi1zb3V0aC0xIFJvb3QgQ0Ew\nHhcNMTkxMDI4MTgwNTU4WhcNMjQxMDI2MTgwNTU4WjCBlTELMAkGA1UEBhMCVVMx\nEDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nJjAkBgNVBAMMHUFtYXpvbiBSRFMgYWYtc291dGgtMSBSb290IENBMIIBIjANBgkq\nhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwR2351uPMZaJk2gMGT+1sk8HE9MQh2rc\n/sCnbxGn2p1c7Oi9aBbd/GiFijeJb2BXvHU+TOq3d3Jjqepq8tapXVt4ojbTJNyC\nJ5E7r7KjTktKdLxtBE1MK25aY+IRJjtdU6vG3KiPKUT1naO3xs3yt0F76WVuFivd\n9OHv2a+KHvPkRUWIxpmAHuMY9SIIMmEZtVE7YZGx5ah0iO4JzItHcbVR0y0PBH55\narpFBddpIVHCacp1FUPxSEWkOpI7q0AaU4xfX0fe1BV5HZYRKpBOIp1TtZWvJD+X\njGUtL1BEsT5vN5g9MkqdtYrC+3SNpAk4VtpvJrdjraI/hhvfeXNnAwIDAQABo2Mw\nYTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUEEi/\nWWMcBJsoGXg+EZwkQ0MscZQwHwYDVR0jBBgwFoAUEEi/WWMcBJsoGXg+EZwkQ0Ms\ncZQwDQYJKoZIhvcNAQELBQADggEBAGDZ5js5Pc/gC58LJrwMPXFhJDBS8QuDm23C\nFFUdlqucskwOS3907ErK1ZkmVJCIqFLArHqskFXMAkRZ2PNR7RjWLqBs+0znG5yH\nhRKb4DXzhUFQ18UBRcvT6V6zN97HTRsEEaNhM/7k8YLe7P8vfNZ28VIoJIGGgv9D\nwQBBvkxQ71oOmAG0AwaGD0ORGUfbYry9Dz4a4IcUsZyRWRMADixgrFv6VuETp26s\n/+z+iqNaGWlELBKh3iQCT6Y/1UnkPLO42bxrCSyOvshdkYN58Q2gMTE1SVTqyo8G\nLw8lLAz9bnvUSgHzB3jRrSx6ggF/WRMRYlR++y6LXP4SAsSAaC0=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEEjCCAvqgAwIBAgIJAJYM4LxvTZA6MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD\nVQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\nMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\nem9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBldS1zb3V0aC0xIFJvb3QgQ0Ew\nHhcNMTkxMDMwMjAyMDM2WhcNMjQxMDI4MjAyMDM2WjCBlTELMAkGA1UEBhMCVVMx\nEDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nJjAkBgNVBAMMHUFtYXpvbiBSRFMgZXUtc291dGgtMSBSb290IENBMIIBIjANBgkq\nhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqM921jXCXeqpRNCS9CBPOe5N7gMaEt+D\ns5uR3riZbqzRlHGiF1jZihkXfHAIQewDwy+Yz+Oec1aEZCQMhUHxZJPusuX0cJfj\nb+UluFqHIijL2TfXJ3D0PVLLoNTQJZ8+GAPECyojAaNuoHbdVqxhOcznMsXIXVFq\nyVLKDGvyKkJjai/iSPDrQMXufg3kWt0ISjNLvsG5IFXgP4gttsM8i0yvRd4QcHoo\nDjvH7V3cS+CQqW5SnDrGnHToB0RLskE1ET+oNOfeN9PWOxQprMOX/zmJhnJQlTqD\nQP7jcf7SddxrKFjuziFiouskJJyNDsMjt1Lf60+oHZhed2ogTeifGwIDAQABo2Mw\nYTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUFBAF\ncgJe/BBuZiGeZ8STfpkgRYQwHwYDVR0jBBgwFoAUFBAFcgJe/BBuZiGeZ8STfpkg\nRYQwDQYJKoZIhvcNAQELBQADggEBAKAYUtlvDuX2UpZW9i1QgsjFuy/ErbW0dLHU\ne/IcFtju2z6RLZ+uF+5A8Kme7IKG1hgt8s+w9TRVQS/7ukQzoK3TaN6XKXRosjtc\no9Rm4gYWM8bmglzY1TPNaiI4HC7546hSwJhubjN0bXCuj/0sHD6w2DkiGuwKNAef\nyTu5vZhPkeNyXLykxkzz7bNp2/PtMBnzIp+WpS7uUDmWyScGPohKMq5PqvL59z+L\nZI3CYeMZrJ5VpXUg3fNNIz/83N3G0sk7wr0ohs/kHTP7xPOYB0zD7Ku4HA0Q9Swf\nWX0qr6UQgTPMjfYDLffI7aEId0gxKw1eGYc6Cq5JAZ3ipi/cBFc=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEEjCCAvqgAwIBAgIJANew34ehz5l8MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD\nVQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\nMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\nem9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0Ew\nHhcNMTkwNTEwMjE0ODI3WhcNMjQwNTA4MjE0ODI3WjCBlTELMAkGA1UEBhMCVVMx\nEDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nJjAkBgNVBAMMHUFtYXpvbiBSRFMgbWUtc291dGgtMSBSb290IENBMIIBIjANBgkq\nhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp7BYV88MukcY+rq0r79+C8UzkT30fEfT\naPXbx1d6M7uheGN4FMaoYmL+JE1NZPaMRIPTHhFtLSdPccInvenRDIatcXX+jgOk\nUA6lnHQ98pwN0pfDUyz/Vph4jBR9LcVkBbe0zdoKKp+HGbMPRU0N2yNrog9gM5O8\ngkU/3O2csJ/OFQNnj4c2NQloGMUpEmedwJMOyQQfcUyt9CvZDfIPNnheUS29jGSw\nERpJe/AENu8Pxyc72jaXQuD+FEi2Ck6lBkSlWYQFhTottAeGvVFNCzKszCntrtqd\nrdYUwurYsLTXDHv9nW2hfDUQa0mhXf9gNDOBIVAZugR9NqNRNyYLHQIDAQABo2Mw\nYTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU54cf\nDjgwBx4ycBH8+/r8WXdaiqYwHwYDVR0jBBgwFoAU54cfDjgwBx4ycBH8+/r8WXda\niqYwDQYJKoZIhvcNAQELBQADggEBAIIMTSPx/dR7jlcxggr+O6OyY49Rlap2laKA\neC/XI4ySP3vQkIFlP822U9Kh8a9s46eR0uiwV4AGLabcu0iKYfXjPkIprVCqeXV7\nny9oDtrbflyj7NcGdZLvuzSwgl9SYTJp7PVCZtZutsPYlbJrBPHwFABvAkMvRtDB\nhitIg4AESDGPoCl94sYHpfDfjpUDMSrAMDUyO6DyBdZH5ryRMAs3lGtsmkkNUrso\naTW6R05681Z0mvkRdb+cdXtKOSuDZPoe2wJJIaz3IlNQNSrB5TImMYgmt6iAsFhv\n3vfTSTKrZDNTJn4ybG6pq1zWExoXsktZPylJly6R3RBwV6nwqBM=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEBjCCAu6gAwIBAgIJAMc0ZzaSUK51MA0GCSqGSIb3DQEBCwUAMIGPMQswCQYD\nVQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\nMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\nem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkw\nODIyMTcwODUwWhcNMjQwODIyMTcwODUwWjCBjzELMAkGA1UEBhMCVVMxEDAOBgNV\nBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoMGUFtYXpv\nbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxIDAeBgNV\nBAMMF0FtYXpvbiBSRFMgUm9vdCAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\nAQ8AMIIBCgKCAQEArXnF/E6/Qh+ku3hQTSKPMhQQlCpoWvnIthzX6MK3p5a0eXKZ\noWIjYcNNG6UwJjp4fUXl6glp53Jobn+tWNX88dNH2n8DVbppSwScVE2LpuL+94vY\n0EYE/XxN7svKea8YvlrqkUBKyxLxTjh+U/KrGOaHxz9v0l6ZNlDbuaZw3qIWdD/I\n6aNbGeRUVtpM6P+bWIoxVl/caQylQS6CEYUk+CpVyJSkopwJlzXT07tMoDL5WgX9\nO08KVgDNz9qP/IGtAcRduRcNioH3E9v981QO1zt/Gpb2f8NqAjUUCUZzOnij6mx9\nMcZ+9cWX88CRzR0vQODWuZscgI08NvM69Fn2SQIDAQABo2MwYTAOBgNVHQ8BAf8E\nBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUc19g2LzLA5j0Kxc0LjZa\npmD/vB8wHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJKoZIhvcN\nAQELBQADggEBAHAG7WTmyjzPRIM85rVj+fWHsLIvqpw6DObIjMWokpliCeMINZFV\nynfgBKsf1ExwbvJNzYFXW6dihnguDG9VMPpi2up/ctQTN8tm9nDKOy08uNZoofMc\nNUZxKCEkVKZv+IL4oHoeayt8egtv3ujJM6V14AstMQ6SwvwvA93EP/Ug2e4WAXHu\ncbI1NAbUgVDqp+DRdfvZkgYKryjTWd/0+1fS8X1bBZVWzl7eirNVnHbSH2ZDpNuY\n0SBd8dj5F6ld3t58ydZbrTHze7JJOd8ijySAp4/kiu9UfZWuTPABzDa/DSdz9Dk/\nzPW4CXXvhLmE02TA9/HeCw3KEHIwicNuEfw=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEEDCCAvigAwIBAgIJAKFMXyltvuRdMA0GCSqGSIb3DQEBCwUAMIGUMQswCQYD\nVQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\nMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\nem9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJEUyBCZXRhIFJvb3QgMjAxOSBDQTAe\nFw0xOTA4MTkxNzM4MjZaFw0yNDA4MTkxNzM4MjZaMIGUMQswCQYDVQQGEwJVUzEQ\nMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UECgwZ\nQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEl\nMCMGA1UEAwwcQW1hem9uIFJEUyBCZXRhIFJvb3QgMjAxOSBDQTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAMkZdnIH9ndatGAcFo+DppGJ1HUt4x+zeO+0\nZZ29m0sfGetVulmTlv2d5b66e+QXZFWpcPQMouSxxYTW08TbrQiZngKr40JNXftA\natvzBqIImD4II0ZX5UEVj2h98qe/ypW5xaDN7fEa5e8FkYB1TEemPaWIbNXqchcL\ntV7IJPr3Cd7Z5gZJlmujIVDPpMuSiNaal9/6nT9oqN+JSM1fx5SzrU5ssg1Vp1vv\n5Xab64uOg7wCJRB9R2GC9XD04odX6VcxUAGrZo6LR64ZSifupo3l+R5sVOc5i8NH\nskdboTzU9H7+oSdqoAyhIU717PcqeDum23DYlPE2nGBWckE+eT8CAwEAAaNjMGEw\nDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFK2hDBWl\nsbHzt/EHd0QYOooqcFPhMB8GA1UdIwQYMBaAFK2hDBWlsbHzt/EHd0QYOooqcFPh\nMA0GCSqGSIb3DQEBCwUAA4IBAQAO/718k8EnOqJDx6wweUscGTGL/QdKXUzTVRAx\nJUsjNUv49mH2HQVEW7oxszfH6cPCaupNAddMhQc4C/af6GHX8HnqfPDk27/yBQI+\nyBBvIanGgxv9c9wBbmcIaCEWJcsLp3HzXSYHmjiqkViXwCpYfkoV3Ns2m8bp+KCO\ny9XmcCKRaXkt237qmoxoh2sGmBHk2UlQtOsMC0aUQ4d7teAJG0q6pbyZEiPyKZY1\nXR/UVxMJL0Q4iVpcRS1kaNCMfqS2smbLJeNdsan8pkw1dvPhcaVTb7CvjhJtjztF\nYfDzAI5794qMlWxwilKMmUvDlPPOTen8NNHkLwWvyFCH7Doh\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEFjCCAv6gAwIBAgIJAMzYZJ+R9NBVMA0GCSqGSIb3DQEBCwUAMIGXMQswCQYD\nVQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\nMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\nem9uIFJEUzEoMCYGA1UEAwwfQW1hem9uIFJEUyBQcmV2aWV3IFJvb3QgMjAxOSBD\nQTAeFw0xOTA4MjEyMjI5NDlaFw0yNDA4MjEyMjI5NDlaMIGXMQswCQYDVQQGEwJV\nUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\nCgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\nUzEoMCYGA1UEAwwfQW1hem9uIFJEUyBQcmV2aWV3IFJvb3QgMjAxOSBDQTCCASIw\nDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM7kkS6vjgKKQTPynC2NjdN5aPPV\nO71G0JJS/2ARVBVJd93JLiGovVJilfWYfwZCs4gTRSSjrUD4D4HyqCd6A+eEEtJq\nM0DEC7i0dC+9WNTsPszuB206Jy2IUmxZMIKJAA1NHSbIMjB+b6/JhbSUi7nKdbR/\nbrj83bF+RoSA+ogrgX7mQbxhmFcoZN9OGaJgYKsKWUt5Wqv627KkGodUK8mDepgD\nS3ZfoRQRx3iceETpcmHJvaIge6+vyDX3d9Z22jmvQ4AKv3py2CmU2UwuhOltFDwB\n0ddtb39vgwrJxaGfiMRHpEP1DfNLWHAnA69/pgZPwIggidS+iBPUhgucMp8CAwEA\nAaNjMGEwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE\nFGnTGpQuQ2H/DZlXMQijZEhjs7TdMB8GA1UdIwQYMBaAFGnTGpQuQ2H/DZlXMQij\nZEhjs7TdMA0GCSqGSIb3DQEBCwUAA4IBAQC3xz1vQvcXAfpcZlngiRWeqU8zQAMQ\nLZPCFNv7PVk4pmqX+ZiIRo4f9Zy7TrOVcboCnqmP/b/mNq0gVF4O+88jwXJZD+f8\n/RnABMZcnGU+vK0YmxsAtYU6TIb1uhRFmbF8K80HHbj9vSjBGIQdPCbvmR2zY6VJ\nBYM+w9U9hp6H4DVMLKXPc1bFlKA5OBTgUtgkDibWJKFOEPW3UOYwp9uq6pFoN0AO\nxMTldqWFsOF3bJIlvOY0c/1EFZXu3Ns6/oCP//Ap9vumldYMUZWmbK+gK33FPOXV\n8BQ6jNC29icv7lLDpRPwjibJBXX+peDR5UK4FdYcswWEB1Tix5X8dYu6\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZUxCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSYwJAYDVQQDDB1BbWF6b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQTAeFw0xOTEw\nMjgxODA2NTNaFw0yNDEwMjgxODA2NTNaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UE\nCAwKV2FzaGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9u\nIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UE\nAwwYQW1hem9uIFJEUyBhZi1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\nAQ8AMIIBCgKCAQEAvtV1OqmFa8zCVQSKOvPUJERLVFtd4rZmDpImc5rIoeBk7w/P\n9lcKUJjO8R/w1a2lJXx3oQ81tiY0Piw6TpT62YWVRMWrOw8+Vxq1dNaDSFp9I8d0\nUHillSSbOk6FOrPDp+R6AwbGFqUDebbN5LFFoDKbhNmH1BVS0a6YNKpGigLRqhka\ncClPslWtPqtjbaP3Jbxl26zWzLo7OtZl98dR225pq8aApNBwmtgA7Gh60HK/cX0t\n32W94n8D+GKSg6R4MKredVFqRTi9hCCNUu0sxYPoELuM+mHiqB5NPjtm92EzCWs+\n+vgWhMc6GxG+82QSWx1Vj8sgLqtE/vLrWddf5QIDAQABo2YwZDAOBgNVHQ8BAf8E\nBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUuLB4gYVJrSKJj/Gz\npqc6yeA+RcAwHwYDVR0jBBgwFoAUEEi/WWMcBJsoGXg+EZwkQ0MscZQwDQYJKoZI\nhvcNAQELBQADggEBABauYOZxUhe9/RhzGJ8MsWCz8eKcyDVd4FCnY6Qh+9wcmYNT\nLtnD88LACtJKb/b81qYzcB0Em6+zVJ3Z9jznfr6buItE6es9wAoja22Xgv44BTHL\nrimbgMwpTt3uEMXDffaS0Ww6YWb3pSE0XYI2ISMWz+xRERRf+QqktSaL39zuiaW5\ntfZMre+YhohRa/F0ZQl3RCd6yFcLx4UoSPqQsUl97WhYzwAxZZfwvLJXOc4ATt3u\nVlCUylNDkaZztDJc/yN5XQoK9W5nOt2cLu513MGYKbuarQr8f+gYU8S+qOyuSRSP\nNRITzwCRVnsJE+2JmcRInn/NcanB7uOGqTvJ9+c=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZUxCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSYwJAYDVQQDDB1BbWF6b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQTAeFw0xOTEw\nMzAyMDIxMzBaFw0yNDEwMzAyMDIxMzBaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UE\nCAwKV2FzaGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9u\nIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UE\nAwwYQW1hem9uIFJEUyBldS1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\nAQ8AMIIBCgKCAQEAtEyjYcajx6xImJn8Vz1zjdmL4ANPgQXwF7+tF7xccmNAZETb\nbzb3I9i5fZlmrRaVznX+9biXVaGxYzIUIR3huQ3Q283KsDYnVuGa3mk690vhvJbB\nQIPgKa5mVwJppnuJm78KqaSpi0vxyCPe3h8h6LLFawVyWrYNZ4okli1/U582eef8\nRzJp/Ear3KgHOLIiCdPDF0rjOdCG1MOlDLixVnPn9IYOciqO+VivXBg+jtfc5J+L\nAaPm0/Yx4uELt1tkbWkm4BvTU/gBOODnYziITZM0l6Fgwvbwgq5duAtKW+h031lC\n37rEvrclqcp4wrsUYcLAWX79ZyKIlRxcAdvEhQIDAQABo2YwZDAOBgNVHQ8BAf8E\nBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQU7zPyc0azQxnBCe7D\nb9KAadH1QSEwHwYDVR0jBBgwFoAUFBAFcgJe/BBuZiGeZ8STfpkgRYQwDQYJKoZI\nhvcNAQELBQADggEBAFGaNiYxg7yC/xauXPlaqLCtwbm2dKyK9nIFbF/7be8mk7Q3\nMOA0of1vGHPLVQLr6bJJpD9MAbUcm4cPAwWaxwcNpxOjYOFDaq10PCK4eRAxZWwF\nNJRIRmGsl8NEsMNTMCy8X+Kyw5EzH4vWFl5Uf2bGKOeFg0zt43jWQVOX6C+aL3Cd\npRS5MhmYpxMG8irrNOxf4NVFE2zpJOCm3bn0STLhkDcV/ww4zMzObTJhiIb5wSWn\nEXKKWhUXuRt7A2y1KJtXpTbSRHQxE++69Go1tWhXtRiULCJtf7wF2Ksm0RR/AdXT\n1uR1vKyH5KBJPX3ppYkQDukoHTFR0CpB+G84NLo=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZUxCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSYwJAYDVQQDDB1BbWF6b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQTAeFw0xOTA1\nMTAyMTU4NDNaFw0yNTA2MDExMjAwMDBaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UE\nCAwKV2FzaGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9u\nIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UE\nAwwYQW1hem9uIFJEUyBtZS1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\nAQ8AMIIBCgKCAQEAudOYPZH+ihJAo6hNYMB5izPVBe3TYhnZm8+X3IoaaYiKtsp1\nJJhkTT0CEejYIQ58Fh4QrMUyWvU8qsdK3diNyQRoYLbctsBPgxBR1u07eUJDv38/\nC1JlqgHmMnMi4y68Iy7ymv50QgAMuaBqgEBRI1R6Lfbyrb2YvH5txjJyTVMwuCfd\nYPAtZVouRz0JxmnfsHyxjE+So56uOKTDuw++Ho4HhZ7Qveej7XB8b+PIPuroknd3\nFQB5RVbXRvt5ZcVD4F2fbEdBniF7FAF4dEiofVCQGQ2nynT7dZdEIPfPdH3n7ZmE\nlAOmwHQ6G83OsiHRBLnbp+QZRgOsjkHJxT20bQIDAQABo2YwZDAOBgNVHQ8BAf8E\nBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUOEVDM7VomRH4HVdA\nQvIMNq2tXOcwHwYDVR0jBBgwFoAU54cfDjgwBx4ycBH8+/r8WXdaiqYwDQYJKoZI\nhvcNAQELBQADggEBAHhvMssj+Th8IpNePU6RH0BiL6o9c437R3Q4IEJeFdYL+nZz\nPW/rELDPvLRUNMfKM+KzduLZ+l29HahxefejYPXtvXBlq/E/9czFDD4fWXg+zVou\nuDXhyrV4kNmP4S0eqsAP/jQHPOZAMFA4yVwO9hlqmePhyDnszCh9c1PfJSBh49+b\n4w7i/L3VBOMt8j3EKYvqz0gVfpeqhJwL4Hey8UbVfJRFJMJzfNHpePqtDRAY7yjV\nPYquRaV2ab/E+/7VFkWMM4tazYz/qsYA2jSH+4xDHvYk8LnsbcrF9iuidQmEc5sb\nFgcWaSKG4DJjcI5k7AJLWcXyTDt21Ci43LE+I9Q=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECDCCAvCgAwIBAgICVIYwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MDQxNzEz\nMDRaFw0yNDA4MjIxNzA4NTBaMIGVMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEmMCQGA1UEAwwdQW1h\nem9uIFJEUyBhcC1zb3V0aC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQDUYOz1hGL42yUCrcsMSOoU8AeD/3KgZ4q7gP+vAz1WnY9K/kim\neWN/2Qqzlo3+mxSFQFyD4MyV3+CnCPnBl9Sh1G/F6kThNiJ7dEWSWBQGAB6HMDbC\nBaAsmUc1UIz8sLTL3fO+S9wYhA63Wun0Fbm/Rn2yk/4WnJAaMZcEtYf6e0KNa0LM\np/kN/70/8cD3iz3dDR8zOZFpHoCtf0ek80QqTich0A9n3JLxR6g6tpwoYviVg89e\nqCjQ4axxOkWWeusLeTJCcY6CkVyFvDAKvcUl1ytM5AiaUkXblE7zDFXRM4qMMRdt\nlPm8d3pFxh0fRYk8bIKnpmtOpz3RIctDrZZxAgMBAAGjZjBkMA4GA1UdDwEB/wQE\nAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBT99wKJftD3jb4sHoHG\ni3uGlH6W6TAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n9w0BAQsFAAOCAQEAZ17hhr3dII3hUfuHQ1hPWGrpJOX/G9dLzkprEIcCidkmRYl+\nhu1Pe3caRMh/17+qsoEErmnVq5jNY9X1GZL04IZH8YbHc7iRHw3HcWAdhN8633+K\njYEB2LbJ3vluCGnCejq9djDb6alOugdLMJzxOkHDhMZ6/gYbECOot+ph1tQuZXzD\ntZ7prRsrcuPBChHlPjmGy8M9z8u+kF196iNSUGC4lM8vLkHM7ycc1/ZOwRq9aaTe\niOghbQQyAEe03MWCyDGtSmDfr0qEk+CHN+6hPiaL8qKt4s+V9P7DeK4iW08ny8Ox\nAVS7u0OK/5+jKMAMrKwpYrBydOjTUTHScocyNw==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICQ2QwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MDUxODQ2\nMjlaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyBzYS1lYXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBAMMvR+ReRnOzqJzoaPipNTt1Z2VA968jlN1+SYKUrYM3No+Vpz0H\nM6Tn0oYB66ByVsXiGc28ulsqX1HbHsxqDPwvQTKvO7SrmDokoAkjJgLocOLUAeld\n5AwvUjxGRP6yY90NV7X786MpnYb2Il9DIIaV9HjCmPt+rjy2CZjS0UjPjCKNfB8J\nbFjgW6GGscjeyGb/zFwcom5p4j0rLydbNaOr9wOyQrtt3ZQWLYGY9Zees/b8pmcc\nJt+7jstZ2UMV32OO/kIsJ4rMUn2r/uxccPwAc1IDeRSSxOrnFKhW3Cu69iB3bHp7\nJbawY12g7zshE4I14sHjv3QoXASoXjx4xgMCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFI1Fc/Ql2jx+oJPgBVYq\nccgP0pQ8MB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQB4VVVabVp70myuYuZ3vltQIWqSUMhkaTzehMgGcHjMf9iLoZ/I\n93KiFUSGnek5cRePyS9wcpp0fcBT3FvkjpUdCjVtdttJgZFhBxgTd8y26ImdDDMR\n4+BUuhI5msvjL08f+Vkkpu1GQcGmyFVPFOy/UY8iefu+QyUuiBUnUuEDd49Hw0Fn\n/kIPII6Vj82a2mWV/Q8e+rgN8dIRksRjKI03DEoP8lhPlsOkhdwU6Uz9Vu6NOB2Q\nLs1kbcxAc7cFSyRVJEhh12Sz9d0q/CQSTFsVJKOjSNQBQfVnLz1GwO/IieUEAr4C\njkTntH0r1LX5b/GwN4R887LvjAEdTbg1his7\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECDCCAvCgAwIBAgIDAIkHMA0GCSqGSIb3DQEBCwUAMIGPMQswCQYDVQQGEwJV\nUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\nCgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\nUzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkwOTA2MTc0\nMDIxWhcNMjQwODIyMTcwODUwWjCBlDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldh\nc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBXZWIg\nU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJTAjBgNVBAMMHEFt\nYXpvbiBSRFMgdXMtd2VzdC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQDD2yzbbAl77OofTghDMEf624OvU0eS9O+lsdO0QlbfUfWa1Kd6\n0WkgjkLZGfSRxEHMCnrv4UPBSK/Qwn6FTjkDLgemhqBtAnplN4VsoDL+BkRX4Wwq\n/dSQJE2b+0hm9w9UMVGFDEq1TMotGGTD2B71eh9HEKzKhGzqiNeGsiX4VV+LJzdH\nuM23eGisNqmd4iJV0zcAZ+Gbh2zK6fqTOCvXtm7Idccv8vZZnyk1FiWl3NR4WAgK\nAkvWTIoFU3Mt7dIXKKClVmvssG8WHCkd3Xcb4FHy/G756UZcq67gMMTX/9fOFM/v\nl5C0+CHl33Yig1vIDZd+fXV1KZD84dEJfEvHAgMBAAGjZjBkMA4GA1UdDwEB/wQE\nAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBR+ap20kO/6A7pPxo3+\nT3CfqZpQWjAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n9w0BAQsFAAOCAQEAHCJky2tPjPttlDM/RIqExupBkNrnSYnOK4kr9xJ3sl8UF2DA\nPAnYsjXp3rfcjN/k/FVOhxwzi3cXJF/2Tjj39Bm/OEfYTOJDNYtBwB0VVH4ffa/6\ntZl87jaIkrxJcreeeHqYMnIxeN0b/kliyA+a5L2Yb0VPjt9INq34QDc1v74FNZ17\n4z8nr1nzg4xsOWu0Dbjo966lm4nOYIGBRGOKEkHZRZ4mEiMgr3YLkv8gSmeitx57\nZ6dVemNtUic/LVo5Iqw4n3TBS0iF2C1Q1xT/s3h+0SXZlfOWttzSluDvoMv5PvCd\npFjNn+aXLAALoihL1MJSsxydtsLjOBro5eK0Vw==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEDDCCAvSgAwIBAgICOFAwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTAxNzQ2\nMjFaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\nem9uIFJEUyBhcC1ub3J0aGVhc3QtMiAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEAzU72e6XbaJbi4HjJoRNjKxzUEuChKQIt7k3CWzNnmjc5\n8I1MjCpa2W1iw1BYVysXSNSsLOtUsfvBZxi/1uyMn5ZCaf9aeoA9UsSkFSZBjOCN\nDpKPCmfV1zcEOvJz26+1m8WDg+8Oa60QV0ou2AU1tYcw98fOQjcAES0JXXB80P2s\n3UfkNcnDz+l4k7j4SllhFPhH6BQ4lD2NiFAP4HwoG6FeJUn45EPjzrydxjq6v5Fc\ncQ8rGuHADVXotDbEhaYhNjIrsPL+puhjWfhJjheEw8c4whRZNp6gJ/b6WEes/ZhZ\nh32DwsDsZw0BfRDUMgUn8TdecNexHUw8vQWeC181hwIDAQABo2YwZDAOBgNVHQ8B\nAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUwW9bWgkWkr0U\nlrOsq2kvIdrECDgwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\nKoZIhvcNAQELBQADggEBAEugF0Gj7HVhX0ehPZoGRYRt3PBuI2YjfrrJRTZ9X5wc\n9T8oHmw07mHmNy1qqWvooNJg09bDGfB0k5goC2emDiIiGfc/kvMLI7u+eQOoMKj6\nmkfCncyRN3ty08Po45vTLBFZGUvtQmjM6yKewc4sXiASSBmQUpsMbiHRCL72M5qV\nobcJOjGcIdDTmV1BHdWT+XcjynsGjUqOvQWWhhLPrn4jWe6Xuxll75qlrpn3IrIx\nCRBv/5r7qbcQJPOgwQsyK4kv9Ly8g7YT1/vYBlR3cRsYQjccw5ceWUj2DrMVWhJ4\nprf+E3Aa4vYmLLOUUvKnDQ1k3RGNu56V0tonsQbfsaM=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECjCCAvKgAwIBAgICEzUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTAyMDUy\nMjVaFw0yNDA4MjIxNzA4NTBaMIGXMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEoMCYGA1UEAwwfQW1h\nem9uIFJEUyBjYS1jZW50cmFsLTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD\nggEPADCCAQoCggEBAOxHqdcPSA2uBjsCP4DLSlqSoPuQ/X1kkJLusVRKiQE2zayB\nviuCBt4VB9Qsh2rW3iYGM+usDjltGnI1iUWA5KHcvHszSMkWAOYWLiMNKTlg6LCp\nXnE89tvj5dIH6U8WlDvXLdjB/h30gW9JEX7S8supsBSci2GxEzb5mRdKaDuuF/0O\nqvz4YE04pua3iZ9QwmMFuTAOYzD1M72aOpj+7Ac+YLMM61qOtU+AU6MndnQkKoQi\nqmUN2A9IFaqHFzRlSdXwKCKUA4otzmz+/N3vFwjb5F4DSsbsrMfjeHMo6o/nb6Nh\nYDb0VJxxPee6TxSuN7CQJ2FxMlFUezcoXqwqXD0CAwEAAaNmMGQwDgYDVR0PAQH/\nBAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFDGGpon9WfIpsggE\nCxHq8hZ7E2ESMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqG\nSIb3DQEBCwUAA4IBAQAvpeQYEGZvoTVLgV9rd2+StPYykMsmFjWQcyn3dBTZRXC2\nlKq7QhQczMAOhEaaN29ZprjQzsA2X/UauKzLR2Uyqc2qOeO9/YOl0H3qauo8C/W9\nr8xqPbOCDLEXlOQ19fidXyyEPHEq5WFp8j+fTh+s8WOx2M7IuC0ANEetIZURYhSp\nxl9XOPRCJxOhj7JdelhpweX0BJDNHeUFi0ClnFOws8oKQ7sQEv66d5ddxqqZ3NVv\nRbCvCtEutQMOUMIuaygDlMn1anSM8N7Wndx8G6+Uy67AnhjGx7jw/0YPPxopEj6x\nJXP8j0sJbcT9K/9/fPVLNT25RvQ/93T2+IQL4Ca2\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICYpgwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTExNzMx\nNDhaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyBldS13ZXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBAMk3YdSZ64iAYp6MyyKtYJtNzv7zFSnnNf6vv0FB4VnfITTMmOyZ\nLXqKAT2ahZ00hXi34ewqJElgU6eUZT/QlzdIu359TEZyLVPwURflL6SWgdG01Q5X\nO++7fSGcBRyIeuQWs9FJNIIqK8daF6qw0Rl5TXfu7P9dBc3zkgDXZm2DHmxGDD69\n7liQUiXzoE1q2Z9cA8+jirDioJxN9av8hQt12pskLQumhlArsMIhjhHRgF03HOh5\ntvi+RCfihVOxELyIRTRpTNiIwAqfZxxTWFTgfn+gijTmd0/1DseAe82aYic8JbuS\nEMbrDduAWsqrnJ4GPzxHKLXX0JasCUcWyMECAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFPLtsq1NrwJXO13C9eHt\nsLY11AGwMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQAnWBKj5xV1A1mYd0kIgDdkjCwQkiKF5bjIbGkT3YEFFbXoJlSP\n0lZZ/hDaOHI8wbLT44SzOvPEEmWF9EE7SJzkvSdQrUAWR9FwDLaU427ALI3ngNHy\nlGJ2hse1fvSRNbmg8Sc9GBv8oqNIBPVuw+AJzHTacZ1OkyLZrz1c1QvwvwN2a+Jd\nvH0V0YIhv66llKcYDMUQJAQi4+8nbRxXWv6Gq3pvrFoorzsnkr42V3JpbhnYiK+9\nnRKd4uWl62KRZjGkfMbmsqZpj2fdSWMY1UGyN1k+kDmCSWYdrTRDP0xjtIocwg+A\nJ116n4hV/5mbA0BaPiS2krtv17YAeHABZcvz\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECjCCAvKgAwIBAgICV2YwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTExOTM2\nMjBaFw0yNDA4MjIxNzA4NTBaMIGXMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEoMCYGA1UEAwwfQW1h\nem9uIFJEUyBldS1jZW50cmFsLTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD\nggEPADCCAQoCggEBAMEx54X2pHVv86APA0RWqxxRNmdkhAyp2R1cFWumKQRofoFv\nn+SPXdkpIINpMuEIGJANozdiEz7SPsrAf8WHyD93j/ZxrdQftRcIGH41xasetKGl\nI67uans8d+pgJgBKGb/Z+B5m+UsIuEVekpvgpwKtmmaLFC/NCGuSsJoFsRqoa6Gh\nm34W6yJoY87UatddCqLY4IIXaBFsgK9Q/wYzYLbnWM6ZZvhJ52VMtdhcdzeTHNW0\n5LGuXJOF7Ahb4JkEhoo6TS2c0NxB4l4MBfBPgti+O7WjR3FfZHpt18A6Zkq6A2u6\nD/oTSL6c9/3sAaFTFgMyL3wHb2YlW0BPiljZIqECAwEAAaNmMGQwDgYDVR0PAQH/\nBAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFOcAToAc6skWffJa\nTnreaswAfrbcMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqG\nSIb3DQEBCwUAA4IBAQA1d0Whc1QtspK496mFWfFEQNegLh0a9GWYlJm+Htcj5Nxt\nDAIGXb+8xrtOZFHmYP7VLCT5Zd2C+XytqseK/+s07iAr0/EPF+O2qcyQWMN5KhgE\ncXw2SwuP9FPV3i+YAm11PBVeenrmzuk9NrdHQ7TxU4v7VGhcsd2C++0EisrmquWH\nmgIfmVDGxphwoES52cY6t3fbnXmTkvENvR+h3rj+fUiSz0aSo+XZUGHPgvuEKM/W\nCBD9Smc9CBoBgvy7BgHRgRUmwtABZHFUIEjHI5rIr7ZvYn+6A0O6sogRfvVYtWFc\nqpyrW1YX8mD0VlJ8fGKM3G+aCOsiiPKDV/Uafrm+\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECDCCAvCgAwIBAgICGAcwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTIxODE5\nNDRaFw0yNDA4MjIxNzA4NTBaMIGVMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEmMCQGA1UEAwwdQW1h\nem9uIFJEUyBldS1ub3J0aC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQCiIYnhe4UNBbdBb/nQxl5giM0XoVHWNrYV5nB0YukA98+TPn9v\nAoj1RGYmtryjhrf01Kuv8SWO+Eom95L3zquoTFcE2gmxCfk7bp6qJJ3eHOJB+QUO\nXsNRh76fwDzEF1yTeZWH49oeL2xO13EAx4PbZuZpZBttBM5zAxgZkqu4uWQczFEs\nJXfla7z2fvWmGcTagX10O5C18XaFroV0ubvSyIi75ue9ykg/nlFAeB7O0Wxae88e\nuhiBEFAuLYdqWnsg3459NfV8Yi1GnaitTym6VI3tHKIFiUvkSiy0DAlAGV2iiyJE\nq+DsVEO4/hSINJEtII4TMtysOsYPpINqeEzRAgMBAAGjZjBkMA4GA1UdDwEB/wQE\nAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBRR0UpnbQyjnHChgmOc\nhnlc0PogzTAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n9w0BAQsFAAOCAQEAKJD4xVzSf4zSGTBJrmamo86jl1NHQxXUApAZuBZEc8tqC6TI\nT5CeoSr9CMuVC8grYyBjXblC4OsM5NMvmsrXl/u5C9dEwtBFjo8mm53rOOIm1fxl\nI1oYB/9mtO9ANWjkykuLzWeBlqDT/i7ckaKwalhLODsRDO73vRhYNjsIUGloNsKe\npxw3dzHwAZx4upSdEVG4RGCZ1D0LJ4Gw40OfD69hfkDfRVVxKGrbEzqxXRvovmDc\ntKLdYZO/6REoca36v4BlgIs1CbUXJGLSXUwtg7YXGLSVBJ/U0+22iGJmBSNcoyUN\ncjPFD9JQEhDDIYYKSGzIYpvslvGc4T5ISXFiuQ==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICZIEwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTIyMTMy\nMzJaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyBldS13ZXN0LTIgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBALGiwqjiF7xIjT0Sx7zB3764K2T2a1DHnAxEOr+/EIftWKxWzT3u\nPFwS2eEZcnKqSdRQ+vRzonLBeNLO4z8aLjQnNbkizZMBuXGm4BqRm1Kgq3nlLDQn\n7YqdijOq54SpShvR/8zsO4sgMDMmHIYAJJOJqBdaus2smRt0NobIKc0liy7759KB\n6kmQ47Gg+kfIwxrQA5zlvPLeQImxSoPi9LdbRoKvu7Iot7SOa+jGhVBh3VdqndJX\n7tm/saj4NE375csmMETFLAOXjat7zViMRwVorX4V6AzEg1vkzxXpA9N7qywWIT5Y\nfYaq5M8i6vvLg0CzrH9fHORtnkdjdu1y+0MCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFFOhOx1yt3Z7mvGB9jBv\n2ymdZwiOMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQBehqY36UGDvPVU9+vtaYGr38dBbp+LzkjZzHwKT1XJSSUc2wqM\nhnCIQKilonrTIvP1vmkQi8qHPvDRtBZKqvz/AErW/ZwQdZzqYNFd+BmOXaeZWV0Q\noHtDzXmcwtP8aUQpxN0e1xkWb1E80qoy+0uuRqb/50b/R4Q5qqSfJhkn6z8nwB10\n7RjLtJPrK8igxdpr3tGUzfAOyiPrIDncY7UJaL84GFp7WWAkH0WG3H8Y8DRcRXOU\nmqDxDLUP3rNuow3jnGxiUY+gGX5OqaZg4f4P6QzOSmeQYs6nLpH0PiN00+oS1BbD\nbpWdZEttILPI+vAYkU4QuBKKDjJL6HbSd+cn\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECDCCAvCgAwIBAgIDAIVCMA0GCSqGSIb3DQEBCwUAMIGPMQswCQYDVQQGEwJV\nUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\nCgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\nUzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkwOTEzMTcw\nNjQxWhcNMjQwODIyMTcwODUwWjCBlDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldh\nc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBXZWIg\nU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJTAjBgNVBAMMHEFt\nYXpvbiBSRFMgdXMtZWFzdC0yIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQDE+T2xYjUbxOp+pv+gRA3FO24+1zCWgXTDF1DHrh1lsPg5k7ht\n2KPYzNc+Vg4E+jgPiW0BQnA6jStX5EqVh8BU60zELlxMNvpg4KumniMCZ3krtMUC\nau1NF9rM7HBh+O+DYMBLK5eSIVt6lZosOb7bCi3V6wMLA8YqWSWqabkxwN4w0vXI\n8lu5uXXFRemHnlNf+yA/4YtN4uaAyd0ami9+klwdkZfkrDOaiy59haOeBGL8EB/c\ndbJJlguHH5CpCscs3RKtOOjEonXnKXldxarFdkMzi+aIIjQ8GyUOSAXHtQHb3gZ4\nnS6Ey0CMlwkB8vUObZU9fnjKJcL5QCQqOfwvAgMBAAGjZjBkMA4GA1UdDwEB/wQE\nAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBQUPuRHohPxx4VjykmH\n6usGrLL1ETAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n9w0BAQsFAAOCAQEAUdR9Vb3y33Yj6X6KGtuthZ08SwjImVQPtknzpajNE5jOJAh8\nquvQnU9nlnMO85fVDU1Dz3lLHGJ/YG1pt1Cqq2QQ200JcWCvBRgdvH6MjHoDQpqZ\nHvQ3vLgOGqCLNQKFuet9BdpsHzsctKvCVaeBqbGpeCtt3Hh/26tgx0rorPLw90A2\nV8QSkZJjlcKkLa58N5CMM8Xz8KLWg3MZeT4DmlUXVCukqK2RGuP2L+aME8dOxqNv\nOnOz1zrL5mR2iJoDpk8+VE/eBDmJX40IJk6jBjWoxAO/RXq+vBozuF5YHN1ujE92\ntO8HItgTp37XT8bJBAiAnt5mxw+NLSqtxk2QdQ==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEDDCCAvSgAwIBAgICY4kwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTMyMDEx\nNDJaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\nem9uIFJEUyBhcC1zb3V0aGVhc3QtMSAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEAr5u9OuLL/OF/fBNUX2kINJLzFl4DnmrhnLuSeSnBPgbb\nqddjf5EFFJBfv7IYiIWEFPDbDG5hoBwgMup5bZDbas+ZTJTotnnxVJTQ6wlhTmns\neHECcg2pqGIKGrxZfbQhlj08/4nNAPvyYCTS0bEcmQ1emuDPyvJBYDDLDU6AbCB5\n6Z7YKFQPTiCBblvvNzchjLWF9IpkqiTsPHiEt21sAdABxj9ityStV3ja/W9BfgxH\nwzABSTAQT6FbDwmQMo7dcFOPRX+hewQSic2Rn1XYjmNYzgEHisdUsH7eeXREAcTw\n61TRvaLH8AiOWBnTEJXPAe6wYfrcSd1pD0MXpoB62wIDAQABo2YwZDAOBgNVHQ8B\nAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUytwMiomQOgX5\nIchd+2lDWRUhkikwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\nKoZIhvcNAQELBQADggEBACf6lRDpfCD7BFRqiWM45hqIzffIaysmVfr+Jr+fBTjP\nuYe/ba1omSrNGG23bOcT9LJ8hkQJ9d+FxUwYyICQNWOy6ejicm4z0C3VhphbTPqj\nyjpt9nG56IAcV8BcRJh4o/2IfLNzC/dVuYJV8wj7XzwlvjysenwdrJCoLadkTr1h\neIdG6Le07sB9IxrGJL9e04afk37h7c8ESGSE4E+oS4JQEi3ATq8ne1B9DQ9SasXi\nIRmhNAaISDzOPdyLXi9N9V9Lwe/DHcja7hgLGYx3UqfjhLhOKwp8HtoZORixAmOI\nHfILgNmwyugAbuZoCazSKKBhQ0wgO0WZ66ZKTMG8Oho=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICUYkwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTYxODIx\nMTVaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyB1cy13ZXN0LTIgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBANCEZBZyu6yJQFZBJmSUZfSZd3Ui2gitczMKC4FLr0QzkbxY+cLa\nuVONIOrPt4Rwi+3h/UdnUg917xao3S53XDf1TDMFEYp4U8EFPXqCn/GXBIWlU86P\nPvBN+gzw3nS+aco7WXb+woTouvFVkk8FGU7J532llW8o/9ydQyDIMtdIkKTuMfho\nOiNHSaNc+QXQ32TgvM9A/6q7ksUoNXGCP8hDOkSZ/YOLiI5TcdLh/aWj00ziL5bj\npvytiMZkilnc9dLY9QhRNr0vGqL0xjmWdoEXz9/OwjmCihHqJq+20MJPsvFm7D6a\n2NKybR9U+ddrjb8/iyLOjURUZnj5O+2+OPcCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFEBxMBdv81xuzqcK5TVu\npHj+Aor8MB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQBZkfiVqGoJjBI37aTlLOSjLcjI75L5wBrwO39q+B4cwcmpj58P\n3sivv+jhYfAGEbQnGRzjuFoyPzWnZ1DesRExX+wrmHsLLQbF2kVjLZhEJMHF9eB7\nGZlTPdTzHErcnuXkwA/OqyXMpj9aghcQFuhCNguEfnROY9sAoK2PTfnTz9NJHL+Q\nUpDLEJEUfc0GZMVWYhahc0x38ZnSY2SKacIPECQrTI0KpqZv/P+ijCEcMD9xmYEb\njL4en+XKS1uJpw5fIU5Sj0MxhdGstH6S84iAE5J3GM3XHklGSFwwqPYvuTXvANH6\nuboynxRgSae59jIlAK6Jrr6GWMwQRbgcaAlW\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEDDCCAvSgAwIBAgICEkYwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTYxOTUz\nNDdaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\nem9uIFJEUyBhcC1zb3V0aGVhc3QtMiAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEAufodI2Flker8q7PXZG0P0vmFSlhQDw907A6eJuF/WeMo\nGHnll3b4S6nC3oRS3nGeRMHbyU2KKXDwXNb3Mheu+ox+n5eb/BJ17eoj9HbQR1cd\ngEkIciiAltf8gpMMQH4anP7TD+HNFlZnP7ii3geEJB2GGXSxgSWvUzH4etL67Zmn\nTpGDWQMB0T8lK2ziLCMF4XAC/8xDELN/buHCNuhDpxpPebhct0T+f6Arzsiswt2j\n7OeNeLLZwIZvVwAKF7zUFjC6m7/VmTQC8nidVY559D6l0UhhU0Co/txgq3HVsMOH\nPbxmQUwJEKAzQXoIi+4uZzHFZrvov/nDTNJUhC6DqwIDAQABo2YwZDAOBgNVHQ8B\nAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUwaZpaCme+EiV\nM5gcjeHZSTgOn4owHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\nKoZIhvcNAQELBQADggEBAAR6a2meCZuXO2TF9bGqKGtZmaah4pH2ETcEVUjkvXVz\nsl+ZKbYjrun+VkcMGGKLUjS812e7eDF726ptoku9/PZZIxlJB0isC/0OyixI8N4M\nNsEyvp52XN9QundTjkl362bomPnHAApeU0mRbMDRR2JdT70u6yAzGLGsUwMkoNnw\n1VR4XKhXHYGWo7KMvFrZ1KcjWhubxLHxZWXRulPVtGmyWg/MvE6KF+2XMLhojhUL\n+9jB3Fpn53s6KMx5tVq1x8PukHmowcZuAF8k+W4gk8Y68wIwynrdZrKRyRv6CVtR\nFZ8DeJgoNZT3y/GT254VqMxxfuy2Ccb/RInd16tEvVk=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEDDCCAvSgAwIBAgICOYIwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTcyMDA1\nMjlaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\nem9uIFJEUyBhcC1ub3J0aGVhc3QtMyAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEA4dMak8W+XW8y/2F6nRiytFiA4XLwePadqWebGtlIgyCS\nkbug8Jv5w7nlMkuxOxoUeD4WhI6A9EkAn3r0REM/2f0aYnd2KPxeqS2MrtdxxHw1\nxoOxk2x0piNSlOz6yog1idsKR5Wurf94fvM9FdTrMYPPrDabbGqiBMsZZmoHLvA3\nZ+57HEV2tU0Ei3vWeGIqnNjIekS+E06KhASxrkNU5vi611UsnYZlSi0VtJsH4UGV\nLhnHl53aZL0YFO5mn/fzuNG/51qgk/6EFMMhaWInXX49Dia9FnnuWXwVwi6uX1Wn\n7kjoHi5VtmC8ZlGEHroxX2DxEr6bhJTEpcLMnoQMqwIDAQABo2YwZDAOBgNVHQ8B\nAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUsUI5Cb3SWB8+\ngv1YLN/ABPMdxSAwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\nKoZIhvcNAQELBQADggEBAJAF3E9PM1uzVL8YNdzb6fwJrxxqI2shvaMVmC1mXS+w\nG0zh4v2hBZOf91l1EO0rwFD7+fxoI6hzQfMxIczh875T6vUXePKVOCOKI5wCrDad\nzQbVqbFbdhsBjF4aUilOdtw2qjjs9JwPuB0VXN4/jY7m21oKEOcnpe36+7OiSPjN\nxngYewCXKrSRqoj3mw+0w/+exYj3Wsush7uFssX18av78G+ehKPIVDXptOCP/N7W\n8iKVNeQ2QGTnu2fzWsGUSvMGyM7yqT+h1ILaT//yQS8er511aHMLc142bD4D9VSy\nDgactwPDTShK/PXqhvNey9v/sKXm4XatZvwcc8KYlW4=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEDDCCAvSgAwIBAgICcEUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTgxNjU2\nMjBaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\nem9uIFJEUyBhcC1ub3J0aGVhc3QtMSAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEAndtkldmHtk4TVQAyqhAvtEHSMb6pLhyKrIFved1WO3S7\n+I+bWwv9b2W/ljJxLq9kdT43bhvzonNtI4a1LAohS6bqyirmk8sFfsWT3akb+4Sx\n1sjc8Ovc9eqIWJCrUiSvv7+cS7ZTA9AgM1PxvHcsqrcUXiK3Jd/Dax9jdZE1e15s\nBEhb2OEPE+tClFZ+soj8h8Pl2Clo5OAppEzYI4LmFKtp1X/BOf62k4jviXuCSst3\nUnRJzE/CXtjmN6oZySVWSe0rQYuyqRl6//9nK40cfGKyxVnimB8XrrcxUN743Vud\nQQVU0Esm8OVTX013mXWQXJHP2c0aKkog8LOga0vobQIDAQABo2YwZDAOBgNVHQ8B\nAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQULmoOS1mFSjj+\nsnUPx4DgS3SkLFYwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\nKoZIhvcNAQELBQADggEBAAkVL2P1M2/G9GM3DANVAqYOwmX0Xk58YBHQu6iiQg4j\nb4Ky/qsZIsgT7YBsZA4AOcPKQFgGTWhe9pvhmXqoN3RYltN8Vn7TbUm/ZVDoMsrM\ngwv0+TKxW1/u7s8cXYfHPiTzVSJuOogHx99kBW6b2f99GbP7O1Sv3sLq4j6lVvBX\nFiacf5LAWC925nvlTzLlBgIc3O9xDtFeAGtZcEtxZJ4fnGXiqEnN4539+nqzIyYq\nnvlgCzyvcfRAxwltrJHuuRu6Maw5AGcd2Y0saMhqOVq9KYKFKuD/927BTrbd2JVf\n2sGWyuPZPCk3gq+5pCjbD0c6DkhcMGI6WwxvM5V/zSM=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICJDQwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTgxNzAz\nMTVaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyBldS13ZXN0LTMgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBAL9bL7KE0n02DLVtlZ2PL+g/BuHpMYFq2JnE2RgompGurDIZdjmh\n1pxfL3nT+QIVMubuAOy8InRfkRxfpxyjKYdfLJTPJG+jDVL+wDcPpACFVqoV7Prg\npVYEV0lc5aoYw4bSeYFhdzgim6F8iyjoPnObjll9mo4XsHzSoqJLCd0QC+VG9Fw2\nq+GDRZrLRmVM2oNGDRbGpGIFg77aRxRapFZa8SnUgs2AqzuzKiprVH5i0S0M6dWr\ni+kk5epmTtkiDHceX+dP/0R1NcnkCPoQ9TglyXyPdUdTPPRfKCq12dftqll+u4mV\nARdN6WFjovxax8EAP2OAUTi1afY+1JFMj+sCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFLfhrbrO5exkCVgxW0x3\nY2mAi8lNMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQAigQ5VBNGyw+OZFXwxeJEAUYaXVoP/qrhTOJ6mCE2DXUVEoJeV\nSxScy/TlFA9tJXqmit8JH8VQ/xDL4ubBfeMFAIAo4WzNWDVoeVMqphVEcDWBHsI1\nAETWzfsapRS9yQekOMmxg63d/nV8xewIl8aNVTHdHYXMqhhik47VrmaVEok1UQb3\nO971RadLXIEbVd9tjY5bMEHm89JsZDnDEw1hQXBb67Elu64OOxoKaHBgUH8AZn/2\nzFsL1ynNUjOhCSAA15pgd1vjwc0YsBbAEBPcHBWYBEyME6NLNarjOzBl4FMtATSF\nwWCKRGkvqN8oxYhwR2jf2rR5Mu4DWkK5Q8Ep\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICJVUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTkxODE2\nNTNaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyB1cy1lYXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBAM3i/k2u6cqbMdcISGRvh+m+L0yaSIoOXjtpNEoIftAipTUYoMhL\nInXGlQBVA4shkekxp1N7HXe1Y/iMaPEyb3n+16pf3vdjKl7kaSkIhjdUz3oVUEYt\ni8Z/XeJJ9H2aEGuiZh3kHixQcZczn8cg3dA9aeeyLSEnTkl/npzLf//669Ammyhs\nXcAo58yvT0D4E0D/EEHf2N7HRX7j/TlyWvw/39SW0usiCrHPKDLxByLojxLdHzso\nQIp/S04m+eWn6rmD+uUiRteN1hI5ncQiA3wo4G37mHnUEKo6TtTUh+sd/ku6a8HK\nglMBcgqudDI90s1OpuIAWmuWpY//8xEG2YECAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFPqhoWZcrVY9mU7tuemR\nRBnQIj1jMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQB6zOLZ+YINEs72heHIWlPZ8c6WY8MDU+Be5w1M+BK2kpcVhCUK\nPJO4nMXpgamEX8DIiaO7emsunwJzMSvavSPRnxXXTKIc0i/g1EbiDjnYX9d85DkC\nE1LaAUCmCZBVi9fIe0H2r9whIh4uLWZA41oMnJx/MOmo3XyMfQoWcqaSFlMqfZM4\n0rNoB/tdHLNuV4eIdaw2mlHxdWDtF4oH+HFm+2cVBUVC1jXKrFv/euRVtsTT+A6i\nh2XBHKxQ1Y4HgAn0jACP2QSPEmuoQEIa57bEKEcZsBR8SDY6ZdTd2HLRIApcCOSF\nMRM8CKLeF658I0XgF8D5EsYoKPsA+74Z+jDH\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEETCCAvmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZQxCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSUwIwYDVQQDDBxBbWF6b24gUkRTIEJldGEgUm9vdCAyMDE5IENBMB4XDTE5MDgy\nMDE3MTAwN1oXDTI0MDgxOTE3MzgyNlowgZkxCzAJBgNVBAYTAlVTMRMwEQYDVQQI\nDApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMSIwIAYDVQQKDBlBbWF6b24g\nV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMSowKAYDVQQD\nDCFBbWF6b24gUkRTIEJldGEgdXMtZWFzdC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3\nDQEBAQUAA4IBDwAwggEKAoIBAQDTNCOlotQcLP8TP82U2+nk0bExVuuMVOgFeVMx\nvbUHZQeIj9ikjk+jm6eTDnnkhoZcmJiJgRy+5Jt69QcRbb3y3SAU7VoHgtraVbxF\nQDh7JEHI9tqEEVOA5OvRrDRcyeEYBoTDgh76ROco2lR+/9uCvGtHVrMCtG7BP7ZB\nsSVNAr1IIRZZqKLv2skKT/7mzZR2ivcw9UeBBTUf8xsfiYVBvMGoEsXEycjYdf6w\nWV+7XS7teNOc9UgsFNN+9AhIBc1jvee5E//72/4F8pAttAg/+mmPUyIKtekNJ4gj\nOAR2VAzGx1ybzWPwIgOudZFHXFduxvq4f1hIRPH0KbQ/gkRrAgMBAAGjZjBkMA4G\nA1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBTkvpCD\n6C43rar9TtJoXr7q8dkrrjAfBgNVHSMEGDAWgBStoQwVpbGx87fxB3dEGDqKKnBT\n4TANBgkqhkiG9w0BAQsFAAOCAQEAJd9fOSkwB3uVdsS+puj6gCER8jqmhd3g/J5V\nZjk9cKS8H0e8pq/tMxeJ8kpurPAzUk5RkCspGt2l0BSwmf3ahr8aJRviMX6AuW3/\ng8aKplTvq/WMNGKLXONa3Sq8591J+ce8gtOX/1rDKmFI4wQ/gUzOSYiT991m7QKS\nFr6HMgFuz7RNJbb3Fy5cnurh8eYWA7mMv7laiLwTNsaro5qsqErD5uXuot6o9beT\na+GiKinEur35tNxAr47ax4IRubuIzyfCrezjfKc5raVV2NURJDyKP0m0CCaffAxE\nqn2dNfYc3v1D8ypg3XjHlOzRo32RB04o8ALHMD9LSwsYDLpMag==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEFzCCAv+gAwIBAgICFSUwDQYJKoZIhvcNAQELBQAwgZcxCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSgwJgYDVQQDDB9BbWF6b24gUkRTIFByZXZpZXcgUm9vdCAyMDE5IENBMB4XDTE5\nMDgyMTIyMzk0N1oXDTI0MDgyMTIyMjk0OVowgZwxCzAJBgNVBAYTAlVTMRMwEQYD\nVQQIDApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMSIwIAYDVQQKDBlBbWF6\nb24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMS0wKwYD\nVQQDDCRBbWF6b24gUkRTIFByZXZpZXcgdXMtZWFzdC0yIDIwMTkgQ0EwggEiMA0G\nCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQD0dB/U7qRnSf05wOi7m10Pa2uPMTJv\nr6U/3Y17a5prq5Zr4++CnSUYarG51YuIf355dKs+7Lpzs782PIwCmLpzAHKWzix6\npOaTQ+WZ0+vUMTxyqgqWbsBgSCyP7pVBiyqnmLC/L4az9XnscrbAX4pNaoJxsuQe\nmzBo6yofjQaAzCX69DuqxFkVTRQnVy7LCFkVaZtjNAftnAHJjVgQw7lIhdGZp9q9\nIafRt2gteihYfpn+EAQ/t/E4MnhrYs4CPLfS7BaYXBycEKC5Muj1l4GijNNQ0Efo\nxG8LSZz7SNgUvfVwiNTaqfLP3AtEAWiqxyMyh3VO+1HpCjT7uNBFtmF3AgMBAAGj\nZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQW\nBBQtinkdrj+0B2+qdXngV2tgHnPIujAfBgNVHSMEGDAWgBRp0xqULkNh/w2ZVzEI\no2RIY7O03TANBgkqhkiG9w0BAQsFAAOCAQEAtJdqbCxDeMc8VN1/RzCabw9BIL/z\n73Auh8eFTww/sup26yn8NWUkfbckeDYr1BrXa+rPyLfHpg06kwR8rBKyrs5mHwJx\nbvOzXD/5WTdgreB+2Fb7mXNvWhenYuji1MF+q1R2DXV3I05zWHteKX6Dajmx+Uuq\nYq78oaCBSV48hMxWlp8fm40ANCL1+gzQ122xweMFN09FmNYFhwuW+Ao+Vv90ZfQG\nPYwTvN4n/gegw2TYcifGZC2PNX74q3DH03DXe5fvNgRW5plgz/7f+9mS+YHd5qa9\ntYTPUvoRbi169ou6jicsMKUKPORHWhiTpSCWR1FMMIbsAcsyrvtIsuaGCQ==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIID/jCCAuagAwIBAgIQdOCSuA9psBpQd8EI368/0DANBgkqhkiG9w0BAQsFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIHNhLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTE5MTgwNjI2WhgPMjA2MTA1MTkxOTA2MjZaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgc2EtZWFzdC0xIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN6ftL6w8v3dB2yW\nLjCxSP1D7ZsOTeLZOSCz1Zv0Gkd0XLhil5MdHOHBvwH/DrXqFU2oGzCRuAy+aZis\nDardJU6ChyIQIciXCO37f0K23edhtpXuruTLLwUwzeEPdcnLPCX+sWEn9Y5FPnVm\npCd6J8edH2IfSGoa9LdErkpuESXdidLym/w0tWG/O2By4TabkNSmpdrCL00cqI+c\nprA8Bx1jX8/9sY0gpAovtuFaRN+Ivg3PAnWuhqiSYyQ5nC2qDparOWuDiOhpY56E\nEgmTvjwqMMjNtExfYx6Rv2Ndu50TriiNKEZBzEtkekwXInTupmYTvc7U83P/959V\nUiQ+WSMCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU4uYHdH0+\nbUeh81Eq2l5/RJbW+vswDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\nAQBhxcExJ+w74bvDknrPZDRgTeMLYgbVJjx2ExH7/Ac5FZZWcpUpFwWMIJJxtewI\nAnhryzM3tQYYd4CG9O+Iu0+h/VVfW7e4O3joWVkxNMb820kQSEwvZfA78aItGwOY\nWSaFNVRyloVicZRNJSyb1UL9EiJ9ldhxm4LTT0ax+4ontI7zTx6n6h8Sr6r/UOvX\nd9T5aUUENWeo6M9jGupHNn3BobtL7BZm2oS8wX8IVYj4tl0q5T89zDi2x0MxbsIV\n5ZjwqBQ5JWKv7ASGPb+z286RjPA9R2knF4lJVZrYuNV90rHvI/ECyt/JrDqeljGL\nBLl1W/UsvZo6ldLIpoMbbrb5\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEBDCCAuygAwIBAgIQUfVbqapkLYpUqcLajpTJWzANBgkqhkiG9w0BAQsFADCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIG1lLWNlbnRyYWwtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\nBAcMB1NlYXR0bGUwIBcNMjIwNTA2MjMyMDA5WhgPMjA2MjA1MDcwMDIwMDlaMIGa\nMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\nLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\nYXpvbiBSRFMgbWUtY2VudHJhbC0xIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJIeovu3\newI9FVitXMQzvkh34aQ6WyI4NO3YepfJaePiv3cnyFGYHN2S1cR3UQcLWgypP5va\nj6bfroqwGbCbZZcb+6cyOB4ceKO9Ws1UkcaGHnNDcy5gXR7aCW2OGTUfinUuhd2d\n5bOGgV7JsPbpw0bwJ156+MwfOK40OLCWVbzy8B1kITs4RUPNa/ZJnvIbiMu9rdj4\n8y7GSFJLnKCjlOFUkNI5LcaYvI1+ybuNgphT3nuu5ZirvTswGakGUT/Q0J3dxP0J\npDfg5Sj/2G4gXiaM0LppVOoU5yEwVewhQ250l0eQAqSrwPqAkdTg9ng360zqCFPE\nJPPcgI1tdGUgneECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU\n/2AJVxWdZxc8eJgdpbwpW7b0f7IwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEB\nCwUAA4IBAQBYm63jTu2qYKJ94gKnqc+oUgqmb1mTXmgmp/lXDbxonjszJDOXFbri\n3CCO7xB2sg9bd5YWY8sGKHaWmENj3FZpCmoefbUx++8D7Mny95Cz8R32rNcwsPTl\nebpd9A/Oaw5ug6M0x/cNr0qzF8Wk9Dx+nFEimp8RYQdKvLDfNFZHjPa1itnTiD8M\nTorAqj+VwnUGHOYBsT/0NY12tnwXdD+ATWfpEHdOXV+kTMqFFwDyhfgRVNpTc+os\nygr8SwhnSCpJPB/EYl2S7r+tgAbJOkuwUvGT4pTqrzDQEhwE7swgepnHC87zhf6l\nqN6mVpSnQKQLm6Ob5TeCEFgcyElsF5bH\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICrjCCAjSgAwIBAgIRAOxu0I1QuMAhIeszB3fJIlkwCgYIKoZIzj0EAwMwgZYx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\nem9uIFJEUyB1cy13ZXN0LTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTI0MjIwNjU5WhgPMjEyMTA1MjQyMzA2NTlaMIGWMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\nRFMgdXMtd2VzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\nMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEz4bylRcGqqDWdP7gQIIoTHdBK6FNtKH1\n4SkEIXRXkYDmRvL9Bci1MuGrwuvrka5TDj4b7e+csY0llEzHpKfq6nJPFljoYYP9\nuqHFkv77nOpJJ633KOr8IxmeHW5RXgrZo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\nA1UdDgQWBBQQikVz8wmjd9eDFRXzBIU8OseiGzAOBgNVHQ8BAf8EBAMCAYYwCgYI\nKoZIzj0EAwMDaAAwZQIwf06Mcrpw1O0EBLBBrp84m37NYtOkE/0Z0O+C7D41wnXi\nEQdn6PXUVgdD23Gj82SrAjEAklhKs+liO1PtN15yeZR1Io98nFve+lLptaLakZcH\n+hfFuUtCqMbaI8CdvJlKnPqT\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGCTCCA/GgAwIBAgIRALyWMTyCebLZOGcZZQmkmfcwDQYJKoZIhvcNAQEMBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI0MjAyODAzWhgPMjEyMTA1MjQyMTI4MDNa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTMgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\nwGFiyDyCrGqgdn4fXG12cxKAAfVvhMea1mw5h9CVRoavkPqhzQpAitSOuMB9DeiP\nwQyqcsiGl/cTEau4L+AUBG8b9v26RlY48exUYBXj8CieYntOT9iNw5WtdYJa3kF/\nJxgI+HDMzE9cmHDs5DOO3S0uwZVyra/xE1ymfSlpOeUIOTpHRJv97CBUEpaZMUW5\nSr6GruuOwFVpO5FX3A/jQlcS+UN4GjSRgDUJuqg6RRQldEZGCVCCmodbByvI2fGm\nreGpsPJD54KkmAX08nOR8e5hkGoHxq0m2DLD4SrOFmt65vG47qnuwplWJjtk9B3Z\n9wDoopwZLBOtlkPIkUllWm1P8EuHC1IKOA+wSP6XdT7cy8S77wgyHzR0ynxv7q/l\nvlZtH30wnNqFI0y9FeogD0TGMCHcnGqfBSicJXPy9T4fU6f0r1HwqKwPp2GArwe7\ndnqLTj2D7M9MyVtFjEs6gfGWXmu1y5uDrf+CszurE8Cycoma+OfjjuVQgWOCy7Nd\njJswPxAroTzVfpgoxXza4ShUY10woZu0/J+HmNmqK7lh4NS75q1tz75in8uTZDkV\nbe7GK+SEusTrRgcf3tlgPjSTWG3veNzFDF2Vn1GLJXmuZfhdlVQDBNXW4MNREExS\ndG57kJjICpT+r8X+si+5j51gRzkSnMYs7VHulpxfcwECAwEAAaNCMEAwDwYDVR0T\nAQH/BAUwAwEB/zAdBgNVHQ4EFgQU4JWOpDBmUBuWKvGPZelw87ezhL8wDgYDVR0P\nAQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQBRNLMql7itvXSEFQRAnyOjivHz\nl5IlWVQjAbOUr6ogZcwvK6YpxNAFW5zQr8F+fdkiypLz1kk5irx9TIpff0BWC9hQ\n/odMPO8Gxn8+COlSvc+dLsF2Dax3Hvz0zLeKMo+cYisJOzpdR/eKd0/AmFdkvQoM\nAOK9n0yYvVJU2IrSgeJBiiCarpKSeAktEVQ4rvyacQGr+QAPkkjRwm+5LHZKK43W\nnNnggRli9N/27qYtc5bgr3AaQEhEXMI4RxPRXCLsod0ehMGWyRRK728a+6PMMJAJ\nWHOU0x7LCEMPP/bvpLj3BdvSGqNor4ZtyXEbwREry1uzsgODeRRns5acPwTM6ff+\nCmxO2NZ0OktIUSYRmf6H/ZFlZrIhV8uWaIwEJDz71qvj7buhQ+RFDZ9CNL64C0X6\nmf0zJGEpddjANHaaVky+F4gYMtEy2K2Lcm4JGTdyIzUoIe+atzCnRp0QeIcuWtF+\ns8AjDYCVFNypcMmqbRmNpITSnOoCHSRuVkY3gutVoYyMLbp8Jm9SJnCIlEWTA6Rm\nwADOMGZJVn5/XRTRuetVOB3KlQDjs9OO01XN5NzGSZO2KT9ngAUfh9Eqhf1iRWSP\nnZlRbQ2NRCuY/oJ5N59mLGxnNJSE7giEKEBRhTQ/XEPIUYAUPD5fca0arKRJwbol\nl9Se1Hsq0ZU5f+OZKQ==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGATCCA+mgAwIBAgIRAK7vlRrGVEePJpW1VHMXdlIwDQYJKoZIhvcNAQEMBQAw\ngZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\nQW1hem9uIFJEUyBhZi1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMTA1MTkxOTI4NDNaGA8yMTIxMDUxOTIwMjg0M1owgZgx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\nem9uIFJEUyBhZi1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMZiHOQC6x4o\neC7vVOMCGiN5EuLqPYHdceFPm4h5k/ZejXTf7kryk6aoKZKsDIYihkaZwXVS7Y/y\n7Ig1F1ABi2jD+CYprj7WxXbhpysmN+CKG7YC3uE4jSvfvUnpzionkQbjJsRJcrPO\ncZJM4FVaVp3mlHHtvnM+K3T+ni4a38nAd8xrv1na4+B8ZzZwWZXarfg8lJoGskSn\nou+3rbGQ0r+XlUP03zWujHoNlVK85qUIQvDfTB7n3O4s1XNGvkfv3GNBhYRWJYlB\n4p8T+PFN8wG+UOByp1gV7BD64RnpuZ8V3dRAlO6YVAmINyG5UGrPzkIbLtErUNHO\n4iSp4UqYvztDqJWWHR/rA84ef+I9RVwwZ8FQbjKq96OTnPrsr63A5mXTC9dXKtbw\nXNJPQY//FEdyM3K8sqM0IdCzxCA1MXZ8+QapWVjwyTjUwFvL69HYky9H8eAER59K\n5I7u/CWWeCy2R1SYUBINc3xxLr0CGGukcWPEZW2aPo5ibW5kepU1P/pzdMTaTfao\nF42jSFXbc7gplLcSqUgWwzBnn35HLTbiZOFBPKf6vRRu8aRX9atgHw/EjCebi2xP\nxIYr5Ub8u0QVHIqcnF1/hVzO/Xz0chj3E6VF/yTXnsakm+W1aM2QkZbFGpga+LMy\nmFCtdPrELjea2CfxgibaJX1Q4rdEpc8DAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wHQYDVR0OBBYEFDSaycEyuspo/NOuzlzblui8KotFMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQwFAAOCAgEAbosemjeTRsL9o4v0KadBUNS3V7gdAH+X4vH2\nEe1Jc91VOGLdd/s1L9UX6bhe37b9WjUD69ur657wDW0RzxMYgQdZ27SUl0tEgGGp\ncCmVs1ky3zEN+Hwnhkz+OTmIg1ufq0W2hJgJiluAx2r1ib1GB+YI3Mo3rXSaBYUk\nbgQuujYPctf0PA153RkeICE5GI3OaJ7u6j0caYEixBS3PDHt2MJWexITvXGwHWwc\nCcrC05RIrTUNOJaetQw8smVKYOfRImEzLLPZ5kf/H3Cbj8BNAFNsa10wgvlPuGOW\nXLXqzNXzrG4V3sjQU5YtisDMagwYaN3a6bBf1wFwFIHQoAPIgt8q5zaQ9WI+SBns\nIl6rd4zfvjq/BPmt0uI7rVg/cgbaEg/JDL2neuM9CJAzmKxYxLQuHSX2i3Fy4Y1B\ncnxnRQETCRZNPGd00ADyxPKVoYBC45/t+yVusArFt+2SVLEGiFBr23eG2CEZu+HS\nnDEgIfQ4V3YOTUNa86wvbAss1gbbnT/v1XCnNGClEWCWNCSRjwV2ZmQ/IVTmNHPo\n7axTTBBJbKJbKzFndCnuxnDXyytdYRgFU7Ly3sa27WS2KFyFEDebLFRHQEfoYqCu\nIupSqBSbXsR3U10OTjc9z6EPo1nuV6bdz+gEDthmxKa1NI+Qb1kvyliXQHL2lfhr\n5zT5+Bs=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIF/zCCA+egAwIBAgIRAOLV6zZcL4IV2xmEneN1GwswDQYJKoZIhvcNAQEMBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyB1cy13ZXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUxOTE5MDg1OFoYDzIxMjEwNTE5MjAwODU4WjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIHVzLXdlc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC7koAKGXXlLixN\nfVjhuqvz0WxDeTQfhthPK60ekRpftkfE5QtnYGzeovaUAiS58MYVzqnnTACDwcJs\nIGTFE6Wd7sB6r8eI/3CwI1pyJfxepubiQNVAQG0zJETOVkoYKe/5KnteKtnEER3X\ntCBRdV/rfbxEDG9ZAsYfMl6zzhEWKF88G6xhs2+VZpDqwJNNALvQuzmTx8BNbl5W\nRUWGq9CQ9GK9GPF570YPCuURW7kl35skofudE9bhURNz51pNoNtk2Z3aEeRx3ouT\nifFJlzh+xGJRHqBG7nt5NhX8xbg+vw4xHCeq1aAe6aVFJ3Uf9E2HzLB4SfIT9bRp\nP7c9c0ySGt+3n+KLSHFf/iQ3E4nft75JdPjeSt0dnyChi1sEKDi0tnWGiXaIg+J+\nr1ZtcHiyYpCB7l29QYMAdD0TjfDwwPayLmq//c20cPmnSzw271VwqjUT0jYdrNAm\ngV+JfW9t4ixtE3xF2jaUh/NzL3bAmN5v8+9k/aqPXlU1BgE3uPwMCjrfn7V0I7I1\nWLpHyd9jF3U/Ysci6H6i8YKgaPiOfySimQiDu1idmPld659qerutUSemQWmPD3bE\ndcjZolmzS9U0Ujq/jDF1YayN3G3xvry1qWkTci0qMRMu2dZu30Herugh9vsdTYkf\n00EqngPbqtIVLDrDjEQLqPcb8QvWFQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\nMB0GA1UdDgQWBBQBqg8Za/L0YMHURGExHfvPyfLbOTAOBgNVHQ8BAf8EBAMCAYYw\nDQYJKoZIhvcNAQEMBQADggIBACAGPMa1QL7P/FIO7jEtMelJ0hQlQepKnGtbKz4r\nXq1bUX1jnLvnAieR9KZmeQVuKi3g3CDU6b0mDgygS+FL1KDDcGRCSPh238Ou8KcG\nHIxtt3CMwMHMa9gmdcMlR5fJF9vhR0C56KM2zvyelUY51B/HJqHwGvWuexryXUKa\nwq1/iK2/d9mNeOcjDvEIj0RCMI8dFQCJv3PRCTC36XS36Tzr6F47TcTw1c3mgKcs\nxpcwt7ezrXMUunzHS4qWAA5OGdzhYlcv+P5GW7iAA7TDNrBF+3W4a/6s9v2nQAnX\nUvXd9ul0ob71377UhZbJ6SOMY56+I9cJOOfF5QvaL83Sz29Ij1EKYw/s8TYdVqAq\n+dCyQZBkMSnDFLVe3J1KH2SUSfm3O98jdPORQrUlORQVYCHPls19l2F6lCmU7ICK\nhRt8EVSpXm4sAIA7zcnR2nU00UH8YmMQLnx5ok9YGhuh3Ehk6QlTQLJux6LYLskd\n9YHOLGW/t6knVtV78DgPqDeEx/Wu/5A8R0q7HunpWxr8LCPBK6hksZnOoUhhb8IP\nvl46Ve5Tv/FlkyYr1RTVjETmg7lb16a8J0At14iLtpZWmwmuv4agss/1iBVMXfFk\n+ZGtx5vytWU5XJmsfKA51KLsMQnhrLxb3X3zC+JRCyJoyc8++F3YEcRi2pkRYE3q\nHing\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgIRANxgyBbnxgTEOpDul2ZnC0UwDQYJKoZIhvcNAQELBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMyBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNjEwMTgxOTA3WhgPMjA2MTA2MTAxOTE5MDda\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTMgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\nxnwSDAChrMkfk5TA4Dk8hKzStDlSlONzmd3fTG0Wqr5+x3EmFT6Ksiu/WIwEl9J2\nK98UI7vYyuZfCxUKb1iMPeBdVGqk0zb92GpURd+Iz/+K1ps9ZLeGBkzR8mBmAi1S\nOfpwKiTBzIv6E8twhEn4IUpHsdcuX/2Y78uESpJyM8O5CpkG0JaV9FNEbDkJeBUQ\nAo2qqNcH4R0Qcr5pyeqA9Zto1RswgL06BQMI9dTpfwSP5VvkvcNUaLl7Zv5WzLQE\nJzORWePvdPzzvWEkY/3FPjxBypuYwssKaERW0fkPDmPtykktP9W/oJolKUFI6pXp\ny+Y6p6/AVdnQD2zZjW5FhQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\nDgQWBBT+jEKs96LC+/X4BZkUYUkzPfXdqTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\nhvcNAQELBQADggEBAIGQqgqcQ6XSGkmNebzR6DhadTbfDmbYeN5N0Vuzv+Tdmufb\ntMGjdjnYMg4B+IVnTKQb+Ox3pL9gbX6KglGK8HupobmIRtwKVth+gYYz3m0SL/Nk\nhaWPYzOm0x3tJm8jSdufJcEob4/ATce9JwseLl76pSWdl5A4lLjnhPPKudUDfH+1\nBLNUi3lxpp6GkC8aWUPtupnhZuXddolTLOuA3GwTZySI44NfaFRm+o83N1jp+EwD\n6e94M4cTRzjUv6J3MZmSbdtQP/Tk1uz2K4bQZGP0PZC3bVpqiesdE/xr+wbu8uHr\ncM1JXH0AmXf1yIkTgyWzmvt0k1/vgcw5ixAqvvE=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEATCCAumgAwIBAgIRAMhw98EQU18mIji+unM2YH8wDQYJKoZIhvcNAQELBQAw\ngZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\nQW1hem9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMjA2MDYyMTQyMjJaGA8yMDYyMDYwNjIyNDIyMlowgZgx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\nem9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAIeeRoLfTm+7\nvqm7ZlFSx+1/CGYHyYrOOryM4/Z3dqYVHFMgWTR7V3ziO8RZ6yUanrRcWVX3PZbF\nAfX0KFE8OgLsXEZIX8odSrq86+/Th5eZOchB2fDBsUB7GuN2rvFBbM8lTI9ivVOU\nlbuTnYyb55nOXN7TpmH2bK+z5c1y9RVC5iQsNAl6IJNvSN8VCqXh31eK5MlKB4DT\n+Y3OivCrSGsjM+UR59uZmwuFB1h+icE+U0p9Ct3Mjq3MzSX5tQb6ElTNGlfmyGpW\nKh7GQ5XU1KaKNZXoJ37H53woNSlq56bpVrKI4uv7ATpdpFubOnSLtpsKlpLdR3sy\nWs245200pC8CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUp0ki\n6+eWvsnBjQhMxwMW5pwn7DgwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUA\nA4IBAQB2V8lv0aqbYQpj/bmVv/83QfE4vOxKCJAHv7DQ35cJsTyBdF+8pBczzi3t\n3VNL5IUgW6WkyuUOWnE0eqAFOUVj0yTS1jSAtfl3vOOzGJZmWBbqm9BKEdu1D8O6\nsB8bnomwiab2tNDHPmUslpdDqdabbkWwNWzLJ97oGFZ7KNODMEPXWKWNxg33iHfS\n/nlmnrTVI3XgaNK9qLZiUrxu9Yz5gxi/1K+sG9/Dajd32ZxjRwDipOLiZbiXQrsd\nqzIMY4GcWf3g1gHL5mCTfk7dG22h/rhPyGV0svaDnsb+hOt6sv1McMN6Y3Ou0mtM\n/UaAXojREmJmTSCNvs2aBny3/2sy\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICrjCCAjSgAwIBAgIRAMnRxsKLYscJV8Qv5pWbL7swCgYIKoZIzj0EAwMwgZYx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\nem9uIFJEUyBzYS1lYXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTE5MTgxNjAxWhgPMjEyMTA1MTkxOTE2MDFaMIGWMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\nRFMgc2EtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\nMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEjFOCZgTNVKxLKhUxffiDEvTLFhrmIqdO\ndKqVdgDoELEzIHWDdC+19aDPitbCYtBVHl65ITu/9pn6mMUl5hhUNtfZuc6A+Iw1\nsBe0v0qI3y9Q9HdQYrGgeHDh8M5P7E2ho0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\nA1UdDgQWBBS5L7/8M0TzoBZk39Ps7BkfTB4yJTAOBgNVHQ8BAf8EBAMCAYYwCgYI\nKoZIzj0EAwMDaAAwZQIwI43O0NtWKTgnVv9z0LO5UMZYgSve7GvGTwqktZYCMObE\nrUI4QerXM9D6JwLy09mqAjEAypfkdLyVWtaElVDUyHFkihAS1I1oUxaaDrynLNQK\nOu/Ay+ns+J+GyvyDUjBpVVW1\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIF/jCCA+agAwIBAgIQR71Z8lTO5Sj+as2jB7IWXzANBgkqhkiG9w0BAQwFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIHVzLXdlc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTI0MjIwMzIwWhgPMjEyMTA1MjQyMzAzMjBaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgdXMtd2VzdC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAM977bHIs1WJijrS\nXQMfUOhmlJjr2v0K0UjPl52sE1TJ76H8umo1yR4T7Whkd9IwBHNGKXCJtJmMr9zp\nfB38eLTu+5ydUAXdFuZpRMKBWwPVe37AdJRKqn5beS8HQjd3JXAgGKUNNuE92iqF\nqi2fIqFMpnJXWo0FIW6s2Dl2zkORd7tH0DygcRi7lgVxCsw1BJQhFJon3y+IV8/F\nbnbUXSNSDUnDW2EhvWSD8L+t4eiXYsozhDAzhBvojpxhPH9OB7vqFYw5qxFx+G0t\nlSLX5iWi1jzzc3XyGnB6WInZDVbvnvJ4BGZ+dTRpOCvsoMIn9bz4EQTvu243c7aU\nHbS/kvnCASNt+zk7C6lbmaq0AGNztwNj85Opn2enFciWZVnnJ/4OeefUWQxD0EPp\nSjEd9Cn2IHzkBZrHCg+lWZJQBKbUVS0lLIMSsLQQ6WvR38jY7D2nxM1A93xWxwpt\nZtQnYRCVXH6zt2OwDAFePInWwxUjR5t/wu3XxPgpSfrmTi3WYtr1wFypAJ811e/P\nyBtswWUQ6BNJQvy+KnOEeGfOwmtdDFYR+GOCfvCihzrKJrxOtHIieehR5Iw3cbXG\nsm4pDzfMUVvDDz6C2M6PRlJhhClbatHCjik9hxFYEsAlqtVVK9pxaz9i8hOqSFQq\nkJSQsgWw+oM/B2CyjcSqkSQEu8RLAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\nHQYDVR0OBBYEFPmrdxpRRgu3IcaB5BTqlprcKdTsMA4GA1UdDwEB/wQEAwIBhjAN\nBgkqhkiG9w0BAQwFAAOCAgEAVdlxWjPvVKky3kn8ZizeM4D+EsLw9dWLau2UD/ls\nzwDCFoT6euagVeCknrn+YEl7g20CRYT9iaonGoMUPuMR/cdtPL1W/Rf40PSrGf9q\nQuxavWiHLEXOQTCtCaVZMokkvjuuLNDXyZnstgECuiZECTwhexUF4oiuhyGk9o01\nQMaiz4HX4lgk0ozALUvEzaNd9gWEwD2qe+rq9cQMTVq3IArUkvTIftZUaVUMzr0O\ned1+zAsNa9nJhURJ/6anJPJjbQgb5qA1asFcp9UaMT1ku36U3gnR1T/BdgG2jX3X\nUm0UcaGNVPrH1ukInWW743pxWQb7/2sumEEMVh+jWbB18SAyLI4WIh4lkurdifzS\nIuTFp8TEx+MouISFhz/vJDWZ84tqoLVjkEcP6oDypq9lFoEzHDJv3V1CYcIgOusT\nk1jm9P7BXdTG7TYzUaTb9USb6bkqkD9EwJAOSs7DI94aE6rsSws2yAHavjAMfuMZ\nsDAZvkqS2Qg2Z2+CI6wUZn7mzkJXbZoqRjDvChDXEB1mIhzVXhiNW/CR5WKVDvlj\n9v1sdGByh2pbxcLQtVaq/5coM4ANgphoNz3pOYUPWHS+JUrIivBZ+JobjXcxr3SN\n9iDzcu5/FVVNbq7+KN/nvPMngT+gduEN5m+EBjm8GukJymFG0m6BENRA0QSDqZ7k\nzDY=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgIRAK5EYG3iHserxMqgg+0EFjgwDQYJKoZIhvcNAQELBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI0MjAyMzE2WhgPMjA2MTA1MjQyMTIzMTZa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTMgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\ns1L6TtB84LGraLHVC+rGPhLBW2P0oN/91Rq3AnYwqDOuTom7agANwEjvLq7dSRG/\nsIfZsSV/ABTgArZ5sCmLjHFZAo8Kd45yA9byx20RcYtAG8IZl+q1Cri+s0XefzyO\nU6mlfXZkVe6lzjlfXBkrlE/+5ifVbJK4dqOS1t9cWIpgKqv5fbE6Qbq4LVT+5/WM\nVd2BOljuBMGMzdZubqFKFq4mzTuIYfnBm7SmHlZfTdfBYPP1ScNuhpjuzw4n3NCR\nEdU6dQv04Q6th4r7eiOCwbWI9LkmVbvBe3ylhH63lApC7MiiPYLlB13xBubVHVhV\nq1NHoNTi+zA3MN9HWicRxQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\nDgQWBBSuxoqm0/wjNiZLvqv+JlQwsDvTPDAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\nhvcNAQELBQADggEBAFfTK/j5kv90uIbM8VaFdVbr/6weKTwehafT0pAk1bfLVX+7\nuf8oHgYiyKTTl0DFQicXejghXTeyzwoEkWSR8c6XkhD5vYG3oESqmt/RGvvoxz11\nrHHy7yHYu7RIUc3VQG60c4qxXv/1mWySGwVwJrnuyNT9KZXPevu3jVaWOVHEILaK\nHvzQ2YEcWBPmde/zEseO2QeeGF8FL45Q1d66wqIP4nNUd2pCjeTS5SpB0MMx7yi9\nki1OH1pv8tOuIdimtZ7wkdB8+JSZoaJ81b8sRrydRwJyvB88rftuI3YB4WwGuONT\nZezUPsmaoK69B0RChB0ofDpAaviF9V3xOWvVZfo=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGDzCCA/egAwIBAgIRAI0sMNG2XhaBMRN3zD7ZyoEwDQYJKoZIhvcNAQEMBQAw\ngZ8xCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE4MDYGA1UEAwwv\nQW1hem9uIFJEUyBQcmV2aWV3IHVzLWVhc3QtMiBSb290IENBIFJTQTQwOTYgRzEx\nEDAOBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTE4MjA1NzUwWhgPMjEyMTA1MTgyMTU3\nNTBaMIGfMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExODA2BgNV\nBAMML0FtYXpvbiBSRFMgUHJldmlldyB1cy1lYXN0LTIgUm9vdCBDQSBSU0E0MDk2\nIEcxMRAwDgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC\nCgKCAgEAh/otSiCu4Uw3hu7OJm0PKgLsLRqBmUS6jihcrkxfN2SHmp2zuRflkweU\nBhMkebzL+xnNvC8okzbgPWtUxSmDnIRhE8J7bvSKFlqs/tmEdiI/LMqe/YIKcdsI\n20UYmvyLIjtDaJIh598SHHlF9P8DB5jD8snJfhxWY+9AZRN+YVTltgQAAgayxkWp\nM1BbvxpOnz4CC00rE0eqkguXIUSuobb1vKqdKIenlYBNxm2AmtgvQfpsBIQ0SB+8\n8Zip8Ef5rtjSw5J3s2Rq0aYvZPfCVIsKYepIboVwXtD7E9J31UkB5onLBQlaHaA6\nXlH4srsMmrew5d2XejQGy/lGZ1nVWNsKO0x/Az2QzY5Kjd6AlXZ8kq6H68hscA5i\nOMbNlXzeEQsZH0YkId3+UsEns35AAjZv4qfFoLOu8vDotWhgVNT5DfdbIWZW3ZL8\nqbmra3JnCHuaTwXMnc25QeKgVq7/rG00YB69tCIDwcf1P+tFJWxvaGtV0g2NthtB\na+Xo09eC0L53gfZZ3hZw1pa3SIF5dIZ6RFRUQ+lFOux3Q/I3u+rYstYw7Zxc4Zeo\nY8JiedpQXEAnbw2ECHix/L6mVWgiWCiDzBnNLLdbmXjJRnafNSndSfFtHCnY1SiP\naCrNpzwZIJejoV1zDlWAMO+gyS28EqzuIq3WJK/TFE7acHkdKIcCAwEAAaNCMEAw\nDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUrmV1YASnuudfmqAZP4sKGTvScaEw\nDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQBGpEKeQoPvE85tN/25\nqHFkys9oHDl93DZ62EnOqAUKLd6v0JpCyEiop4nlrJe+4KrBYVBPyKOJDcIqE2Sp\n3cvgJXLhY4i46VM3Qxe8yuYF1ElqBpg3jJVj/sCQnYz9dwoAMWIJFaDWOvmU2E7M\nMRaKx+sPXFkIjiDA6Bv0m+VHef7aedSYIY7IDltEQHuXoqNacGrYo3I50R+fZs88\n/mB3e/V7967e99D6565yf9Lcjw4oQf2Hy7kl/6P9AuMz0LODnGITwh2TKk/Zo3RU\nVgq25RDrT4xJK6nFHyjUF6+4cOBxVpimmFw/VP1zaXT8DN5r4HyJ9p4YuSK8ha5N\n2pJc/exvU8Nv2+vS/efcDZWyuEdZ7eh1IJWQZlOZKIAONfRDRTpeQHJ3zzv3QVYy\nt78pYp/eWBHyVIfEE8p2lFKD4279WYe+Uvdb8c4Jm4TJwqkSJV8ifID7Ub80Lsir\nlPAU3OCVTBeVRFPXT2zpC4PB4W6KBSuj6OOcEu2y/HgWcoi7Cnjvp0vFTUhDFdus\nWz3ucmJjfVsrkEO6avDKu4SwdbVHsk30TVAwPd6srIdi9U6MOeOQSOSE4EsrrS7l\nSVmu2QIDUVFpm8QAHYplkyWIyGkupyl3ashH9mokQhixIU/Pzir0byePxHLHrwLu\n1axqeKpI0F5SBUPsaVNYY2uNFg==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECDCCAvCgAwIBAgIQCREfzzVyDTMcNME+gWnTCTANBgkqhkiG9w0BAQsFADCB\nnDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\nbWF6b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4G\nA1UEBwwHU2VhdHRsZTAgFw0yMTA1MjQyMDQyMzNaGA8yMDYxMDUyNDIxNDIzM1ow\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDL\n1MT6br3L/4Pq87DPXtcjlXN3cnbNk2YqRAZHJayStTz8VtsFcGPJOpk14geRVeVk\ne9uKFHRbcyr/RM4owrJTj5X4qcEuATYZbo6ou/rW2kYzuWFZpFp7lqm0vasV4Z9F\nfChlhwkNks0UbM3G+psCSMNSoF19ERunj7w2c4E62LwujkeYLvKGNepjnaH10TJL\n2krpERd+ZQ4jIpObtRcMH++bTrvklc+ei8W9lqrVOJL+89v2piN3Ecdd389uphst\nqQdb1BBVXbhUrtuGHgVf7zKqN1SkCoktoWxVuOprVWhSvr7akaWeq0UmlvbEsujU\nvADqxGMcJFyCzxx3CkJjAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0O\nBBYEFFk8UJmlhoxFT3PP12PvhvazHjT4MA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG\n9w0BAQsFAAOCAQEAfFtr2lGoWVXmWAsIo2NYre7kzL8Xb9Tx7desKxCCz5HOOvIr\n8JMB1YK6A7IOvQsLJQ/f1UnKRh3X3mJZjKIywfrMSh0FiDf+rjcEzXxw2dGtUem4\nA+WMvIA3jwxnJ90OQj5rQ8bg3iPtE6eojzo9vWQGw/Vu48Dtw1DJo9210Lq/6hze\nhPhNkFh8fMXNT7Q1Wz/TJqJElyAQGNOXhyGpHKeb0jHMMhsy5UNoW5hLeMS5ffao\nTBFWEJ1gVfxIU9QRxSh+62m46JIg+dwDlWv8Aww14KgepspRbMqDuaM2cinoejv6\nt3dyOyHHrsOyv3ffZUKtQhQbQr+sUcL89lARsg==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIID/zCCAuegAwIBAgIRAIJLTMpzGNxqHZ4t+c1MlCIwDQYJKoZIhvcNAQELBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyBhcC1lYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyNTIxMzAzM1oYDzIwNjEwNTI1MjIzMDMzWjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGFwLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDtdHut0ZhJ9Nn2\nMpVafFcwHdoEzx06okmmhjJsNy4l9QYVeh0UUoek0SufRNMRF4d5ibzpgZol0Y92\n/qKWNe0jNxhEj6sXyHsHPeYtNBPuDMzThfbvsLK8z7pBP7vVyGPGuppqW/6m4ZBB\nlcc9fsf7xpZ689iSgoyjiT6J5wlVgmCx8hFYc/uvcRtfd8jAHvheug7QJ3zZmIye\nV4htOW+fRVWnBjf40Q+7uTv790UAqs0Zboj4Yil+hER0ibG62y1g71XcCyvcVpto\n2/XW7Y9NCgMNqQ7fGN3wR1gjtSYPd7DO32LTzYhutyvfbpAZjsAHnoObmoljcgXI\nQjfBcCFpAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJI3aWLg\nCS5xqU5WYVaeT5s8lpO0MA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\nAQEAUwATpJOcGVOs3hZAgJwznWOoTzOVJKfrqBum7lvkVH1vBwxBl9CahaKj3ZOt\nYYp2qJzhDUWludL164DL4ZjS6eRedLRviyy5cRy0581l1MxPWTThs27z+lCC14RL\nPJZNVYYdl7Jy9Q5NsQ0RBINUKYlRY6OqGDySWyuMPgno2GPbE8aynMdKP+f6G/uE\nYHOf08gFDqTsbyfa70ztgVEJaRooVf5JJq4UQtpDvVswW2reT96qi6tXPKHN5qp3\n3wI0I1Mp4ePmiBKku2dwYzPfrJK/pQlvu0Gu5lKOQ65QdotwLAAoaFqrf9za1yYs\nINUkHLWIxDds+4OHNYcerGp5Dw==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGCTCCA/GgAwIBAgIRAIO6ldra1KZvNWJ0TA1ihXEwDQYJKoZIhvcNAQEMBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIxMjE0NTA1WhgPMjEyMTA1MjEyMjQ1MDVa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\nsDN52Si9pFSyZ1ruh3xAN0nVqEs960o2IK5CPu/ZfshFmzAwnx/MM8EHt/jMeZtj\nSM58LADAsNDL01ELpFZATjgZQ6xNAyXRXE7RiTRUvNkK7O3o2qAGbLnJq/UqF7Sw\nLRnB8V6hYOv+2EjVnohtGCn9SUFGZtYDjWXsLd4ML4Zpxv0a5LK7oEC7AHzbUR7R\njsjkrXqSv7GE7bvhSOhMkmgxgj1F3J0b0jdQdtyyj109aO0ATUmIvf+Bzadg5AI2\nA9UA+TUcGeebhpHu8AP1Hf56XIlzPpaQv3ZJ4vzoLaVNUC7XKzAl1dlvCl7Klg/C\n84qmbD/tjZ6GHtzpLKgg7kQEV7mRoXq8X4wDX2AFPPQl2fv+Kbe+JODqm5ZjGegm\nuskABBi8IFv1hYx9jEulZPxC6uD/09W2+niFm3pirnlWS83BwVDTUBzF+CooUIMT\njhWkIIZGDDgMJTzouBHfoSJtS1KpUZi99m2WyVs21MNKHeWAbs+zmI6TO5iiMC+T\nuB8spaOiHFO1573Fmeer4sy3YA6qVoqVl6jjTQqOdy3frAMbCkwH22/crV8YA+08\nhLeHXrMK+6XUvU+EtHAM3VzcrLbuYJUI2XJbzTj5g0Eb8I8JWsHvWHR5K7Z7gceR\n78AzxQmoGEfV6KABNWKsgoCQnfb1BidDJIe3BsI0A6UCAwEAAaNCMEAwDwYDVR0T\nAQH/BAUwAwEB/zAdBgNVHQ4EFgQUABp0MlB14MSHgAcuNSOhs3MOlUcwDgYDVR0P\nAQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQCv4CIOBSQi/QR9NxdRgVAG/pAh\ntFJhV7OWb/wqwsNKFDtg6tTxwaahdCfWpGWId15OUe7G9LoPiKiwM9C92n0ZeHRz\n4ewbrQVo7Eu1JI1wf0rnZJISL72hVYKmlvaWaacHhWxvsbKLrB7vt6Cknxa+S993\nKf8i2Psw8j5886gaxhiUtzMTBwoDWak8ZaK7m3Y6C6hXQk08+3pnIornVSFJ9dlS\nPAqt5UPwWmrEfF+0uIDORlT+cvrAwgSp7nUF1q8iasledycZ/BxFgQqzNwnkBDwQ\nZ/aM52ArGsTzfMhkZRz9HIEhz1/0mJw8gZtDVQroD8778h8zsx2SrIz7eWQ6uWsD\nQEeSWXpcheiUtEfzkDImjr2DLbwbA23c9LoexUD10nwohhoiQQg77LmvBVxeu7WU\nE63JqaYUlOLOzEmNJp85zekIgR8UTkO7Gc+5BD7P4noYscI7pPOL5rP7YLg15ZFi\nega+G53NTckRXz4metsd8XFWloDjZJJq4FfD60VuxgXzoMNT9wpFTNSH42PR2s9L\nI1vcl3w8yNccs9se2utM2nLsItZ3J0m/+QSRiw9hbrTYTcM9sXki0DtH2kyIOwYf\nlOrGJDiYOIrXSQK36H0gQ+8omlrUTvUj4msvkXuQjlfgx6sgp2duOAfnGxE7uHnc\nUhnJzzoe6M+LfGHkVQ==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICuDCCAj2gAwIBAgIQSAG6j2WHtWUUuLGJTPb1nTAKBggqhkjOPQQDAzCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLW5vcnRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyMDE2MzgyNloYDzIxMjEwNTIwMTczODI2WjCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLW5vcnRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE2eqwU4FOzW8RV1W381Bd\nolhDOrqoMqzWli21oDUt7y8OnXM/lmAuOS6sr8Nt61BLVbONdbr+jgCYw75KabrK\nZGg3siqvMOgabIKkKuXO14wtrGyGDt7dnKXg5ERGYOZlo0IwQDAPBgNVHRMBAf8E\nBTADAQH/MB0GA1UdDgQWBBS1Acp2WYxOcblv5ikZ3ZIbRCCW+zAOBgNVHQ8BAf8E\nBAMCAYYwCgYIKoZIzj0EAwMDaQAwZgIxAJL84J08PBprxmsAKPTotBuVI3MyW1r8\nxQ0i8lgCQUf8GcmYjQ0jI4oZyv+TuYJAcwIxAP9Xpzq0Docxb+4N1qVhpiOfWt1O\nFnemFiy9m1l+wv6p3riQMPV7mBVpklmijkIv3Q==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgIRALZLcqCVIJ25maDPE3sbPCIwDQYJKoZIhvcNAQELBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIxMjEzOTM5WhgPMjA2MTA1MjEyMjM5Mzla\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\nypKc+6FfGx6Gl6fQ78WYS29QoKgQiur58oxR3zltWeg5fqh9Z85K5S3UbRSTqWWu\nXcfnkz0/FS07qHX+nWAGU27JiQb4YYqhjZNOAq8q0+ptFHJ6V7lyOqXBq5xOzO8f\n+0DlbJSsy7GEtJp7d7QCM3M5KVY9dENVZUKeJwa8PC5StvwPx4jcLeZRJC2rAVDG\nSW7NAInbATvr9ssSh03JqjXb+HDyywiqoQ7EVLtmtXWimX+0b3/2vhqcH5jgcKC9\nIGFydrjPbv4kwMrKnm6XlPZ9L0/3FMzanXPGd64LQVy51SI4d5Xymn0Mw2kMX8s6\nNf05OsWcDzJ1n6/Q1qHSxQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\nDgQWBBRmaIc8eNwGP7i6P7AJrNQuK6OpFzAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\nhvcNAQELBQADggEBAIBeHfGwz3S2zwIUIpqEEI5/sMySDeS+3nJR+woWAHeO0C8i\nBJdDh+kzzkP0JkWpr/4NWz84/IdYo1lqASd1Kopz9aT1+iROXaWr43CtbzjXb7/X\nZv7eZZFC8/lS5SROq42pPWl4ekbR0w8XGQElmHYcWS41LBfKeHCUwv83ATF0XQ6I\n4t+9YSqZHzj4vvedrvcRInzmwWJaal9s7Z6GuwTGmnMsN3LkhZ+/GD6oW3pU/Pyh\nEtWqffjsLhfcdCs3gG8x9BbkcJPH5aPAVkPn4wc8wuXg6xxb9YGsQuY930GWTYRf\nschbgjsuqznW4HHakq4WNhs1UdTSTKkRdZz7FUQ=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEDzCCAvegAwIBAgIRAM2zAbhyckaqRim63b+Tib8wDQYJKoZIhvcNAQELBQAw\ngZ8xCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE4MDYGA1UEAwwv\nQW1hem9uIFJEUyBQcmV2aWV3IHVzLWVhc3QtMiBSb290IENBIFJTQTIwNDggRzEx\nEDAOBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTE4MjA0OTQ1WhgPMjA2MTA1MTgyMTQ5\nNDVaMIGfMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExODA2BgNV\nBAMML0FtYXpvbiBSRFMgUHJldmlldyB1cy1lYXN0LTIgUm9vdCBDQSBSU0EyMDQ4\nIEcxMRAwDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\nCgKCAQEA1ybjQMH1MkbvfKsWJaCTXeCSN1SG5UYid+Twe+TjuSqaXWonyp4WRR5z\ntlkqq+L2MWUeQQAX3S17ivo/t84mpZ3Rla0cx39SJtP3BiA2BwfUKRjhPwOjmk7j\n3zrcJjV5k1vSeLNOfFFSlwyDiVyLAE61lO6onBx+cRjelu0egMGq6WyFVidTdCmT\nQ9Zw3W6LTrnPvPmEyjHy2yCHzH3E50KSd/5k4MliV4QTujnxYexI2eR8F8YQC4m3\nDYjXt/MicbqA366SOoJA50JbgpuVv62+LSBu56FpzY12wubmDZsdn4lsfYKiWxUy\nuc83a2fRXsJZ1d3whxrl20VFtLFHFQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\nMB0GA1UdDgQWBBRC0ytKmDYbfz0Bz0Psd4lRQV3aNTAOBgNVHQ8BAf8EBAMCAYYw\nDQYJKoZIhvcNAQELBQADggEBAGv8qZu4uaeoF6zsbumauz6ea6tdcWt+hGFuwGrb\ntRbI85ucAmVSX06x59DJClsb4MPhL1XmqO3RxVMIVVfRwRHWOsZQPnXm8OYQ2sny\nrYuFln1COOz1U/KflZjgJmxbn8x4lYiTPZRLarG0V/OsCmnLkQLPtEl/spMu8Un7\nr3K8SkbWN80gg17Q8EV5mnFwycUx9xsTAaFItuG0en9bGsMgMmy+ZsDmTRbL+lcX\nFq8r4LT4QjrFz0shrzCwuuM4GmcYtBSxlacl+HxYEtAs5k10tmzRf6OYlY33tGf6\n1tkYvKryxDPF/EDgGp/LiBwx6ixYMBfISoYASt4V/ylAlHA=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICtTCCAjqgAwIBAgIRAK9BSZU6nIe6jqfODmuVctYwCgYIKoZIzj0EAwMwgZkx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1h\nem9uIFJEUyBjYS1jZW50cmFsLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTIxMjIxMzA5WhgPMjEyMTA1MjEyMzEzMDlaMIGZMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMjAwBgNVBAMMKUFtYXpv\nbiBSRFMgY2EtY2VudHJhbC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEUkEERcgxneT5H+P+fERcbGmf\nbVx+M7rNWtgWUr6w+OBENebQA9ozTkeSg4c4M+qdYSObFqjxITdYxT1z/nHz1gyx\nOKAhLjWu+nkbRefqy3RwXaWT680uUaAP6ccnkZOMo0IwQDAPBgNVHRMBAf8EBTAD\nAQH/MB0GA1UdDgQWBBSN6fxlg0s5Wny08uRBYZcQ3TUoyzAOBgNVHQ8BAf8EBAMC\nAYYwCgYIKoZIzj0EAwMDaQAwZgIxAORaz+MBVoFBTmZ93j2G2vYTwA6T5hWzBWrx\nCrI54pKn5g6At56DBrkjrwZF5T1enAIxAJe/LZ9xpDkAdxDgGJFN8gZYLRWc0NRy\nRb4hihy5vj9L+w9uKc9VfEBIFuhT7Z3ljg==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEADCCAuigAwIBAgIQB/57HSuaqUkLaasdjxUdPjANBgkqhkiG9w0BAQsFADCB\nmDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\nbWF6b24gUkRTIGFwLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUxOTE3NDAzNFoYDzIwNjEwNTE5MTg0MDM0WjCBmDEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\nb24gUkRTIGFwLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtbkaoVsUS76o\nTgLFmcnaB8cswBk1M3Bf4IVRcwWT3a1HeJSnaJUqWHCJ+u3ip/zGVOYl0gN1MgBb\nMuQRIJiB95zGVcIa6HZtx00VezDTr3jgGWRHmRjNVCCHGmxOZWvJjsIE1xavT/1j\nQYV/ph4EZEIZ/qPq7e3rHohJaHDe23Z7QM9kbyqp2hANG2JtU/iUhCxqgqUHNozV\nZd0l5K6KnltZQoBhhekKgyiHqdTrH8fWajYl5seD71bs0Axowb+Oh0rwmrws3Db2\nDh+oc2PwREnjHeca9/1C6J2vhY+V0LGaJmnnIuOANrslx2+bgMlyhf9j0Bv8AwSi\ndSWsobOhNQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQb7vJT\nVciLN72yJGhaRKLn6Krn2TAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\nggEBAAxEj8N9GslReAQnNOBpGl8SLgCMTejQ6AW/bapQvzxrZrfVOZOYwp/5oV0f\n9S1jcGysDM+DrmfUJNzWxq2Y586R94WtpH4UpJDGqZp+FuOVJL313te4609kopzO\nlDdmd+8z61+0Au93wB1rMiEfnIMkOEyt7D2eTFJfJRKNmnPrd8RjimRDlFgcLWJA\n3E8wca67Lz/G0eAeLhRHIXv429y8RRXDtKNNz0wA2RwURWIxyPjn1fHjA9SPDkeW\nE1Bq7gZj+tBnrqz+ra3yjZ2blss6Ds3/uRY6NYqseFTZWmQWT7FolZEnT9vMUitW\nI0VynUbShVpGf6946e0vgaaKw20=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIID/jCCAuagAwIBAgIQGyUVTaVjYJvWhroVEiHPpDANBgkqhkiG9w0BAQsFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIHVzLXdlc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTE5MTkwNDA2WhgPMjA2MTA1MTkyMDA0MDZaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgdXMtd2VzdC0xIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANhyXpJ0t4nigRDZ\nEwNtFOem1rM1k8k5XmziHKDvDk831p7QsX9ZOxl/BT59Pu/P+6W6SvasIyKls1sW\nFJIjFF+6xRQcpoE5L5evMgN/JXahpKGeQJPOX9UEXVW5B8yi+/dyUitFT7YK5LZA\nMqWBN/LtHVPa8UmE88RCDLiKkqiv229tmwZtWT7nlMTTCqiAHMFcryZHx0pf9VPh\nx/iPV8p2gBJnuPwcz7z1kRKNmJ8/cWaY+9w4q7AYlAMaq/rzEqDaN2XXevdpsYAK\nTMMj2kji4x1oZO50+VPNfBl5ZgJc92qz1ocF95SAwMfOUsP8AIRZkf0CILJYlgzk\n/6u6qZECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUm5jfcS9o\n+LwL517HpB6hG+PmpBswDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\nAQAcQ6lsqxi63MtpGk9XK8mCxGRLCad51+MF6gcNz6i6PAqhPOoKCoFqdj4cEQTF\nF8dCfa3pvfJhxV6RIh+t5FCk/y6bWT8Ls/fYKVo6FhHj57bcemWsw/Z0XnROdVfK\nYqbc7zvjCPmwPHEqYBhjU34NcY4UF9yPmlLOL8uO1JKXa3CAR0htIoW4Pbmo6sA4\n6P0co/clW+3zzsQ92yUCjYmRNeSbdXbPfz3K/RtFfZ8jMtriRGuO7KNxp8MqrUho\nHK8O0mlSUxGXBZMNicfo7qY8FD21GIPH9w5fp5oiAl7lqFzt3E3sCLD3IiVJmxbf\nfUwpGd1XZBBSdIxysRLM6j48\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICrTCCAjOgAwIBAgIQU+PAILXGkpoTcpF200VD/jAKBggqhkjOPQQDAzCBljEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMS8wLQYDVQQDDCZBbWF6\nb24gUkRTIGFwLWVhc3QtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTAgFw0yMTA1MjUyMTQ1MTFaGA8yMTIxMDUyNTIyNDUxMVowgZYxCzAJBgNV\nBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYD\nVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1hem9uIFJE\nUyBhcC1lYXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0bGUw\ndjAQBgcqhkjOPQIBBgUrgQQAIgNiAAT3tFKE8Kw1sGQAvNLlLhd8OcGhlc7MiW/s\nNXm3pOiCT4vZpawKvHBzD76Kcv+ZZzHRxQEmG1/muDzZGlKR32h8AAj+NNO2Wy3d\nCKTtYMiVF6Z2zjtuSkZQdjuQbe4eQ7qjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYD\nVR0OBBYEFAiSQOp16Vv0Ohpvqcbd2j5RmhYNMA4GA1UdDwEB/wQEAwIBhjAKBggq\nhkjOPQQDAwNoADBlAjBVsi+5Ape0kOhMt/WFkANkslD4qXA5uqhrfAtH29Xzz2NV\ntR7akiA771OaIGB/6xsCMQCZt2egCtbX7J0WkuZ2KivTh66jecJr5DHvAP4X2xtS\nF/5pS+AUhcKTEGjI9jDH3ew=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICuDCCAj2gAwIBAgIQT5mGlavQzFHsB7hV6Mmy6TAKBggqhkjOPQQDAzCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyNDIwNTAxNVoYDzIxMjEwNTI0MjE1MDE1WjCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEcm4BBBjYK7clwm0HJRWS\nflt3iYwoJbIXiXn9c1y3E+Vb7bmuyKhS4eO8mwO4GefUcXObRfoHY2TZLhMJLVBQ\n7MN2xDc0RtZNj07BbGD3VAIFRTDX0mH9UNYd0JQM3t/Oo0IwQDAPBgNVHRMBAf8E\nBTADAQH/MB0GA1UdDgQWBBRrd5ITedfAwrGo4FA9UaDaGFK3rjAOBgNVHQ8BAf8E\nBAMCAYYwCgYIKoZIzj0EAwMDaQAwZgIxAPBNqmVv1IIA3EZyQ6XuVf4gj79/DMO8\nbkicNS1EcBpUqbSuU4Zwt2BYc8c/t7KVOQIxAOHoWkoKZPiKyCxfMtJpCZySUG+n\nsXgB/LOyWE5BJcXUfm+T1ckeNoWeUUMOLmnJjg==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgIRAJcDeinvdNrDQBeJ8+t38WQwDQYJKoZIhvcNAQELBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtNCBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjIwNTI1MTY0OTE2WhgPMjA2MjA1MjUxNzQ5MTZa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTQgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\nk8DBNkr9tMoIM0NHoFiO7cQfSX0cOMhEuk/CHt0fFx95IBytx7GHCnNzpM27O5z6\nx6iRhfNnx+B6CrGyCzOjxvPizneY+h+9zfvNz9jj7L1I2uYMuiNyOKR6FkHR46CT\n1CiArfVLLPaTqgD/rQjS0GL2sLHS/0dmYipzynnZcs613XT0rAWdYDYgxDq7r/Yi\nXge5AkWQFkMUq3nOYDLCyGGfQqWKkwv6lZUHLCDKf+Y0Uvsrj8YGCI1O8mF0qPCQ\nlmlfaDvbuBu1AV+aabmkvyFj3b8KRIlNLEtQ4N8KGYR2Jdb82S4YUGIOAt4wuuFt\n1B7AUDLk3V/u+HTWiwfoLQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\nDgQWBBSNpcjz6ArWBtAA+Gz6kyyZxrrgdDAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\nhvcNAQELBQADggEBAGJEd7UgOzHYIcQRSF7nSYyjLROyalaIV9AX4WXW/Cqlul1c\nMblP5etDZm7A/thliZIWAuyqv2bNicmS3xKvNy6/QYi1YgxZyy/qwJ3NdFl067W0\nt8nGo29B+EVK94IPjzFHWShuoktIgp+dmpijB7wkTIk8SmIoe9yuY4+hzgqk+bo4\nms2SOXSN1DoQ75Xv+YmztbnZM8MuWhL1T7hA4AMorzTQLJ9Pof8SpSdMHeDsHp0R\n01jogNFkwy25nw7cL62nufSuH2fPYGWXyNDg+y42wKsKWYXLRgUQuDVEJ2OmTFMB\nT0Vf7VuNijfIA9hkN2d3K53m/9z5WjGPSdOjGhg=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIID/jCCAuagAwIBAgIQRiwspKyrO0xoxDgSkqLZczANBgkqhkiG9w0BAQsFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIHVzLXdlc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTI0MjE1OTAwWhgPMjA2MTA1MjQyMjU5MDBaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgdXMtd2VzdC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL53Jk3GsKiu+4bx\njDfsevWbwPCNJ3H08Zp7GWhvI3Tgi39opfHYv2ku2BKFjK8N2L6RvNPSR8yplv5j\nY0tK0U+XVNl8o0ibhqRDhbTuh6KL8CFINWYzAajuxFS+CF0U6c1Q3tXLBdALxA7l\nFlXJ71QrP06W31kRe7kvgrvO7qWU3/OzUf9qYw4LSiR1/VkvvRCTqcVNw09clw/M\nJbw6FSgweN65M9j7zPbjGAXSHkXyxH1Erin2fa+B9PE4ZDgX9cp2C1DHewYJQL/g\nSepwwcudVNRN1ibKH7kpMrgPnaNIVNx5sXVsTjk6q2ZqYw3SVHegltJpLy/cZReP\nmlivF2kCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUmTcQd6o1\nCuS65MjBrMwQ9JJjmBwwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\nAQAKSDSIzl956wVddPThf2VAzI8syw9ngSwsEHZvxVGHBvu5gg618rDyguVCYX9L\n4Kw/xJrk6S3qxOS2ZDyBcOpsrBskgahDFIunzoRP3a18ARQVq55LVgfwSDQiunch\nBd05cnFGLoiLkR5rrkgYaP2ftn3gRBRaf0y0S3JXZ2XB3sMZxGxavYq9mfiEcwB0\nLMTMQ1NYzahIeG6Jm3LqRqR8HkzP/Ztq4dT2AtSLvFebbNMiWqeqT7OcYp94HTYT\nzqrtaVdUg9bwyAUCDgy0GV9RHDIdNAOInU/4LEETovrtuBU7Z1q4tcHXvN6Hd1H8\ngMb0mCG5I393qW5hFsA/diFb\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgIRAPQAvihfjBg/JDbj6U64K98wDQYJKoZIhvcNAQELBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIwMTYyODQxWhgPMjA2MTA1MjAxNzI4NDFa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\nvJ9lgyksCxkBlY40qOzI1TCj/Q0FVGuPL/Z1Mw2YN0l+41BDv0FHApjTUkIKOeIP\nnwDwpXTa3NjYbk3cOZ/fpH2rYJ++Fte6PNDGPgKppVCUh6x3jiVZ1L7wOgnTdK1Q\nTrw8440IDS5eLykRHvz8OmwvYDl0iIrt832V0QyOlHTGt6ZJ/aTQKl12Fy3QBLv7\nstClPzvHTrgWqVU6uidSYoDtzHbU7Vda7YH0wD9IUoMBf7Tu0rqcE4uH47s2XYkc\nSdLEoOg/Ngs7Y9B1y1GCyj3Ux7hnyvCoRTw014QyNB7dTatFMDvYlrRDGG14KeiU\nUL7Vo/+EejWI31eXNLw84wIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\nDgQWBBQkgTWFsNg6wA3HbbihDQ4vpt1E2zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\nhvcNAQELBQADggEBAGz1Asiw7hn5WYUj8RpOCzpE0h/oBZcnxP8wulzZ5Xd0YxWO\n0jYUcUk3tTQy1QvoY+Q5aCjg6vFv+oFBAxkib/SmZzp4xLisZIGlzpJQuAgRkwWA\n6BVMgRS+AaOMQ6wKPgz1x4v6T0cIELZEPq3piGxvvqkcLZKdCaeC3wCS6sxuafzZ\n4qA3zMwWuLOzRftgX2hQto7d/2YkRXga7jSvQl3id/EI+xrYoH6zIWgjdU1AUaNq\nNGT7DIo47vVMfnd9HFZNhREsd4GJE83I+JhTqIxiKPNxrKgESzyADmNPt0gXDnHo\ntbV1pMZz5HpJtjnP/qVZhEK5oB0tqlKPv9yx074=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICuTCCAj6gAwIBAgIRAKp1Rn3aL/g/6oiHVIXtCq8wCgYIKoZIzj0EAwMwgZsx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\nem9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMTA1MjQyMDMyMTdaGA8yMTIxMDUyNDIxMzIxN1owgZsx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\nem9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABGTYWPILeBJXfcL3Dz4z\nEWMUq78xB1HpjBwHoTURYfcMd5r96BTVG6yaUBWnAVCMeeD6yTG9a1eVGNhG14Hk\nZAEjgLiNB7RRbEG5JZ/XV7W/vODh09WCst2y9SLKsdgeAaNCMEAwDwYDVR0TAQH/\nBAUwAwEB/zAdBgNVHQ4EFgQUoE0qZHmDCDB+Bnm8GUa/evpfPwgwDgYDVR0PAQH/\nBAQDAgGGMAoGCCqGSM49BAMDA2kAMGYCMQCnil5MMwhY3qoXv0xvcKZGxGPaBV15\n0CCssCKn0oVtdJQfJQ3Jrf3RSaEyijXIJsoCMQC35iJi4cWoNX3N/qfgnHohW52O\nB5dg0DYMqy5cNZ40+UcAanRMyqNQ6P7fy3umGco=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICtzCCAj2gAwIBAgIQPXnDTPegvJrI98qz8WxrMjAKBggqhkjOPQQDAzCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIEJldGEgdXMtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUxODIxNDAxMloYDzIxMjEwNTE4MjI0MDEyWjCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIEJldGEgdXMtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEI0sR7gwutK5AB46hM761\ngcLTGBIYlURSEoM1jcBwy56CL+3CJKZwLLyJ7qoOKfWbu5GsVLUTWS8MV6Nw33cx\n2KQD2svb694wi+Px2f4n9+XHkEFQw8BbiodDD7RZA70fo0IwQDAPBgNVHRMBAf8E\nBTADAQH/MB0GA1UdDgQWBBTQSioOvnVLEMXwNSDg+zgln/vAkjAOBgNVHQ8BAf8E\nBAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIxAMwu1hqm5Bc98uE/E0B5iMYbBQ4kpMxO\ntP8FTfz5UR37HUn26nXE0puj6S/Ffj4oJgIwXI7s2c26tFQeqzq6u3lrNJHp5jC9\nUxlo/hEJOLoDj5jnpxo8dMAtCNoQPaHdfL0P\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICrjCCAjWgAwIBAgIQGKVv+5VuzEZEBzJ+bVfx2zAKBggqhkjOPQQDAzCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGFwLXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTE5MTc1MDU5WhgPMjEyMTA1MTkxODUwNTlaMIGXMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\nRFMgYXAtc291dGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\nZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABMqdLJ0tZF/DGFZTKZDrGRJZID8ivC2I\nJRCYTWweZKCKSCAzoiuGGHzJhr5RlLHQf/QgmFcgXsdmO2n3CggzhA4tOD9Ip7Lk\nP05eHd2UPInyPCHRgmGjGb0Z+RdQ6zkitKNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\nBgNVHQ4EFgQUC1yhRgVqU5bR8cGzOUCIxRpl4EYwDgYDVR0PAQH/BAQDAgGGMAoG\nCCqGSM49BAMDA2cAMGQCMG0c/zLGECRPzGKJvYCkpFTCUvdP4J74YP0v/dPvKojL\nt/BrR1Tg4xlfhaib7hPc7wIwFvgqHes20CubQnZmswbTKLUrgSUW4/lcKFpouFd2\nt2/ewfi/0VhkeUW+IiHhOMdU\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGCTCCA/GgAwIBAgIRAOXxJuyXVkbfhZCkS/dOpfEwDQYJKoZIhvcNAQEMBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI1MjE1OTEwWhgPMjEyMTA1MjUyMjU5MTBa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\nxiP4RDYm4tIS12hGgn1csfO8onQDmK5SZDswUpl0HIKXOUVVWkHNlINkVxbdqpqH\nFhbyZmNN6F/EWopotMDKe1B+NLrjNQf4zefv2vyKvPHJXhxoKmfyuTd5Wk8k1F7I\nlNwLQzznB+ElhrLIDJl9Ro8t31YBBNFRGAGEnxyACFGcdkjlsa52UwfYrwreEg2l\ngW5AzqHgjFfj9QRLydeU/n4bHm0F1adMsV7P3rVwilcUlqsENDwXnWyPEyv3sw6F\nwNemLEs1129mB77fwvySb+lLNGsnzr8w4wdioZ74co+T9z2ca+eUiP+EQccVw1Is\nD4Fh57IjPa6Wuc4mwiUYKkKY63+38aCfEWb0Qoi+zW+mE9nek6MOQ914cN12u5LX\ndBoYopphRO5YmubSN4xcBy405nIdSdbrAVWwxXnVVyjqjknmNeqQsPZaxAhdoKhV\nAqxNr8AUAdOAO6Sz3MslmcLlDXFihrEEOeUbpg/m1mSUUHGbu966ajTG1FuEHHwS\n7WB52yxoJo/tHvt9nAWnh3uH5BHmS8zn6s6CGweWKbX5yICnZ1QFR1e4pogxX39v\nXD6YcNOO+Vn+HY4nXmjgSYVC7l+eeP8eduMg1xJujzjrbmrXU+d+cBObgdTOAlpa\nJFHaGwYw1osAwPCo9cZ2f04yitBfj9aPFia8ASKldakCAwEAAaNCMEAwDwYDVR0T\nAQH/BAUwAwEB/zAdBgNVHQ4EFgQUqKS+ltlior0SyZKYAkJ/efv55towDgYDVR0P\nAQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQAdElvp8bW4B+Cv+1WSN87dg6TN\nwGyIjJ14/QYURgyrZiYpUmZpj+/pJmprSWXu4KNyqHftmaidu7cdjL5nCAvAfnY5\n/6eDDbX4j8Gt9fb/6H9y0O0dn3mUPSEKG0crR+JRFAtPhn/2FNvst2P82yguWLv0\npHjHVUVcq+HqDMtUIJsTPYjSh9Iy77Q6TOZKln9dyDOWJpCSkiUWQtMAKbCSlvzd\nzTs/ahqpT+zLfGR1SR+T3snZHgQnbnemmz/XtlKl52NxccARwfcEEKaCRQyGq/pR\n0PVZasyJS9JY4JfQs4YOdeOt4UMZ8BmW1+BQWGSkkb0QIRl8CszoKofucAlqdPcO\nIT/ZaMVhI580LFGWiQIizWFskX6lqbCyHqJB3LDl8gJISB5vNTHOHpvpMOMs5PYt\ncRl5Mrksx5MKMqG7y5R734nMlZxQIHjL5FOoOxTBp9KeWIL/Ib89T2QDaLw1SQ+w\nihqWBJ4ZdrIMWYpP3WqM+MXWk7WAem+xsFJdR+MDgOOuobVQTy5dGBlPks/6gpjm\nrO9TjfQ36ppJ3b7LdKUPeRfnYmlR5RU4oyYJ//uLbClI443RZAgxaCXX/nyc12lr\neVLUMNF2abLX4/VF63m2/Z9ACgMRfqGshPssn1NN33OonrotQoj4S3N9ZrjvzKt8\niHcaqd60QKpfiH2A3A==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICuDCCAj2gAwIBAgIQPaVGRuu86nh/ylZVCLB0MzAKBggqhkjOPQQDAzCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLW5vcnRoZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyNTIyMDMxNloYDzIxMjEwNTI1MjMwMzE2WjCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLW5vcnRoZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEexNURoB9KE93MEtEAlJG\nobz4LS/pD2hc8Gczix1WhVvpJ8bN5zCDXaKdnDMCebetyRQsmQ2LYlfmCwpZwSDu\n0zowB11Pt3I5Avu2EEcuKTlKIDMBeZ1WWuOd3Tf7MEAMo0IwQDAPBgNVHRMBAf8E\nBTADAQH/MB0GA1UdDgQWBBSaYbZPBvFLikSAjpa8mRJvyArMxzAOBgNVHQ8BAf8E\nBAMCAYYwCgYIKoZIzj0EAwMDaQAwZgIxAOEJkuh3Zjb7Ih/zuNRd1RBqmIYcnyw0\nnwUZczKXry+9XebYj3VQxSRNadrarPWVqgIxAMg1dyGoDAYjY/L/9YElyMnvHltO\nPwpJShmqHvCLc/mXMgjjYb/akK7yGthvW6j/uQ==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGCDCCA/CgAwIBAgIQChu3v5W1Doil3v6pgRIcVzANBgkqhkiG9w0BAQwFADCB\nnDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\nbWF6b24gUkRTIEJldGEgdXMtZWFzdC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4G\nA1UEBwwHU2VhdHRsZTAgFw0yMTA1MTgyMTM0MTVaGA8yMTIxMDUxODIyMzQxNVow\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBCZXRhIHVzLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC1\nFUGQ5tf3OwpDR6hGBxhUcrkwKZhaXP+1St1lSOQvjG8wXT3RkKzRGMvb7Ee0kzqI\nmzKKe4ASIhtV3UUWdlNmP0EA3XKnif6N79MismTeGkDj75Yzp5A6tSvqByCgxIjK\nJqpJrch3Dszoyn8+XhwDxMZtkUa5nQVdJgPzJ6ltsQ8E4SWLyLtTu0S63jJDkqYY\nS7cQblk7y7fel+Vn+LS5dGTdRRhMvSzEnb6mkVBaVzRyVX90FNUED06e8q+gU8Ob\nhtvQlf9/kRzHwRAdls2YBhH40ZeyhpUC7vdtPwlmIyvW5CZ/QiG0yglixnL6xahL\npbmTuTSA/Oqz4UGQZv2WzHe1lD2gRHhtFX2poQZeNQX8wO9IcUhrH5XurW/G9Xwl\nSat9CMPERQn4KC3HSkat4ir2xaEUrjfg6c4XsGyh2Pk/LZ0gLKum0dyWYpWP4JmM\nRQNjrInXPbMhzQObozCyFT7jYegS/3cppdyy+K1K7434wzQGLU1gYXDKFnXwkX8R\nbRKgx2pHNbH5lUddjnNt75+e8m83ygSq/ZNBUz2Ur6W2s0pl6aBjwaDES4VfWYlI\njokcmrGvJNDfQWygb1k00eF2bzNeNCHwgWsuo3HSxVgc/WGsbcGrTlDKfz+g3ich\nbXUeUidPhRiv5UQIVCLIHpHuin3bj9lQO/0t6p+tAQIDAQABo0IwQDAPBgNVHRMB\nAf8EBTADAQH/MB0GA1UdDgQWBBSFmMBgm5IsRv3hLrvDPIhcPweXYTAOBgNVHQ8B\nAf8EBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBAAa2EuozymOsQDJlEi7TqnyA2OhT\nGXPfYqCyMJVkfrqNgcnsNpCAiNEiZbb+8sIPXnT8Ay8hrwJYEObJ5b7MHXpLuyft\nz0Pu1oFLKnQxKjNxrIsCvaB4CRRdYjm1q7EqGhMGv76se9stOxkOqO9it31w/LoU\nENDk7GLsSqsV1OzYLhaH8t+MaNP6rZTSNuPrHwbV3CtBFl2TAZ7iKgKOhdFz1Hh9\nPez0lG+oKi4mHZ7ajov6PD0W7njn5KqzCAkJR6OYmlNVPjir+c/vUtEs0j+owsMl\ng7KE5g4ZpTRShyh5BjCFRK2tv0tkqafzNtxrKC5XNpEkqqVTCnLcKG+OplIEadtr\nC7UWf4HyhCiR+xIyxFyR05p3uY/QQU/5uza7GlK0J+U1sBUytx7BZ+Fo8KQfPPqV\nCqDCaYUksoJcnJE/KeoksyqNQys7sDGJhkd0NeUGDrFLKHSLhIwAMbEWnqGxvhli\nE7sP2E5rI/I9Y9zTbLIiI8pfeZlFF8DBdoP/Hzg8pqsiE/yiXSFTKByDwKzGwNqz\nF0VoFdIZcIbLdDbzlQitgGpJtvEL7HseB0WH7B2PMMD8KPJlYvPveO3/6OLzCsav\n+CAkvk47NQViKMsUTKOA0JDCW+u981YRozxa3K081snhSiSe83zIPBz1ikldXxO9\n6YYLNPRrj3mi9T/f\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICrjCCAjSgAwIBAgIRAMkvdFnVDb0mWWFiXqnKH68wCgYIKoZIzj0EAwMwgZYx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\nem9uIFJEUyB1cy13ZXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTE5MTkxMzI0WhgPMjEyMTA1MTkyMDEzMjRaMIGWMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\nRFMgdXMtd2VzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\nMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEy86DB+9th/0A5VcWqMSWDxIUblWTt/R0\nao6Z2l3vf2YDF2wt1A2NIOGpfQ5+WAOJO/IQmnV9LhYo+kacB8sOnXdQa6biZZkR\nIyouUfikVQAKWEJnh1Cuo5YMM4E2sUt5o0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\nA1UdDgQWBBQ8u3OnecANmG8OoT7KLWDuFzZwBTAOBgNVHQ8BAf8EBAMCAYYwCgYI\nKoZIzj0EAwMDaAAwZQIwQ817qkb7mWJFnieRAN+m9W3E0FLVKaV3zC5aYJUk2fcZ\nTaUx3oLp3jPLGvY5+wgeAjEA6wAicAki4ZiDfxvAIuYiIe1OS/7H5RA++R8BH6qG\niRzUBM/FItFpnkus7u/eTkvo\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICrzCCAjWgAwIBAgIQS/+Ryfgb/IOVEa1pWoe8oTAKBggqhkjOPQQDAzCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGFwLXNvdXRoLTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjIwNjA2MjE1NDQyWhgPMjEyMjA2MDYyMjU0NDJaMIGXMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\nRFMgYXAtc291dGgtMiBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\nZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABDsX6fhdUWBQpYTdseBD/P3s96Dtw2Iw\nOrXKNToCnmX5nMkUGdRn9qKNiz1pw3EPzaPxShbYwQ7LYP09ENK/JN4QQjxMihxC\njLFxS85nhBQQQGRCWikDAe38mD8fSvREQKNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\nBgNVHQ4EFgQUIh1xZiseQYFjPYKJmGbruAgRH+AwDgYDVR0PAQH/BAQDAgGGMAoG\nCCqGSM49BAMDA2gAMGUCMFudS4zLy+UUGrtgNLtRMcu/DZ9BUzV4NdHxo0bkG44O\nthnjl4+wTKI6VbyAbj2rkgIxAOHps8NMITU5DpyiMnKTxV8ubb/WGHrLl0BjB8Lw\nETVJk5DNuZvsIIcm7ykk6iL4Tw==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGBDCCA+ygAwIBAgIQDcEmNIAVrDpUw5cH5ynutDANBgkqhkiG9w0BAQwFADCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIG1lLWNlbnRyYWwtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\nBAcMB1NlYXR0bGUwIBcNMjIwNTA3MDA0MDIzWhgPMjEyMjA1MDcwMTQwMjNaMIGa\nMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\nLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\nYXpvbiBSRFMgbWUtY2VudHJhbC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKvADk8t\nFl9bFlU5sajLPPDSOUpPAkKs6iPlz+27o1GJC88THcOvf3x0nVAcu9WYe9Qaas+4\nj4a0vv51agqyODRD/SNi2HnqW7DbtLPAm6KBHe4twl28ItB/JD5g7u1oPAHFoXMS\ncH1CZEAs5RtlZGzJhcBXLFsHNv/7+SCLyZ7+2XFh9OrtgU4wMzkHoRNndhfwV5bu\n17bPTwuH+VxH37zXf1mQ/KjhuJos0C9dL0FpjYBAuyZTAWhZKs8dpSe4DI544z4w\ngkwUB4bC2nA1TBzsywEAHyNuZ/xRjNpWvx0ToWAA2iFJqC3VO3iKcnBplMvaUuMt\njwzVSNBnKcoabXCZL2XDLt4YTZR8FSwz05IvsmwcPB7uNTBXq3T9sjejW8QQK3vT\ntzyfLq4jKmQE7PoS6cqYm+hEPm2hDaC/WP9bp3FdEJxZlPH26fq1b7BWYWhQ9pBA\nNv9zTnzdR1xohTyOJBUFQ81ybEzabqXqVXUIANqIOaNcTB09/sLJ7+zuMhp3mwBu\nLtjfJv8PLuT1r63bU3seROhKA98b5KfzjvbvPSg3vws78JQyoYGbqNyDfyjVjg3U\nv//AdVuPie6PNtdrW3upZY4Qti5IjP9e3kimaJ+KAtTgMRG56W0WxD3SP7+YGGbG\nKhntDOkKsN39hLpn9UOafTIqFu7kIaueEy/NAgMBAAGjQjBAMA8GA1UdEwEB/wQF\nMAMBAf8wHQYDVR0OBBYEFHAems86dTwdZbLe8AaPy3kfIUVoMA4GA1UdDwEB/wQE\nAwIBhjANBgkqhkiG9w0BAQwFAAOCAgEAOBHpp0ICx81kmeoBcZTrMdJs2gnhcd85\nFoSCjXx9H5XE5rmN/lQcxxOgj8hr3uPuLdLHu+i6THAyzjrl2NA1FWiqpfeECGmy\n0jm7iZsYORgGQYp/VKnDrwnKNSqlZvOuRr0kfUexwFlr34Y4VmupvEOK/RdGsd3S\n+3hiemcHse9ST/sJLHx962AWMkN86UHPscJEe4+eT3f2Wyzg6La8ARwdWZSNS+WH\nZfybrncMmuiXuUdHv9XspPsqhKgtHhcYeXOGUtrwQPLe3+VJZ0LVxhlTWr9951GZ\nGfmWwTV/9VsyKVaCFIXeQ6L+gjcKyEzYF8wpMtQlSc7FFqwgC4bKxvMBSaRy88Nr\nlV2+tJD/fr8zGUeBK44Emon0HKDBWGX+/Hq1ZIv0Da0S+j6LbA4fusWxtGfuGha+\nluhHgVInCpALIOamiBEdGhILkoTtx7JrYppt3/Raqg9gUNCOOYlCvGhqX7DXeEfL\nDGabooiY2FNWot6h04JE9nqGj5QqT8D6t/TL1nzxhRPzbcSDIHUd/b5R+a0bAA+7\nYTU6JqzEVCWKEIEynYmqikgLMGB/OzWsgyEL6822QW6hJAQ78XpbNeCzrICF4+GC\n7KShLnwuWoWpAb26268lvOEvCTFM47VC6jNQl97md+2SA9Ma81C9wflid2M83Wle\ncuLMVcQZceE=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEADCCAuigAwIBAgIQAhAteLRCvizAElaWORFU2zANBgkqhkiG9w0BAQsFADCB\nmDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\nbWF6b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyMDE3MDkxNloYDzIwNjEwNTIwMTgwOTE2WjCBmDEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\nb24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA+qg7JAcOVKjh\nN83SACnBFZPyB63EusfDr/0V9ZdL8lKcmZX9sv/CqoBo3N0EvBqHQqUUX6JvFb7F\nXrMUZ740kr28gSRALfXTFgNODjXeDsCtEkKRTkac/UM8xXHn+hR7UFRPHS3e0GzI\niLiwQWDkr0Op74W8aM0CfaVKvh2bp4BI1jJbdDnQ9OKXpOxNHGUf0ZGb7TkNPkgI\nb2CBAc8J5o3H9lfw4uiyvl6Fz5JoP+A+zPELAioYBXDrbE7wJeqQDJrETWqR9VEK\nBXURCkVnHeaJy123MpAX2ozf4pqk0V0LOEOZRS29I+USF5DcWr7QIXR/w2I8ws1Q\n7ys+qbE+kQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQFJ16n\n1EcCMOIhoZs/F9sR+Jy++zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\nggEBAOc5nXbT3XTDEZsxX2iD15YrQvmL5m13B3ImZWpx/pqmObsgx3/dg75rF2nQ\nqS+Vl+f/HLh516pj2BPP/yWCq12TRYigGav8UH0qdT3CAClYy2o+zAzUJHm84oiB\nud+6pFVGkbqpsY+QMpJUbZWu52KViBpJMYsUEy+9cnPSFRVuRAHjYynSiLk2ZEjb\nWkdc4x0nOZR5tP0FgrX0Ve2KcjFwVQJVZLgOUqmFYQ/G0TIIGTNh9tcmR7yp+xJR\nA2tbPV2Z6m9Yxx4E8lLEPNuoeouJ/GR4CkMEmF8cLwM310t174o3lKKUXJ4Vs2HO\nWj2uN6R9oI+jGLMSswTzCNV1vgc=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICuDCCAj6gAwIBAgIRAOocLeZWjYkG/EbHmscuy8gwCgYIKoZIzj0EAwMwgZsx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\nem9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMTA1MjEyMTUwMDFaGA8yMTIxMDUyMTIyNTAwMVowgZsx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\nem9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABCEr3jq1KtRncnZfK5cq\nbtY0nW6ZG3FMbh7XwBIR6Ca0f8llGZ4vJEC1pXgiM/4Dh045B9ZIzNrR54rYOIfa\n2NcYZ7mk06DjIQML64hbAxbQzOAuNzLPx268MrlL2uW2XaNCMEAwDwYDVR0TAQH/\nBAUwAwEB/zAdBgNVHQ4EFgQUln75pChychwN4RfHl+tOinMrfVowDgYDVR0PAQH/\nBAQDAgGGMAoGCCqGSM49BAMDA2gAMGUCMGiyPINRU1mwZ4Crw01vpuPvxZxb2IOr\nyX3RNlOIu4We1H+5dQk5tIvH8KGYFbWEpAIxAO9NZ6/j9osMhLgZ0yj0WVjb+uZx\nYlZR9fyFisY/jNfX7QhSk+nrc3SFLRUNtpXrng==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEBTCCAu2gAwIBAgIRAKiaRZatN8eiz9p0s0lu0rQwDQYJKoZIhvcNAQELBQAw\ngZoxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEzMDEGA1UEAwwq\nQW1hem9uIFJEUyBjYS1jZW50cmFsLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYD\nVQQHDAdTZWF0dGxlMCAXDTIxMDUyMTIyMDIzNVoYDzIwNjEwNTIxMjMwMjM1WjCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIGNhLWNlbnRyYWwtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\nBAcMB1NlYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCygVMf\nqB865IR9qYRBRFHn4eAqGJOCFx+UbraQZmjr/mnRqSkY+nhbM7Pn/DWOrRnxoh+w\nq5F9ZxdZ5D5T1v6kljVwxyfFgHItyyyIL0YS7e2h7cRRscCM+75kMedAP7icb4YN\nLfWBqfKHbHIOqvvQK8T6+Emu/QlG2B5LvuErrop9K0KinhITekpVIO4HCN61cuOe\nCADBKF/5uUJHwS9pWw3uUbpGUwsLBuhJzCY/OpJlDqC8Y9aToi2Ivl5u3/Q/sKjr\n6AZb9lx4q3J2z7tJDrm5MHYwV74elGSXoeoG8nODUqjgklIWAPrt6lQ3WJpO2kug\n8RhCdSbWkcXHfX95AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE\nFOIxhqTPkKVqKBZvMWtKewKWDvDBMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0B\nAQsFAAOCAQEAqoItII89lOl4TKvg0I1EinxafZLXIheLcdGCxpjRxlZ9QMQUN3yb\ny/8uFKBL0otbQgJEoGhxm4h0tp54g28M6TN1U0332dwkjYxUNwvzrMaV5Na55I2Z\n1hq4GB3NMXW+PvdtsgVOZbEN+zOyOZ5MvJHEQVkT3YRnf6avsdntltcRzHJ16pJc\nY8rR7yWwPXh1lPaPkxddrCtwayyGxNbNmRybjR48uHRhwu7v2WuAMdChL8H8bp89\nTQLMrMHgSbZfee9hKhO4Zebelf1/cslRSrhkG0ESq6G5MUINj6lMg2g6F0F7Xz2v\nncD/vuRN5P+vT8th/oZ0Q2Gc68Pun0cn/g==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIID/zCCAuegAwIBAgIRAJYlnmkGRj4ju/2jBQsnXJYwDQYJKoZIhvcNAQELBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyB1cy1lYXN0LTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyMTIzMDQ0NFoYDzIwNjEwNTIyMDAwNDQ0WjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIHVzLWVhc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC74V3eigv+pCj5\nnqDBqplY0Jp16pTeNB06IKbzb4MOTvNde6QjsZxrE1xUmprT8LxQqN9tI3aDYEYk\nb9v4F99WtQVgCv3Y34tYKX9NwWQgwS1vQwnIR8zOFBYqsAsHEkeJuSqAB12AYUSd\nZv2RVFjiFmYJho2X30IrSLQfS/IE3KV7fCyMMm154+/K1Z2IJlcissydEAwgsUHw\nedrE6CxJVkkJ3EvIgG4ugK/suxd8eEMztaQYJwSdN8TdfT59LFuSPl7zmF3fIBdJ\n//WexcQmGabaJ7Xnx+6o2HTfkP8Zzzzaq8fvjAcvA7gyFH5EP26G2ZqMG+0y4pTx\nSPVTrQEXAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFIWWuNEF\nsUMOC82XlfJeqazzrkPDMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\nAQEAgClmxcJaQTGpEZmjElL8G2Zc8lGc+ylGjiNlSIw8X25/bcLRptbDA90nuP+q\nzXAMhEf0ccbdpwxG/P5a8JipmHgqQLHfpkvaXx+0CuP++3k+chAJ3Gk5XtY587jX\n+MJfrPgjFt7vmMaKmynndf+NaIJAYczjhJj6xjPWmGrjM3MlTa9XesmelMwP3jep\nbApIWAvCYVjGndbK9byyMq1nyj0TUzB8oJZQooaR3MMjHTmADuVBylWzkRMxbKPl\n4Nlsk4Ef1JvIWBCzsMt+X17nuKfEatRfp3c9tbpGlAE/DSP0W2/Lnayxr4RpE9ds\nICF35uSis/7ZlsftODUe8wtpkQ==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIF/zCCA+egAwIBAgIRAPvvd+MCcp8E36lHziv0xhMwDQYJKoZIhvcNAQEMBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyB1cy1lYXN0LTIgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyMTIzMTEwNloYDzIxMjEwNTIyMDAxMTA2WjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIHVzLWVhc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDbvwekKIKGcV/s\nlDU96a71ZdN2pTYkev1X2e2/ICb765fw/i1jP9MwCzs8/xHBEQBJSxdfO4hPeNx3\nENi0zbM+TrMKliS1kFVe1trTTEaHYjF8BMK9yTY0VgSpWiGxGwg4tshezIA5lpu8\nsF6XMRxosCEVCxD/44CFqGZTzZaREIvvFPDTXKJ6yOYnuEkhH3OcoOajHN2GEMMQ\nShuyRFDQvYkqOC/Q5icqFbKg7eGwfl4PmimdV7gOVsxSlw2s/0EeeIILXtHx22z3\n8QBhX25Lrq2rMuaGcD3IOMBeBo2d//YuEtd9J+LGXL9AeOXHAwpvInywJKAtXTMq\nWsy3LjhuANFrzMlzjR2YdjkGVzeQVx3dKUzJ2//Qf7IXPSPaEGmcgbxuatxjnvfT\nH85oeKr3udKnXm0Kh7CLXeqJB5ITsvxI+Qq2iXtYCc+goHNR01QJwtGDSzuIMj3K\nf+YMrqBXZgYBwU2J/kCNTH31nfw96WTbOfNGwLwmVRDgguzFa+QzmQsJW4FTDMwc\n7cIjwdElQQVA+Gqa67uWmyDKAnoTkudmgAP+OTBkhnmc6NJuZDcy6f/iWUdl0X0u\n/tsfgXXR6ZovnHonM13ANiN7VmEVqFlEMa0VVmc09m+2FYjjlk8F9sC7Rc4wt214\n7u5YvCiCsFZwx44baP5viyRZgkJVpQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\nMB0GA1UdDgQWBBQgCZCsc34nVTRbWsniXBPjnUTQ2DAOBgNVHQ8BAf8EBAMCAYYw\nDQYJKoZIhvcNAQEMBQADggIBAAQas3x1G6OpsIvQeMS9BbiHG3+kU9P/ba6Rrg+E\nlUz8TmL04Bcd+I+R0IyMBww4NznT+K60cFdk+1iSmT8Q55bpqRekyhcdWda1Qu0r\nJiTi7zz+3w2v66akofOnGevDpo/ilXGvCUJiLOBnHIF0izUqzvfczaMZGJT6xzKq\nPcEVRyAN1IHHf5KnGzUlVFv9SGy47xJ9I1vTk24JU0LWkSLzMMoxiUudVmHSqJtN\nu0h+n/x3Q6XguZi1/C1KOntH56ewRh8n5AF7c+9LJJSRM9wunb0Dzl7BEy21Xe9q\n03xRYjf5wn8eDELB8FZPa1PrNKXIOLYM9egdctbKEcpSsse060+tkyBrl507+SJT\n04lvJ4tcKjZFqxn+bUkDQvXYj0D3WK+iJ7a8kZJPRvz8BDHfIqancY8Tgw+69SUn\nWqIb+HNZqFuRs16WFSzlMksqzXv6wcDSyI7aZOmCGGEcYW9NHk8EuOnOQ+1UMT9C\nQb1GJcipjRzry3M4KN/t5vN3hIetB+/PhmgTO4gKhBETTEyPC3HC1QbdVfRndB6e\nU/NF2U/t8U2GvD26TTFLK4pScW7gyw4FQyXWs8g8FS8f+R2yWajhtS9++VDJQKom\nfAUISoCH+PlPRJpu/nHd1Zrddeiiis53rBaLbXu2J1Q3VqjWOmtj0HjxJJxWnYmz\nPqj2\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGATCCA+mgAwIBAgIRAI/U4z6+GF8/znpHM8Dq8G0wDQYJKoZIhvcNAQEMBQAw\ngZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\nQW1hem9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMjA2MDYyMTQ4MThaGA8yMTIyMDYwNjIyNDgxOFowgZgx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\nem9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK5WqMvyq888\n3uuOtEj1FcP6iZhqO5kJurdJF59Otp2WCg+zv6I+QwaAspEWHQsKD405XfFsTGKV\nSKTCwoMxwBniuChSmyhlagQGKSnRY9+znOWq0v7hgmJRwp6FqclTbubmr+K6lzPy\nhs86mEp68O5TcOTYWUlPZDqfKwfNTbtCl5YDRr8Gxb5buHmkp6gUSgDkRsXiZ5VV\nb3GBmXRqbnwo5ZRNAzQeM6ylXCn4jKs310lQGUrFbrJqlyxUdfxzqdlaIRn2X+HY\nxRSYbHox3LVNPpJxYSBRvpQVFSy9xbX8d1v6OM8+xluB31cbLBtm08KqPFuqx+cO\nI2H5F0CYqYzhyOSKJsiOEJT6/uH4ewryskZzncx9ae62SC+bB5n3aJLmOSTkKLFY\nYS5IsmDT2m3iMgzsJNUKVoCx2zihAzgBanFFBsG+Xmoq0aKseZUI6vd2qpd5tUST\n/wS1sNk0Ph7teWB2ACgbFE6etnJ6stwjHFZOj/iTYhlnR2zDRU8akunFdGb6CB4/\nhMxGJxaqXSJeGtHm7FpadlUTf+2ESbYcVW+ui/F8sdBJseQdKZf3VdZZMgM0bcaX\nNE47cauDTy72WdU9YJX/YXKYMLDE0iFHTnGpfVGsuWGPYhlwZ3dFIO07mWnCRM6X\nu5JXRB1oy5n5HRluMsmpSN/R92MeBxKFAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wHQYDVR0OBBYEFNtH0F0xfijSLHEyIkRGD9gW6NazMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQwFAAOCAgEACo+5jFeY3ygxoDDzL3xpfe5M0U1WxdKk+az4\n/OfjZvkoma7WfChi3IIMtwtKLYC2/seKWA4KjlB3rlTsCVNPnK6D+gAnybcfTKk/\nIRSPk92zagwQkSUWtAk80HpVfWJzpkSU16ejiajhedzOBRtg6BwsbSqLCDXb8hXr\neXWC1S9ZceGc+LcKRHewGWPu31JDhHE9bNcl9BFSAS0lYVZqxIRWxivZ+45j5uQv\nwPrC8ggqsdU3K8quV6dblUQzzA8gKbXJpCzXZihkPrYpQHTH0szvXvgebh+CNUAG\nrUxm8+yTS0NFI3U+RLbcLFVzSvjMOnEwCX0SPj5XZRYYXs5ajtQCoZhTUkkwpDV8\nRxXk8qGKiXwUxDO8GRvmvM82IOiXz5w2jy/h7b7soyIgdYiUydMq4Ja4ogB/xPZa\ngf4y0o+bremO15HFf1MkaU2UxPK5FFVUds05pKvpSIaQWbF5lw4LHHj4ZtVup7zF\nCLjPWs4Hs/oUkxLMqQDw0FBwlqa4uot8ItT8uq5BFpz196ZZ+4WXw5PVzfSxZibI\nC/nwcj0AS6qharXOs8yPnPFLPSZ7BbmWzFDgo3tpglRqo3LbSPsiZR+sLeivqydr\n0w4RK1btRda5Ws88uZMmW7+2aufposMKcbAdrApDEAVzHijbB/nolS5nsnFPHZoA\nKDPtFEk=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICtzCCAj2gAwIBAgIQVZ5Y/KqjR4XLou8MCD5pOjAKBggqhkjOPQQDAzCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLXNvdXRoZWFzdC00IFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIyMDUyNTE2NTgzM1oYDzIxMjIwNTI1MTc1ODMzWjCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLXNvdXRoZWFzdC00IFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEbo473OmpD5vkckdJajXg\nbrhmNFyoSa0WCY1njuZC2zMFp3zP6rX4I1r3imrYnJd9pFH/aSiV/r6L5ACE5RPx\n4qdg5SQ7JJUaZc3DWsTOiOed7BCZSzM+KTYK/2QzDMApo0IwQDAPBgNVHRMBAf8E\nBTADAQH/MB0GA1UdDgQWBBTmogc06+1knsej1ltKUOdWFvwgsjAOBgNVHQ8BAf8E\nBAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIxAIs7TlLMbGTWNXpGiKf9DxaM07d/iDHe\nF/Vv/wyWSTGdobxBL6iArQNVXz0Gr4dvPAIwd0rsoa6R0x5mtvhdRPtM37FYrbHJ\npbV+OMusQqcSLseunLBoCHenvJW0QOCQ8EDY\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICvTCCAkOgAwIBAgIQCIY7E/bFvFN2lK9Kckb0dTAKBggqhkjOPQQDAzCBnjEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTcwNQYDVQQDDC5BbWF6\nb24gUkRTIFByZXZpZXcgdXMtZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYD\nVQQHDAdTZWF0dGxlMCAXDTIxMDUxODIxMDUxMFoYDzIxMjEwNTE4MjIwNTEwWjCB\nnjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTcwNQYDVQQDDC5B\nbWF6b24gUkRTIFByZXZpZXcgdXMtZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEMI0hzf1JCEOI\nEue4+DmcNnSs2i2UaJxHMrNGGfU7b42a7vwP53F7045ffHPBGP4jb9q02/bStZzd\nVHqfcgqkSRI7beBKjD2mfz82hF/wJSITTgCLs+NRpS6zKMFOFHUNo0IwQDAPBgNV\nHRMBAf8EBTADAQH/MB0GA1UdDgQWBBS8uF/6hk5mPLH4qaWv9NVZaMmyTjAOBgNV\nHQ8BAf8EBAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIxAO7Pu9wzLyM0X7Q08uLIL+vL\nqaxe3UFuzFTWjM16MLJHbzLf1i9IDFKz+Q4hXCSiJwIwClMBsqT49BPUxVsJnjGr\nEbyEk6aOOVfY1p2yQL649zh3M4h8okLnwf+bYIb1YpeU\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEADCCAuigAwIBAgIQY+JhwFEQTe36qyRlUlF8ozANBgkqhkiG9w0BAQsFADCB\nmDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\nbWF6b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUxOTE5MjQxNloYDzIwNjEwNTE5MjAyNDE2WjCBmDEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\nb24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnIye77j6ev40\n8wRPyN2OdKFSUfI9jB20Or2RLO+RDoL43+USXdrze0Wv4HMRLqaen9BcmCfaKMp0\nE4SFo47bXK/O17r6G8eyq1sqnHE+v288mWtYH9lAlSamNFRF6YwA7zncmE/iKL8J\n0vePHMHP/B6svw8LULZCk+nZk3tgxQn2+r0B4FOz+RmpkoVddfqqUPMbKUxhM2wf\nfO7F6bJaUXDNMBPhCn/3ayKCjYr49ErmnpYV2ZVs1i34S+LFq39J7kyv6zAgbHv9\n+/MtRMoRB1CjpqW0jIOZkHBdYcd1o9p1zFn591Do1wPkmMsWdjIYj+6e7UXcHvOB\n2+ScIRAcnwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQGtq2W\nYSyMMxpdQ3IZvcGE+nyZqTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\nggEBAEgoP3ixJsKSD5FN8dQ01RNHERl/IFbA7TRXfwC+L1yFocKnQh4Mp/msPRSV\n+OeHIvemPW/wtZDJzLTOFJ6eTolGekHK1GRTQ6ZqsWiU2fmiOP8ks4oSpI+tQ9Lw\nVrfZqTiEcS5wEIqyfUAZZfKDo7W1xp+dQWzfczSBuZJZwI5iaha7+ILM0r8Ckden\nTVTapc5pLSoO15v0ziRuQ2bT3V3nwu/U0MRK44z+VWOJdSiKxdnOYDs8hFNnKhfe\nklbTZF7kW7WbiNYB43OaAQBJ6BALZsIskEaqfeZT8FD71uN928TcEQyBDXdZpRN+\niGQZDGhht0r0URGMDSs9waJtTfA=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIF/jCCA+agAwIBAgIQXY/dmS+72lZPranO2JM9jjANBgkqhkiG9w0BAQwFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIGFwLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTI1MjEzNDUxWhgPMjEyMTA1MjUyMjM0NTFaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgYXAtZWFzdC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMyW9kBJjD/hx8e8\nb5E1sF42bp8TXsz1htSYE3Tl3T1Aq379DfEhB+xa/ASDZxt7/vwa81BkNo4M6HYq\nokYIXeE7cu5SnSgjWXqcERhgPevtAwgmhdE3yREe8oz2DyOi2qKKZqah+1gpPaIQ\nfK0uAqoeQlyHosye3KZZKkDHBatjBsQ5kf8lhuf7wVulEZVRHY2bP2X7N98PfbpL\nQdH7mWXzDtJJ0LiwFwds47BrkgK1pkHx2p1mTo+HMkfX0P6Fq1atkVC2RHHtbB/X\niYyH7paaHBzviFrhr679zNqwXIOKlbf74w3mS11P76rFn9rS1BAH2Qm6eY5S/Fxe\nHEKXm4kjPN63Zy0p3yE5EjPt54yPkvumOnT+RqDGJ2HCI9k8Ehcbve0ogfdRKNqQ\nVHWYTy8V33ndQRHZlx/CuU1yN61TH4WSoMly1+q1ihTX9sApmlQ14B2pJi/9DnKW\ncwECrPy1jAowC2UJ45RtC8UC05CbP9yrIy/7Noj8gQDiDOepm+6w1g6aNlWoiuQS\nkyI6nzz1983GcnOHya73ga7otXo0Qfg9jPghlYiMomrgshlSLDHZG0Ib/3hb8cnR\n1OcN9FpzNmVK2Ll1SmTMLrIhuCkyNYX9O/bOknbcf706XeESxGduSkHEjIw/k1+2\nAtteoq5dT6cwjnJ9hyhiueVlVkiDAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\nHQYDVR0OBBYEFLUI+DD7RJs+0nRnjcwIVWzzYSsFMA4GA1UdDwEB/wQEAwIBhjAN\nBgkqhkiG9w0BAQwFAAOCAgEAb1mcCHv4qMQetLGTBH9IxsB2YUUhr5dda0D2BcHr\nUtDbfd0VQs4tux6h/6iKwHPx0Ew8fuuYj99WknG0ffgJfNc5/fMspxR/pc1jpdyU\n5zMQ+B9wi0lOZPO9uH7/pr+d2odcNEy8zAwqdv/ihsTwLmGP54is9fVbsgzNW1cm\nHKAVL2t/Ope+3QnRiRilKCN1lzhav4HHdLlN401TcWRWKbEuxF/FgxSO2Hmx86pj\ne726lweCTMmnq/cTsPOVY0WMjs0or3eHDVlyLgVeV5ldyN+ptg3Oit60T05SRa58\nAJPTaVKIcGQ/gKkKZConpu7GDofT67P/ox0YNY57LRbhsx9r5UY4ROgz7WMQ1yoS\nY+19xizm+mBm2PyjMUbfwZUyCxsdKMwVdOq5/UmTmdms+TR8+m1uBHPOTQ2vKR0s\nPd/THSzPuu+d3dbzRyDSLQbHFFneG760CUlD/ZmzFlQjJ89/HmAmz8IyENq+Sjhx\nJgzy+FjVZb8aRUoYLlnffpUpej1n87Ynlr1GrvC4GsRpNpOHlwuf6WD4W0qUTsC/\nC9JO+fBzUj/aWlJzNcLEW6pte1SB+EdkR2sZvWH+F88TxemeDrV0jKJw5R89CDf8\nZQNfkxJYjhns+YeV0moYjqQdc7tq4i04uggEQEtVzEhRLU5PE83nlh/K2NZZm8Kj\ndIA=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIID/zCCAuegAwIBAgIRAPVSMfFitmM5PhmbaOFoGfUwDQYJKoZIhvcNAQELBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyB1cy1lYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyNTIyMzQ1N1oYDzIwNjEwNTI1MjMzNDU3WjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIHVzLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDu9H7TBeGoDzMr\ndxN6H8COntJX4IR6dbyhnj5qMD4xl/IWvp50lt0VpmMd+z2PNZzx8RazeGC5IniV\n5nrLg0AKWRQ2A/lGGXbUrGXCSe09brMQCxWBSIYe1WZZ1iU1IJ/6Bp4D2YEHpXrW\nbPkOq5x3YPcsoitgm1Xh8ygz6vb7PsvJvPbvRMnkDg5IqEThapPjmKb8ZJWyEFEE\nQRrkCIRueB1EqQtJw0fvP4PKDlCJAKBEs/y049FoOqYpT3pRy0WKqPhWve+hScMd\n6obq8kxTFy1IHACjHc51nrGII5Bt76/MpTWhnJIJrCnq1/Uc3Qs8IVeb+sLaFC8K\nDI69Sw6bAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFE7PCopt\nlyOgtXX0Y1lObBUxuKaCMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\nAQEAFj+bX8gLmMNefr5jRJfHjrL3iuZCjf7YEZgn89pS4z8408mjj9z6Q5D1H7yS\njNETVV8QaJip1qyhh5gRzRaArgGAYvi2/r0zPsy+Tgf7v1KGL5Lh8NT8iCEGGXwF\ng3Ir+Nl3e+9XUp0eyyzBIjHtjLBm6yy8rGk9p6OtFDQnKF5OxwbAgip42CD75r/q\np421maEDDvvRFR4D+99JZxgAYDBGqRRceUoe16qDzbMvlz0A9paCZFclxeftAxv6\nQlR5rItMz/XdzpBJUpYhdzM0gCzAzdQuVO5tjJxmXhkSMcDP+8Q+Uv6FA9k2VpUV\nE/O5jgpqUJJ2Hc/5rs9VkAPXeA==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICrzCCAjWgAwIBAgIQW0yuFCle3uj4vWiGU0SaGzAKBggqhkjOPQQDAzCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTE5MTkzNTE2WhgPMjEyMTA1MTkyMDM1MTZaMIGXMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\nRFMgYWYtc291dGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\nZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABDPiKNZSaXs3Un/J/v+LTsFDANHpi7en\noL2qh0u0DoqNzEBTbBjvO23bLN3k599zh6CY3HKW0r2k1yaIdbWqt4upMCRCcUFi\nI4iedAmubgzh56wJdoMZztjXZRwDthTkJKNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\nBgNVHQ4EFgQUWbYkcrvVSnAWPR5PJhIzppcAnZIwDgYDVR0PAQH/BAQDAgGGMAoG\nCCqGSM49BAMDA2gAMGUCMCESGqpat93CjrSEjE7z+Hbvz0psZTHwqaxuiH64GKUm\nmYynIiwpKHyBrzjKBmeDoQIxANGrjIo6/b8Jl6sdIZQI18V0pAyLfLiZjlHVOnhM\nMOTVgr82ZuPoEHTX78MxeMnYlw==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgIRAIbsx8XOl0sgTNiCN4O+18QwDQYJKoZIhvcNAQELBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI1MjE1NDU4WhgPMjA2MTA1MjUyMjU0NTha\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\ntROxwXWCgn5R9gI/2Ivjzaxc0g95ysBjoJsnhPdJEHQb7w3y2kWrVWU3Y9fOitgb\nCEsnEC3PrhRnzNVW0fPsK6kbvOeCmjvY30rdbxbc8h+bjXfGmIOgAkmoULEr6Hc7\nG1Q/+tvv4lEwIs7bEaf+abSZxRJbZ0MBxhbHn7UHHDiMZYvzK+SV1MGCxx7JVhrm\nxWu3GC1zZCsGDhB9YqY9eR6PmjbqA5wy8vqbC57dZZa1QVtWIQn3JaRXn+faIzHx\nnLMN5CEWihsdmHBXhnRboXprE/OS4MFv1UrQF/XM/h5RBeCywpHePpC+Oe1T3LNC\niP8KzRFrjC1MX/WXJnmOVQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\nDgQWBBS33XbXAUMs1znyZo4B0+B3D68WFTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\nhvcNAQELBQADggEBADuadd2EmlpueY2VlrIIPC30QkoA1EOSoCmZgN6124apkoY1\nHiV4r+QNPljN4WP8gmcARnNkS7ZeR4fvWi8xPh5AxQCpiaBMw4gcbTMCuKDV68Pw\nP2dZCTMspvR3CDfM35oXCufdtFnxyU6PAyINUqF/wyTHguO3owRFPz64+sk3r2pT\nWHmJjG9E7V+KOh0s6REgD17Gqn6C5ijLchSrPUHB0wOIkeLJZndHxN/76h7+zhMt\nfFeNxPWHY2MfpcaLjz4UREzZPSB2U9k+y3pW1omCIcl6MQU9itGx/LpQE+H3ZeX2\nM2bdYd5L+ow+bdbGtsVKOuN+R9Dm17YpswF+vyQ=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGATCCA+mgAwIBAgIRAKlQ+3JX9yHXyjP/Ja6kZhkwDQYJKoZIhvcNAQEMBQAw\ngZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\nQW1hem9uIFJEUyBhcC1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMTA1MTkxNzQ1MjBaGA8yMTIxMDUxOTE4NDUyMFowgZgx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\nem9uIFJEUyBhcC1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKtahBrpUjQ6\nH2mni05BAKU6Z5USPZeSKmBBJN3YgD17rJ93ikJxSgzJ+CupGy5rvYQ0xznJyiV0\n91QeQN4P+G2MjGQR0RGeUuZcfcZitJro7iAg3UBvw8WIGkcDUg+MGVpRv/B7ry88\n7E4OxKb8CPNoa+a9j6ABjOaaxaI22Bb7j3OJ+JyMICs6CU2bgkJaj3VUV9FCNUOc\nh9PxD4jzT9yyGYm/sK9BAT1WOTPG8XQUkpcFqy/IerZDfiQkf1koiSd4s5VhBkUn\naQHOdri/stldT7a+HJFVyz2AXDGPDj+UBMOuLq0K6GAT6ThpkXCb2RIf4mdTy7ox\nN5BaJ+ih+Ro3ZwPkok60egnt/RN98jgbm+WstgjJWuLqSNInnMUgkuqjyBWwePqX\nKib+wdpyx/LOzhKPEFpeMIvHQ3A0sjlulIjnh+j+itezD+dp0UNxMERlW4Bn/IlS\nsYQVNfYutWkRPRLErXOZXtlxxkI98JWQtLjvGzQr+jywxTiw644FSLWdhKa6DtfU\n2JWBHqQPJicMElfZpmfaHZjtXuCZNdZQXWg7onZYohe281ZrdFPOqC4rUq7gYamL\nT+ZB+2P+YCPOLJ60bj/XSvcB7mesAdg8P0DNddPhHUFWx2dFqOs1HxIVB4FZVA9U\nPpbv4a484yxjTgG7zFZNqXHKTqze6rBBAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wHQYDVR0OBBYEFCEAqjighncv/UnWzBjqu1Ka2Yb4MA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQwFAAOCAgEAYyvumblckIXlohzi3QiShkZhqFzZultbFIu9\nGhA5CDar1IFMhJ9vJpO9nUK/camKs1VQRs8ZsBbXa0GFUM2p8y2cgUfLwFULAiC/\nsWETyW5lcX/xc4Pyf6dONhqFJt/ovVBxNZtcmMEWv/1D6Tf0nLeEb0P2i/pnSRR4\nOq99LVFjossXtyvtaq06OSiUUZ1zLPvV6AQINg8dWeBOWRcQYhYcEcC2wQ06KShZ\n0ahuu7ar5Gym3vuLK6nH+eQrkUievVomN/LpASrYhK32joQ5ypIJej3sICIgJUEP\nUoeswJ+Z16f3ECoL1OSnq4A0riiLj1ZGmVHNhM6m/gotKaHNMxsK9zsbqmuU6IT/\nP6cR0S+vdigQG8ZNFf5vEyVNXhl8KcaJn6lMD/gMB2rY0qpaeTg4gPfU5wcg8S4Y\nC9V//tw3hv0f2n+8kGNmqZrylOQDQWSSo8j8M2SRSXiwOHDoTASd1fyBEIqBAwzn\nLvXVg8wQd1WlmM3b0Vrsbzltyh6y4SuKSkmgufYYvC07NknQO5vqvZcNoYbLNea3\n76NkFaMHUekSbwVejZgG5HGwbaYBgNdJEdpbWlA3X4yGRVxknQSUyt4dZRnw/HrX\nk8x6/wvtw7wht0/DOqz1li7baSsMazqxx+jDdSr1h9xML416Q4loFCLgqQhil8Jq\nEm4Hy3A=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGBTCCA+2gAwIBAgIRAJfKe4Zh4aWNt3bv6ZjQwogwDQYJKoZIhvcNAQEMBQAw\ngZoxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEzMDEGA1UEAwwq\nQW1hem9uIFJEUyBjYS1jZW50cmFsLTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYD\nVQQHDAdTZWF0dGxlMCAXDTIxMDUyMTIyMDg1M1oYDzIxMjEwNTIxMjMwODUzWjCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIGNhLWNlbnRyYWwtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\nBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCpgUH6\nCrzd8cOw9prAh2rkQqAOx2vtuI7xX4tmBG4I/um28eBjyVmgwQ1fpq0Zg2nCKS54\nNn0pCmT7f3h6Bvopxn0J45AzXEtajFqXf92NQ3iPth95GVfAJSD7gk2LWMhpmID9\nJGQyoGuDPg+hYyr292X6d0madzEktVVGO4mKTF989qEg+tY8+oN0U2fRTrqa2tZp\niYsmg350ynNopvntsJAfpCO/srwpsqHHLNFZ9jvhTU8uW90wgaKO9i31j/mHggCE\n+CAOaJCM3g+L8DPl/2QKsb6UkBgaaIwKyRgKSj1IlgrK+OdCBCOgM9jjId4Tqo2j\nZIrrPBGl6fbn1+etZX+2/tf6tegz+yV0HHQRAcKCpaH8AXF44bny9andslBoNjGx\nH6R/3ib4FhPrnBMElzZ5i4+eM/cuPC2huZMBXb/jKgRC/QN1Wm3/nah5FWq+yn+N\ntiAF10Ga0BYzVhHDEwZzN7gn38bcY5yi/CjDUNpY0OzEe2+dpaBKPlXTaFfn9Nba\nCBmXPRF0lLGGtPeTAgjcju+NEcVa82Ht1pqxyu2sDtbu3J5bxp4RKtj+ShwN8nut\nTkf5Ea9rSmHEY13fzgibZlQhXaiFSKA2ASUwgJP19Putm0XKlBCNSGCoECemewxL\n+7Y8FszS4Uu4eaIwvXVqUEE2yf+4ex0hqQ1acQIDAQABo0IwQDAPBgNVHRMBAf8E\nBTADAQH/MB0GA1UdDgQWBBSeUnXIRxNbYsZLtKomIz4Y1nOZEzAOBgNVHQ8BAf8E\nBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBAIpRvxVS0dzoosBh/qw65ghPUGSbP2D4\ndm6oYCv5g/zJr4fR7NzEbHOXX5aOQnHbQL4M/7veuOCLNPOW1uXwywMg6gY+dbKe\nYtPVA1as8G9sUyadeXyGh2uXGsziMFXyaESwiAXZyiYyKChS3+g26/7jwECFo5vC\nXGhWpIO7Hp35Yglp8AnwnEAo/PnuXgyt2nvyTSrxlEYa0jus6GZEZd77pa82U1JH\nqFhIgmKPWWdvELA3+ra1nKnvpWM/xX0pnMznMej5B3RT3Y+k61+kWghJE81Ix78T\n+tG4jSotgbaL53BhtQWBD1yzbbilqsGE1/DXPXzHVf9yD73fwh2tGWSaVInKYinr\na4tcrB3KDN/PFq0/w5/21lpZjVFyu/eiPj6DmWDuHW73XnRwZpHo/2OFkei5R7cT\nrn/YdDD6c1dYtSw5YNnS6hdCQ3sOiB/xbPRN9VWJa6se79uZ9NLz6RMOr73DNnb2\nbhIR9Gf7XAA5lYKqQk+A+stoKbIT0F65RnkxrXi/6vSiXfCh/bV6B41cf7MY/6YW\nehserSdjhQamv35rTFdM+foJwUKz1QN9n9KZhPxeRmwqPitAV79PloksOnX25ElN\nSlyxdndIoA1wia1HRd26EFm2pqfZ2vtD2EjU3wD42CXX4H8fKVDna30nNFSYF0yn\njGKc3k6UNxpg\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIF/jCCA+agAwIBAgIQaRHaEqqacXN20e8zZJtmDDANBgkqhkiG9w0BAQwFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIHVzLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTI1MjIzODM1WhgPMjEyMTA1MjUyMzM4MzVaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgdXMtZWFzdC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAInfBCaHuvj6Rb5c\nL5Wmn1jv2PHtEGMHm+7Z8dYosdwouG8VG2A+BCYCZfij9lIGszrTXkY4O7vnXgru\nJUNdxh0Q3M83p4X+bg+gODUs3jf+Z3Oeq7nTOk/2UYvQLcxP4FEXILxDInbQFcIx\nyen1ESHggGrjEodgn6nbKQNRfIhjhW+TKYaewfsVWH7EF2pfj+cjbJ6njjgZ0/M9\nVZifJFBgat6XUTOf3jwHwkCBh7T6rDpgy19A61laImJCQhdTnHKvzTpxcxiLRh69\nZObypR7W04OAUmFS88V7IotlPmCL8xf7kwxG+gQfvx31+A9IDMsiTqJ1Cc4fYEKg\nbL+Vo+2Ii4W2esCTGVYmHm73drznfeKwL+kmIC/Bq+DrZ+veTqKFYwSkpHRyJCEe\nU4Zym6POqQ/4LBSKwDUhWLJIlq99bjKX+hNTJykB+Lbcx0ScOP4IAZQoxmDxGWxN\nS+lQj+Cx2pwU3S/7+OxlRndZAX/FKgk7xSMkg88HykUZaZ/ozIiqJqSnGpgXCtED\noQ4OJw5ozAr+/wudOawaMwUWQl5asD8fuy/hl5S1nv9XxIc842QJOtJFxhyeMIXt\nLVECVw/dPekhMjS3Zo3wwRgYbnKG7YXXT5WMxJEnHu8+cYpMiRClzq2BEP6/MtI2\nAZQQUFu2yFjRGL2OZA6IYjxnXYiRAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\nHQYDVR0OBBYEFADCcQCPX2HmkqQcmuHfiQ2jjqnrMA4GA1UdDwEB/wQEAwIBhjAN\nBgkqhkiG9w0BAQwFAAOCAgEASXkGQ2eUmudIKPeOIF7RBryCoPmMOsqP0+1qxF8l\npGkwmrgNDGpmd9s0ArfIVBTc1jmpgB3oiRW9c6n2OmwBKL4UPuQ8O3KwSP0iD2sZ\nKMXoMEyphCEzW1I2GRvYDugL3Z9MWrnHkoaoH2l8YyTYvszTvdgxBPpM2x4pSkp+\n76d4/eRpJ5mVuQ93nC+YG0wXCxSq63hX4kyZgPxgCdAA+qgFfKIGyNqUIqWgeyTP\nn5OgKaboYk2141Rf2hGMD3/hsGm0rrJh7g3C0ZirPws3eeJfulvAOIy2IZzqHUSY\njkFzraz6LEH3IlArT3jUPvWKqvh2lJWnnp56aqxBR7qHH5voD49UpJWY1K0BjGnS\nOHcurpp0Yt/BIs4VZeWdCZwI7JaSeDcPMaMDBvND3Ia5Fga0thgYQTG6dE+N5fgF\nz+hRaujXO2nb0LmddVyvE8prYlWRMuYFv+Co8hcMdJ0lEZlfVNu0jbm9/GmwAZ+l\n9umeYO9yz/uC7edC8XJBglMAKUmVK9wNtOckUWAcCfnPWYLbYa/PqtXBYcxrso5j\niaS/A7iEW51uteHBGrViCy1afGG+hiUWwFlesli+Rq4dNstX3h6h2baWABaAxEVJ\ny1RnTQSz6mROT1VmZSgSVO37rgIyY0Hf0872ogcTS+FfvXgBxCxsNWEbiQ/XXva4\n0Ws=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICtDCCAjqgAwIBAgIRAMyaTlVLN0ndGp4ffwKAfoMwCgYIKoZIzj0EAwMwgZkx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1h\nem9uIFJEUyBtZS1jZW50cmFsLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjIwNTA3MDA0NDM3WhgPMjEyMjA1MDcwMTQ0MzdaMIGZMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMjAwBgNVBAMMKUFtYXpv\nbiBSRFMgbWUtY2VudHJhbC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE19nCV1nsI6CohSor13+B25cr\nzg+IHdi9Y3L7ziQnHWI6yjBazvnKD+oC71aRRlR8b5YXsYGUQxWzPLHN7EGPcSGv\nbzA9SLG1KQYCJaQ0m9Eg/iGrwKWOgylbhVw0bCxoo0IwQDAPBgNVHRMBAf8EBTAD\nAQH/MB0GA1UdDgQWBBS4KsknsJXM9+QPEkBdZxUPaLr11zAOBgNVHQ8BAf8EBAMC\nAYYwCgYIKoZIzj0EAwMDaAAwZQIxAJaRgrYIEfXQMZQQDxMTYS0azpyWSseQooXo\nL3nYq4OHGBgYyQ9gVjvRYWU85PXbfgIwdi82DtANQFkCu+j+BU0JBY/uRKPEeYzo\nJG92igKIcXPqCoxIJ7lJbbzmuf73gQu5\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGATCCA+mgAwIBAgIRAJwCobx0Os8F7ihbJngxrR8wDQYJKoZIhvcNAQEMBQAw\ngZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\nQW1hem9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMTA1MjAxNzE1MzNaGA8yMTIxMDUyMDE4MTUzM1owgZgx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\nem9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANukKwlm+ZaI\nY5MkWGbEVLApEyLmlrHLEg8PfiiEa9ts7jssQcin3bzEPdTqGr5jo91ONoZ3ccWq\nxJgg1W3bLu5CAO2CqIOXTXHRyCO/u0Ch1FGgWB8xETPSi3UHt/Vn1ltdO6DYdbDU\nmYgwzYrvLBdRCwxsb9o+BuYQHVFzUYonqk/y9ujz3gotzFq7r55UwDTA1ita3vb4\neDKjIb4b1M4Wr81M23WHonpje+9qkkrAkdQcHrkgvSCV046xsq/6NctzwCUUNsgF\n7Q1a8ut5qJEYpz5ta8vI1rqFqAMBqCbFjRYlmAoTTpFPOmzAVxV+YoqTrW5A16su\n/2SXlMYfJ/n/ad/QfBNPPAAQMpyOr2RCL/YiL/PFZPs7NxYjnZHNWxMLSPgFyI+/\nt2klnn5jR76KJK2qimmaXedB90EtFsMRUU1e4NxH9gDuyrihKPJ3aVnZ35mSipvR\n/1KB8t8gtFXp/VQaz2sg8+uxPMKB81O37fL4zz6Mg5K8+aq3ejBiyHucpFGnsnVB\n3kQWeD36ONkybngmgWoyPceuSWm1hQ0Z7VRAQX+KlxxSaHmSaIk1XxZu9h9riQHx\nfMuev6KXjRn/CjCoUTn+7eFrt0dT5GryQEIZP+nA0oq0LKxogigHNZlwAT4flrqb\nJUfZJrqgoce5HjZSXl10APbtPjJi0fW9AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wHQYDVR0OBBYEFEfV+LztI29OVDRm0tqClP3NrmEWMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQwFAAOCAgEAvSNe+0wuk53KhWlRlRf2x/97H2Q76X3anzF0\n5fOSVm022ldALzXMzqOfdnoKIhAu2oVKiHHKs7mMas+T6TL+Mkphx0CYEVxFE3PG\n061q3CqJU+wMm9W9xsB79oB2XG47r1fIEywZZ3GaRsatAbjcNOT8uBaATPQAfJFN\nzjFe4XyN+rA4cFrYNvfHTeu5ftrYmvks7JlRaJgEGWsz+qXux7uvaEEVPqEumd2H\nuYeaRNOZ2V23R009X5lbgBFx9tq5VDTnKhQiTQ2SeT0rc1W3Dz5ik6SbQQNP3nSR\n0Ywy7r/sZ3fcDyfFiqnrVY4Ympfvb4YW2PZ6OsQJbzH6xjdnTG2HtzEU30ngxdp1\nWUEF4zt6rjJCp7QBUqXgdlHvJqYu6949qtWjEPiFN9uSsRV2i1YDjJqN52dLjAPn\nAipJKo8x1PHTwUzuITqnB9BdP+5TlTl8biJfkEf/+08eWDTLlDHr2VrZLOLompTh\nbS5OrhDmqA2Q+O+EWrTIhMflwwlCpR9QYM/Xwvlbad9H0FUHbJsCVNaru3wGOgWo\ntt3dNSK9Lqnv/Ej9K9v6CRr36in4ylJKivhJ5B9E7ABHg7EpBJ1xi7O5eNDkNoJG\n+pFyphJq3AkBR2U4ni2tUaTAtSW2tks7IaiDV+UMtqZyGabT5ISQfWLLtLHSWn2F\nTspdjbg=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgIRAJZFh4s9aZGzKaTMLrSb4acwDQYJKoZIhvcNAQELBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBCZXRhIHVzLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTE4MjEyODQxWhgPMjA2MTA1MTgyMjI4NDFa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgQmV0YSB1cy1lYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n17i2yoU6diep+WrqxIn2CrDEO2NdJVwWTSckx4WMZlLpkQDoymSmkNHjq9ADIApD\nA31Cx+843apL7wub8QkFZD0Tk7/ThdHWJOzcAM3ov98QBPQfOC1W5zYIIRP2F+vQ\nTRETHQnLcW3rLv0NMk5oQvIKpJoC9ett6aeVrzu+4cU4DZVWYlJUoC/ljWzCluau\n8blfW0Vwin6OB7s0HCG5/wijQWJBU5SrP/KAIPeQi1GqG5efbqAXDr/ple0Ipwyo\nXjjl73LenGUgqpANlC9EAT4i7FkJcllLPeK3NcOHjuUG0AccLv1lGsHAxZLgjk/x\nz9ZcnVV9UFWZiyJTKxeKPwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\nDgQWBBRWyMuZUo4gxCR3Luf9/bd2AqZ7CjAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\nhvcNAQELBQADggEBAIqN2DlIKlvDFPO0QUZQVFbsi/tLdYM98/vvzBpttlTGVMyD\ngJuQeHVz+MnhGIwoCGOlGU3OOUoIlLAut0+WG74qYczn43oA2gbMd7HoD7oL/IGg\nnjorBwJVcuuLv2G//SqM3nxGcLRtkRnQ+lvqPxMz9+0fKFUn6QcIDuF0QSfthLs2\nWSiGEPKO9c9RSXdRQ4pXA7c3hXng8P4A2ZmdciPne5Nu4I4qLDGZYRrRLRkNTrOi\nTyS6r2HNGUfgF7eOSeKt3NWL+mNChcYj71/Vycf5edeczpUgfnWy9WbPrK1svKyl\naAs2xg+X6O8qB+Mnj2dNBzm+lZIS3sIlm+nO9sg=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICrjCCAjSgAwIBAgIRAPAlEk8VJPmEzVRRaWvTh2AwCgYIKoZIzj0EAwMwgZYx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\nem9uIFJEUyB1cy1lYXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTI1MjI0MTU1WhgPMjEyMTA1MjUyMzQxNTVaMIGWMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\nRFMgdXMtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\nMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEx5xjrup8II4HOJw15NTnS3H5yMrQGlbj\nEDA5MMGnE9DmHp5dACIxmPXPMe/99nO7wNdl7G71OYPCgEvWm0FhdvVUeTb3LVnV\nBnaXt32Ek7/oxGk1T+Df03C+W0vmuJ+wo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\nA1UdDgQWBBTGXmqBWN/1tkSea4pNw0oHrjk2UDAOBgNVHQ8BAf8EBAMCAYYwCgYI\nKoZIzj0EAwMDaAAwZQIxAIqqZWCSrIkZ7zsv/FygtAusW6yvlL935YAWYPVXU30m\njkMFLM+/RJ9GMvnO8jHfCgIwB+whlkcItzE9CRQ6CsMo/d5cEHDUu/QW6jSIh9BR\nOGh9pTYPVkUbBiKPA7lVVhre\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIF/zCCA+egAwIBAgIRAJGY9kZITwfSRaAS/bSBOw8wDQYJKoZIhvcNAQEMBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyBzYS1lYXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUxOTE4MTEyMFoYDzIxMjEwNTE5MTkxMTIwWjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIHNhLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDe2vlDp6Eo4WQi\nWi32YJOgdXHhxTFrLjB9SRy22DYoMaWfginJIwJcSR8yse8ZDQuoNhERB9LRggAE\neng23mhrfvtL1yQkMlZfBu4vG1nOb22XiPFzk7X2wqz/WigdYNBCqa1kK3jrLqPx\nYUy7jk2oZle4GLVRTNGuMfcid6S2hs3UCdXfkJuM2z2wc3WUlvHoVNk37v2/jzR/\nhSCHZv5YHAtzL/kLb/e64QkqxKll5QmKhyI6d7vt6Lr1C0zb+DmwxUoJhseAS0hI\ndRk5DklMb4Aqpj6KN0ss0HAYqYERGRIQM7KKA4+hxDMUkJmt8KqWKZkAlCZgflzl\nm8NZ31o2cvBzf6g+VFHx+6iVrSkohVQydkCxx7NJ743iPKsh8BytSM4qU7xx4OnD\nH2yNXcypu+D5bZnVZr4Pywq0w0WqbTM2bpYthG9IC4JeVUvZ2mDc01lqOlbMeyfT\nog5BRPLDXdZK8lapo7se2teh64cIfXtCmM2lDSwm1wnH2iSK+AWZVIM3iE45WSGc\nvZ+drHfVgjJJ5u1YrMCWNL5C2utFbyF9Obw9ZAwm61MSbPQL9JwznhNlCh7F2ANW\nZHWQPNcOAJqzE4uVcJB1ZeVl28ORYY1668lx+s9yYeMXk3QQdj4xmdnvoBFggqRB\nZR6Z0D7ZohADXe024RzEo1TukrQgKQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\nMB0GA1UdDgQWBBT7Vs4Y5uG/9aXnYGNMEs6ycPUT3jAOBgNVHQ8BAf8EBAMCAYYw\nDQYJKoZIhvcNAQEMBQADggIBACN4Htp2PvGcQA0/sAS+qUVWWJoAXSsu8Pgc6Gar\n7tKVlNJ/4W/a6pUV2Xo/Tz3msg4yiE8sMESp2k+USosD5n9Alai5s5qpWDQjrqrh\n76AGyF2nzve4kIN19GArYhm4Mz/EKEG1QHYvBDGgXi3kNvL/a2Zbybp+3LevG+q7\nxtx4Sz9yIyMzuT/6Y7ijtiMZ9XbuxGf5wab8UtwT3Xq1UradJy0KCkzRJAz/Wy/X\nHbTkEvKSaYKExH6sLo0jqdIjV/d2Io31gt4e0Ly1ER2wPyFa+pc/swu7HCzrN+iz\nA2ZM4+KX9nBvFyfkHLix4rALg+WTYJa/dIsObXkdZ3z8qPf5A9PXlULiaa1mcP4+\nrokw74IyLEYooQ8iSOjxumXhnkTS69MAdGzXYE5gnHokABtGD+BB5qLhtLt4fqAp\n8AyHpQWMyV42M9SJLzQ+iOz7kAgJOBOaVtJI3FV/iAg/eqWVm3yLuUTWDxSHrKuL\nN19+pSjF6TNvUSFXwEa2LJkfDqIOCE32iOuy85QY//3NsgrSQF6UkSPa95eJrSGI\n3hTRYYh3Up2GhBGl1KUy7/o0k3KRZTk4s38fylY8bZ3TakUOH5iIGoHyFVVcp361\nPyy25SzFSmNalWoQd9wZVc/Cps2ldxhcttM+WLkFNzprd0VJa8qTz8vYtHP0ouDN\nnWS0\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGCTCCA/GgAwIBAgIRAOY7gfcBZgR2tqfBzMbFQCUwDQYJKoZIhvcNAQEMBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtNCBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjIwNTI1MTY1NDU5WhgPMjEyMjA1MjUxNzU0NTla\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTQgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\nlfxER43FuLRdL08bddF0YhbCP+XXKj1A/TFMXmd2My8XDei8rPXFYyyjMig9+xZw\nuAsIxLwz8uiA26CKA8bCZKg5VG2kTeOJAfvBJaLv1CZefs3Z4Uf1Sjvm6MF2yqEj\nGoORfyfL9HiZFTDuF/hcjWoKYCfMuG6M/wO8IbdICrX3n+BiYQJu/pFO660Mg3h/\n8YBBWYDbHoCiH/vkqqJugQ5BM3OI5nsElW51P1icEEqti4AZ7JmtSv9t7fIFBVyR\noaEyOgpp0sm193F/cDJQdssvjoOnaubsSYm1ep3awZAUyGN/X8MBrPY95d0hLhfH\nEhc5Icyg+hsosBljlAyksmt4hFQ9iBnWIz/ZTfGMck+6p3HVL9RDgvluez+rWv59\n8q7omUGsiPApy5PDdwI/Wt/KtC34/2sjslIJfvgifdAtkRPkhff1WEwER00ADrN9\neGGInaCpJfb1Rq8cV2n00jxg7DcEd65VR3dmIRb0bL+jWK62ni/WdEyomAOMfmGj\naWf78S/4rasHllWJ+QwnaUYY3u6N8Cgio0/ep4i34FxMXqMV3V0/qXdfhyabi/LM\nwCxNo1Dwt+s6OtPJbwO92JL+829QAxydfmaMTeHBsgMPkG7RwAekeuatKGHNsc2Z\nx2Q4C2wVvOGAhcHwxfM8JfZs3nDSZJndtVVnFlUY0UECAwEAAaNCMEAwDwYDVR0T\nAQH/BAUwAwEB/zAdBgNVHQ4EFgQUpnG7mWazy6k97/tb5iduRB3RXgQwDgYDVR0P\nAQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQCDLqq1Wwa9Tkuv7vxBnIeVvvFF\necTn+P+wJxl9Qa2ortzqTHZsBDyJO62d04AgBwiDXkJ9a+bthgG0H1J7Xee8xqv1\nxyX2yKj24ygHjspLotKP4eDMdDi5TYq+gdkbPmm9Q69B1+W6e049JVGXvWG8/7kU\nigxeuCYwtCCdUPRLf6D8y+1XMGgVv3/DSOHWvTg3MJ1wJ3n3+eve3rjGdRYWZeJu\nk21HLSZYzVrCtUsh2YAeLnUbSxVuT2Xr4JehYe9zW5HEQ8Je/OUfnCy9vzoN/ITw\nosAH+EBJQey7RxEDqMwCaRefH0yeHFcnOll0OXg/urnQmwbEYzQ1uutJaBPsjU0J\nQf06sMxI7GiB5nPE+CnI2sM6A9AW9kvwexGXpNJiLxF8dvPQthpOKGcYu6BFvRmt\n6ctfXd9b7JJoVqMWuf5cCY6ihpk1e9JTlAqu4Eb/7JNyGiGCR40iSLvV28un9wiE\nplrdYxwcNYq851BEu3r3AyYWw/UW1AKJ5tM+/Gtok+AphMC9ywT66o/Kfu44mOWm\nL3nSLSWEcgfUVgrikpnyGbUnGtgCmHiMlUtNVexcE7OtCIZoVAlCGKNu7tyuJf10\nQlk8oIIzfSIlcbHpOYoN79FkLoDNc2er4Gd+7w1oPQmdAB0jBJnA6t0OUBPKdDdE\nUfff2jrbfbzECn1ELg==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGCDCCA/CgAwIBAgIQIuO1A8LOnmc7zZ/vMm3TrDANBgkqhkiG9w0BAQwFADCB\nnDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\nbWF6b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4G\nA1UEBwwHU2VhdHRsZTAgFw0yMTA1MjQyMDQ2MThaGA8yMTIxMDUyNDIxNDYxOFow\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDq\nqRHKbG8ZK6/GkGm2cenznEF06yHwI1gD5sdsHjTgekDZ2Dl9RwtDmUH2zFuIQwGj\nSeC7E2iKwrJRA5wYzL9/Vk8NOILEKQOP8OIKUHbc7q8rEtjs401KcU6pFBBEdO9G\nCTiRhogq+8mhC13AM/UriZJbKhwgM2UaDOzAneGMhQAGjH8z83NsNcPxpYVE7tqM\nsch5yLtIJLkJRusrmQQTeHUev16YNqyUa+LuFclFL0FzFCimkcxUhXlbfEKXbssS\nyPzjiv8wokGyo7+gA0SueceMO2UjfGfute3HlXZDcNvBbkSY+ver41jPydyRD6Qq\noEkh0tyIbPoa3oU74kwipJtz6KBEA3u3iq61OUR0ENhR2NeP7CSKrC24SnQJZ/92\nqxusrbyV/0w+U4m62ug/o4hWNK1lUcc2AqiBOvCSJ7qpdteTFxcEIzDwYfERDx6a\nd9+3IPvzMb0ZCxBIIUFMxLTF7yAxI9s6KZBBXSZ6tDcCCYIgEysEPRWMRAcG+ye/\nfZVn9Vnzsj4/2wchC2eQrYpb1QvG4eMXA4M5tFHKi+/8cOPiUzJRgwS222J8YuDj\nyEBval874OzXk8H8Mj0JXJ/jH66WuxcBbh5K7Rp5oJn7yju9yqX6qubY8gVeMZ1i\nu4oXCopefDqa35JplQNUXbWwSebi0qJ4EK0V8F9Q+QIDAQABo0IwQDAPBgNVHRMB\nAf8EBTADAQH/MB0GA1UdDgQWBBT4ysqCxaPe7y+g1KUIAenqu8PAgzAOBgNVHQ8B\nAf8EBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBALU8WN35KAjPZEX65tobtCDQFkIO\nuJjv0alD7qLB0i9eY80C+kD87HKqdMDJv50a5fZdqOta8BrHutgFtDm+xo5F/1M3\nu5/Vva5lV4xy5DqPajcF4Mw52czYBmeiLRTnyPJsU93EQIC2Bp4Egvb6LI4cMOgm\n4pY2hL8DojOC5PXt4B1/7c1DNcJX3CMzHDm4SMwiv2MAxSuC/cbHXcWMk+qXdrVx\n+ayLUSh8acaAOy3KLs1MVExJ6j9iFIGsDVsO4vr4ZNsYQiyHjp+L8ops6YVBO5AT\nk/pI+axHIVsO5qiD4cFWvkGqmZ0gsVtgGUchZaacboyFsVmo6QPrl28l6LwxkIEv\nGGJYvIBW8sfqtGRspjfX5TlNy5IgW/VOwGBdHHsvg/xpRo31PR3HOFw7uPBi7cAr\nFiZRLJut7af98EB2UvovZnOh7uIEGPeecQWeOTQfJeWet2FqTzFYd0NUMgqPuJx1\nvLKferP+ajAZLJvVnW1J7Vccx/pm0rMiUJEf0LRb/6XFxx7T2RGjJTi0EzXODTYI\ngnLfBBjnolQqw+emf4pJ4pAtly0Gq1KoxTG2QN+wTd4lsCMjnelklFDjejwnl7Uy\nvtxzRBAu/hi/AqDkDFf94m6j+edIrjbi9/JDFtQ9EDlyeqPgw0qwi2fwtJyMD45V\nfejbXelUSJSzDIdY\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGCTCCA/GgAwIBAgIRAN7Y9G9i4I+ZaslPobE7VL4wDQYJKoZIhvcNAQEMBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIwMTYzMzIzWhgPMjEyMTA1MjAxNzMzMjNa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTIgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\n4BEPCiIfiK66Q/qa8k+eqf1Q3qsa6Xuu/fPkpuStXVBShhtXd3eqrM0iT4Xxs420\nVa0vSB3oZ7l86P9zYfa60n6PzRxdYFckYX330aI7L/oFIdaodB/C9szvROI0oLG+\n6RwmIF2zcprH0cTby8MiM7G3v9ykpq27g4WhDC1if2j8giOQL3oHpUaByekZNIHF\ndIllsI3RkXmR3xmmxoOxJM1B9MZi7e1CvuVtTGOnSGpNCQiqofehTGwxCN2wFSK8\nxysaWlw48G0VzZs7cbxoXMH9QbMpb4tpk0d+T8JfAPu6uWO9UwCLWWydf0CkmA/+\nD50/xd1t33X9P4FEaPSg5lYbHXzSLWn7oLbrN2UqMLaQrkoEBg/VGvzmfN0mbflw\n+T87bJ/VEOVNlG+gepyCTf89qIQVWOjuYMox4sK0PjzZGsYEuYiq1+OUT3vk/e5K\nag1fCcq2Isy4/iwB2xcXrsQ6ljwdk1fc+EmOnjGKrhuOHJY3S+RFv4ToQBsVyYhC\nXGaC3EkqIX0xaCpDimxYhFjWhpDXAjG/zJ+hRLDAMCMhl/LPGRk/D1kzSbPmdjpl\nlEMK5695PeBvEBTQdBQdOiYgOU3vWU6tzwwHfiM2/wgvess/q0FDAHfJhppbgbb9\n3vgsIUcsvoC5o29JvMsUxsDRvsAfEmMSDGkJoA/X6GECAwEAAaNCMEAwDwYDVR0T\nAQH/BAUwAwEB/zAdBgNVHQ4EFgQUgEWm1mZCbGD6ytbwk2UU1aLaOUUwDgYDVR0P\nAQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQBb4+ABTGBGwxK1U/q4g8JDqTQM\n1Wh8Oz8yAk4XtPJMAmCctxbd81cRnSnePWw/hxViLVtkZ/GsemvXfqAQyOn1coN7\nQeYSw+ZOlu0j2jEJVynmgsR7nIRqE7QkCyZAU+d2FTJUfmee+IiBiGyFGgxz9n7A\nJhBZ/eahBbiuoOik/APW2JWLh0xp0W0GznfJ8lAlaQTyDa8iDXmVtbJg9P9qzkvl\nFgPXQttzEOyooF8Pb2LCZO4kUz+1sbU7tHdr2YE+SXxt6D3SBv+Yf0FlvyWLiqVk\nGDEOlPPTDSjAWgKnqST8UJ0RDcZK/v1ixs7ayqQJU0GUQm1I7LGTErWXHMnCuHKe\nUKYuiSZwmTcJ06NgdhcCnGZgPq13ryMDqxPeltQc3n5eO7f1cL9ERYLDLOzm6A9P\noQ3MfcVOsbHgGHZWaPSeNrQRN9xefqBXH0ZPasgcH9WJdsLlEjVUXoultaHOKx3b\nUCCb+d3EfqF6pRT488ippOL6bk7zNubwhRa/+y4wjZtwe3kAX78ACJVcjPobH9jZ\nErySads5zdQeaoee5wRKdp3TOfvuCe4bwLRdhOLCHWzEcXzY3g/6+ppLvNom8o+h\nBh5X26G6KSfr9tqhQ3O9IcbARjnuPbvtJnoPY0gz3EHHGPhy0RNW8i2gl3nUp0ah\nPtjwbKW0hYAhIttT0Q==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICtzCCAj2gAwIBAgIQQRBQTs6Y3H1DDbpHGta3lzAKBggqhkjOPQQDAzCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLXNvdXRoZWFzdC0zIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDYxMTAwMTI0M1oYDzIxMjEwNjExMDExMjQzWjCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLXNvdXRoZWFzdC0zIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEs0942Xj4m/gKA+WA6F5h\nAHYuek9eGpzTRoLJddM4rEV1T3eSueytMVKOSlS3Ub9IhyQrH2D8EHsLYk9ktnGR\npATk0kCYTqFbB7onNo070lmMJmGT/Q7NgwC8cySChFxbo0IwQDAPBgNVHRMBAf8E\nBTADAQH/MB0GA1UdDgQWBBQ20iKBKiNkcbIZRu0y1uoF1yJTEzAOBgNVHQ8BAf8E\nBAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIwYv0wTSrpQTaPaarfLN8Xcqrqu3hzl07n\nFrESIoRw6Cx77ZscFi2/MV6AFyjCV/TlAjEAhpwJ3tpzPXpThRML8DMJYZ3YgMh3\nCMuLqhPpla3cL0PhybrD27hJWl29C4el6aMO\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICrDCCAjOgAwIBAgIQGcztRyV40pyMKbNeSN+vXTAKBggqhkjOPQQDAzCBljEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMS8wLQYDVQQDDCZBbWF6\nb24gUkRTIHVzLWVhc3QtMiBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTAgFw0yMTA1MjEyMzE1NTZaGA8yMTIxMDUyMjAwMTU1NlowgZYxCzAJBgNV\nBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYD\nVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1hem9uIFJE\nUyB1cy1lYXN0LTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0bGUw\ndjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQfDcv+GGRESD9wT+I5YIPRsD3L+/jsiIis\nTr7t9RSbFl+gYpO7ZbDXvNbV5UGOC5lMJo/SnqFRTC6vL06NF7qOHfig3XO8QnQz\n6T5uhhrhnX2RSY3/10d2kTyHq3ZZg3+jQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYD\nVR0OBBYEFLDyD3PRyNXpvKHPYYxjHXWOgfPnMA4GA1UdDwEB/wQEAwIBhjAKBggq\nhkjOPQQDAwNnADBkAjB20HQp6YL7CqYD82KaLGzgw305aUKw2aMrdkBR29J183jY\n6Ocj9+Wcif9xnRMS+7oCMAvrt03rbh4SU9BohpRUcQ2Pjkh7RoY0jDR4Xq4qzjNr\n5UFr3BXpFvACxXF51BksGQ==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICrjCCAjWgAwIBAgIQeKbS5zvtqDvRtwr5H48cAjAKBggqhkjOPQQDAzCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTIwMTcxOTU1WhgPMjEyMTA1MjAxODE5NTVaMIGXMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\nRFMgbWUtc291dGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\nZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABEKjgUaAPmUlRMEQdBC7BScAGosJ1zRV\nLDd38qTBjzgmwBfQJ5ZfGIvyEK5unB09MB4e/3qqK5I/L6Qn5Px/n5g4dq0c7MQZ\nu7G9GBYm90U3WRJBf7lQrPStXaRnS4A/O6NCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\nBgNVHQ4EFgQUNKcAbGEIn03/vkwd8g6jNyiRdD4wDgYDVR0PAQH/BAQDAgGGMAoG\nCCqGSM49BAMDA2cAMGQCMHIeTrjenCSYuGC6txuBt/0ZwnM/ciO9kHGWVCoK8QLs\njGghb5/YSFGZbmQ6qpGlSAIwVOQgdFfTpEfe5i+Vs9frLJ4QKAfc27cTNYzRIM0I\nE+AJgK4C4+DiyyMzOpiCfmvq\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGCDCCA/CgAwIBAgIQSFkEUzu9FYgC5dW+5lnTgjANBgkqhkiG9w0BAQwFADCB\nnDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\nbWF6b24gUkRTIGFwLXNvdXRoZWFzdC0zIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4G\nA1UEBwwHU2VhdHRsZTAgFw0yMTA2MTEwMDA4MzZaGA8yMTIxMDYxMTAxMDgzNlow\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMyBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDx\nmy5Qmd8zdwaI/KOKV9Xar9oNbhJP5ED0JCiigkuvCkg5qM36klszE8JhsUj40xpp\nvQw9wkYW4y+C8twBpzKGBvakqMnoaVUV7lOCKx0RofrnNwkZCboTBB4X/GCZ3fIl\nYTybS7Ehi1UuiaZspIT5A2jidoA8HiBPk+mTg1UUkoWS9h+MEAPa8L4DY6fGf4pO\nJ1Gk2cdePuNzzIrpm2yPto+I8MRROwZ3ha7ooyymOXKtz2c7jEHHJ314boCXAv9G\ncdo27WiebewZkHHH7Zx9iTIVuuk2abyVSzvLVeGv7Nuy4lmSqa5clWYqWsGXxvZ2\n0fZC5Gd+BDUMW1eSpW7QDTk3top6x/coNoWuLSfXiC5ZrJkIKimSp9iguULgpK7G\nabMMN4PR+O+vhcB8E879hcwmS2yd3IwcPTl3QXxufqeSV58/h2ibkqb/W4Bvggf6\n5JMHQPlPHOqMCVFIHP1IffIo+Of7clb30g9FD2j3F4qgV3OLwEDNg/zuO1DiAvH1\nL+OnmGHkfbtYz+AVApkAZrxMWwoYrwpauyBusvSzwRE24vLTd2i80ZDH422QBLXG\nrN7Zas8rwIiBKacJLYtBYETw8mfsNt8gb72aIQX6cZOsphqp6hUtKaiMTVgGazl7\ntBXqbB+sIv3S9X6bM4cZJKkMJOXbnyCCLZFYv8TurwIDAQABo0IwQDAPBgNVHRMB\nAf8EBTADAQH/MB0GA1UdDgQWBBTOVtaS1b/lz6yJDvNk65vEastbQTAOBgNVHQ8B\nAf8EBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBABEONg+TmMZM/PrYGNAfB4S41zp1\n3CVjslZswh/pC4kgXSf8cPJiUOzMwUevuFQj7tCqxQtJEygJM2IFg4ViInIah2kh\nxlRakEGGw2dEVlxZAmmLWxlL1s1lN1565t5kgVwM0GVfwYM2xEvUaby6KDVJIkD3\naM6sFDBshvVA70qOggM6kU6mwTbivOROzfoIQDnVaT+LQjHqY/T+ok6IN0YXXCWl\nFavai8RDjzLDFwXSRvgIK+1c49vlFFY4W9Efp7Z9tPSZU1TvWUcKdAtV8P2fPHAS\nvAZ+g9JuNfeawhEibjXkwg6Z/yFUueQCQOs9TRXYogzp5CMMkfdNJF8byKYqHscs\nUosIcETnHwqwban99u35sWcoDZPr6aBIrz7LGKTJrL8Nis8qHqnqQBXu/fsQEN8u\nzJ2LBi8sievnzd0qI0kaWmg8GzZmYH1JCt1GXSqOFkI8FMy2bahP7TUQR1LBUKQ3\nhrOSqldkhN+cSAOnvbQcFzLr+iEYEk34+NhcMIFVE+51KJ1n6+zISOinr6mI3ckX\n6p2tmiCD4Shk2Xx/VTY/KGvQWKFcQApWezBSvDNlGe0yV71LtLf3dr1pr4ofo7cE\nrYucCJ40bfxEU/fmzYdBF32xP7AOD9U0FbOR3Mcthc6Z6w20WFC+zru8FGY08gPf\nWT1QcNdw7ntUJP/w\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICrzCCAjWgAwIBAgIQARky6+5PNFRkFVOp3Ob1CTAKBggqhkjOPQQDAzCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGV1LXNvdXRoLTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjIwNTIzMTg0MTI4WhgPMjEyMjA1MjMxOTQxMjdaMIGXMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\nRFMgZXUtc291dGgtMiBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\nZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABNVGL5oF7cfIBxKyWd2PVK/S5yQfaJY3\nQFHWvEdt6951n9JhiiPrHzfVHsxZp1CBjILRMzjgRbYWmc8qRoLkgGE7htGdwudJ\nFa/WuKzO574Prv4iZXUnVGTboC7JdvKbh6NCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\nBgNVHQ4EFgQUgDeIIEKynwUbNXApdIPnmRWieZwwDgYDVR0PAQH/BAQDAgGGMAoG\nCCqGSM49BAMDA2gAMGUCMEOOJfucrST+FxuqJkMZyCM3gWGZaB+/w6+XUAJC6hFM\nuSTY0F44/bERkA4XhH+YGAIxAIpJQBakCA1/mXjsTnQ+0El9ty+LODp8ibkn031c\n8DKDS7pR9UK7ZYdR6zFg3ZCjQw==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICrjCCAjOgAwIBAgIQJvkWUcYLbnxtuwnyjMmntDAKBggqhkjOPQQDAzCBljEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMS8wLQYDVQQDDCZBbWF6\nb24gUkRTIGV1LXdlc3QtMyBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTAgFw0yMTA1MjUyMjI2MTJaGA8yMTIxMDUyNTIzMjYxMlowgZYxCzAJBgNV\nBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYD\nVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1hem9uIFJE\nUyBldS13ZXN0LTMgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0bGUw\ndjAQBgcqhkjOPQIBBgUrgQQAIgNiAARENn8uHCyjn1dFax4OeXxvbV861qsXFD9G\nDshumTmFzWWHN/69WN/AOsxy9XN5S7Cgad4gQgeYYYgZ5taw+tFo/jQvCLY//uR5\nuihcLuLJ78opvRPvD9kbWZ6oXfBtFkWjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYD\nVR0OBBYEFKiK3LpoF+gDnqPldGSwChBPCYciMA4GA1UdDwEB/wQEAwIBhjAKBggq\nhkjOPQQDAwNpADBmAjEA+7qfvRlnvF1Aosyp9HzxxCbN7VKu+QXXPhLEBWa5oeWW\nUOcifunf/IVLC4/FGCsLAjEAte1AYp+iJyOHDB8UYkhBE/1sxnFaTiEPbvQBU0wZ\nSuwWVLhu2wWDuSW+K7tTuL8p\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIID/zCCAuegAwIBAgIRAKeDpqX5WFCGNo94M4v69sUwDQYJKoZIhvcNAQELBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyBldS13ZXN0LTMgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyNTIyMTgzM1oYDzIwNjEwNTI1MjMxODMzWjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGV1LXdlc3QtMyBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCcKOTEMTfzvs4H\nWtJR8gI7GXN6xesulWtZPv21oT+fLGwJ+9Bv8ADCGDDrDxfeH/HxJmzG9hgVAzVn\n4g97Bn7q07tGZM5pVi96/aNp11velZT7spOJKfJDZTlGns6DPdHmx48whpdO+dOb\n6+eR0VwCIv+Vl1fWXgoACXYCoKjhxJs+R+fwY//0JJ1YG8yjZ+ghLCJmvlkOJmE1\nTCPUyIENaEONd6T+FHGLVYRRxC2cPO65Jc4yQjsXvvQypoGgx7FwD5voNJnFMdyY\n754JGPOOe/SZdepN7Tz7UEq8kn7NQSbhmCsgA/Hkjkchz96qN/YJ+H/okiQUTNB0\neG9ogiVFAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFFjayw9Y\nMjbxfF14XAhMM2VPl0PfMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\nAQEAAtmx6d9+9CWlMoU0JCirtp4dSS41bBfb9Oor6GQ8WIr2LdfZLL6uES/ubJPE\n1Sh5Vu/Zon5/MbqLMVrfniv3UpQIof37jKXsjZJFE1JVD/qQfRzG8AlBkYgHNEiS\nVtD4lFxERmaCkY1tjKB4Dbd5hfhdrDy29618ZjbSP7NwAfnwb96jobCmMKgxVGiH\nUqsLSiEBZ33b2hI7PJ6iTJnYBWGuiDnsWzKRmheA4nxwbmcQSfjbrNwa93w3caL2\nv/4u54Kcasvcu3yFsUwJygt8z43jsGAemNZsS7GWESxVVlW93MJRn6M+MMakkl9L\ntWaXdHZ+KUV7LhfYLb0ajvb40w==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEBDCCAuygAwIBAgIQJ5oxPEjefCsaESSwrxk68DANBgkqhkiG9w0BAQsFADCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIGV1LWNlbnRyYWwtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\nBAcMB1NlYXR0bGUwIBcNMjIwNjA2MjExNzA1WhgPMjA2MjA2MDYyMjE3MDVaMIGa\nMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\nLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\nYXpvbiBSRFMgZXUtY2VudHJhbC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALTQt5eX\ng+VP3BjO9VBkWJhE0GfLrU/QIk32I6WvrnejayTrlup9H1z4QWlXF7GNJrqScRMY\nKhJHlcP05aPsx1lYco6pdFOf42ybXyWHHJdShj4A5glU81GTT+VrXGzHSarLmtua\neozkQgPpDsSlPt0RefyTyel7r3Cq+5K/4vyjCTcIqbfgaGwTU36ffjM1LaPCuE4O\nnINMeD6YuImt2hU/mFl20FZ+IZQUIFZZU7pxGLqTRz/PWcH8tDDxnkYg7tNuXOeN\nJbTpXrw7St50/E9ZQ0llGS+MxJD8jGRAa/oL4G/cwnV8P2OEPVVkgN9xDDQeieo0\n3xkzolkDkmeKOnUCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU\nbwu8635iQGQMRanekesORM8Hkm4wDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEB\nCwUAA4IBAQAgN6LE9mUgjsj6xGCX1afYE69fnmCjjb0rC6eEe1mb/QZNcyw4XBIW\n6+zTXo4mjZ4ffoxb//R0/+vdTE7IvaLgfAZgFsLKJCtYDDstXZj8ujQnGR9Pig3R\nW+LpNacvOOSJSawNQq0Xrlcu55AU4buyD5VjcICnfF1dqBMnGTnh27m/scd/ZMx/\nkapHZ/fMoK2mAgSX/NvUKF3UkhT85vSSM2BTtET33DzCPDQTZQYxFBa4rFRmFi4c\nBLlmIReiCGyh3eJhuUUuYAbK6wLaRyPsyEcIOLMQmZe1+gAFm1+1/q5Ke9ugBmjf\nPbTWjsi/lfZ5CdVAhc5lmZj/l5aKqwaS\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICrjCCAjSgAwIBAgIRAKKPTYKln9L4NTx9dpZGUjowCgYIKoZIzj0EAwMwgZYx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\nem9uIFJEUyBldS13ZXN0LTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTIxMjI1NTIxWhgPMjEyMTA1MjEyMzU1MjFaMIGWMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\nRFMgZXUtd2VzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\nMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE/owTReDvaRqdmbtTzXbyRmEpKCETNj6O\nhZMKH0F8oU9Tmn8RU7kQQj6xUKEyjLPrFBN7c+26TvrVO1KmJAvbc8bVliiJZMbc\nC0yV5PtJTalvlMZA1NnciZuhxaxrzlK1o0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\nA1UdDgQWBBT4i5HaoHtrs7Mi8auLhMbKM1XevDAOBgNVHQ8BAf8EBAMCAYYwCgYI\nKoZIzj0EAwMDaAAwZQIxAK9A+8/lFdX4XJKgfP+ZLy5ySXC2E0Spoy12Gv2GdUEZ\np1G7c1KbWVlyb1d6subzkQIwKyH0Naf/3usWfftkmq8SzagicKz5cGcEUaULq4tO\nGzA/AMpr63IDBAqkZbMDTCmH\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICrzCCAjWgAwIBAgIQTgIvwTDuNWQo0Oe1sOPQEzAKBggqhkjOPQQDAzCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGV1LW5vcnRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTI0MjEwNjM4WhgPMjEyMTA1MjQyMjA2MzhaMIGXMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\nRFMgZXUtbm9ydGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\nZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABJuzXLU8q6WwSKXBvx8BbdIi3mPhb7Xo\nrNJBfuMW1XRj5BcKH1ZoGaDGw+BIIwyBJg8qNmCK8kqIb4cH8/Hbo3Y+xBJyoXq/\ncuk8aPrxiNoRsKWwiDHCsVxaK9L7GhHHAqNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\nBgNVHQ4EFgQUYgcsdU4fm5xtuqLNppkfTHM2QMYwDgYDVR0PAQH/BAQDAgGGMAoG\nCCqGSM49BAMDA2gAMGUCMQDz/Rm89+QJOWJecYAmYcBWCcETASyoK1kbr4vw7Hsg\n7Ew3LpLeq4IRmTyuiTMl0gMCMAa0QSjfAnxBKGhAnYxcNJSntUyyMpaXzur43ec0\n3D8npJghwC4DuICtKEkQiI5cSg==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGATCCA+mgAwIBAgIRAORIGqQXLTcbbYT2upIsSnQwDQYJKoZIhvcNAQEMBQAw\ngZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\nQW1hem9uIFJEUyBldS1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMjA1MjMxODM0MjJaGA8yMTIyMDUyMzE5MzQyMlowgZgx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\nem9uIFJEUyBldS1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAPKukwsW2s/h\n1k+Hf65pOP0knVBnOnMQyT1mopp2XHGdXznj9xS49S30jYoUnWccyXgD983A1bzu\nw4fuJRHg4MFdz/NWTgXvy+zy0Roe83OPIJjUmXnnzwUHQcBa9vl6XUO65iQ3pbSi\nfQfNDFXD8cvuXbkezeADoy+iFAlzhXTzV9MD44GTuo9Z3qAXNGHQCrgRSCL7uRYt\nt1nfwboCbsVRnElopn2cTigyVXE62HzBUmAw1GTbAZeFAqCn5giBWYAfHwTUldRL\n6eEa6atfsS2oPNus4ZENa1iQxXq7ft+pMdNt0qKXTCZiiCZjmLkY0V9kWwHTRRF8\nr+75oSL//3di43QnuSCgjwMRIeWNtMud5jf3eQzSBci+9njb6DrrSUbx7blP0srg\n94/C/fYOp/0/EHH34w99Th14VVuGWgDgKahT9/COychLOubXUT6vD1As47S9KxTv\nyYleVKwJnF9cVjepODN72fNlEf74BwzgSIhUmhksmZSeJBabrjSUj3pdyo/iRZN/\nCiYz9YPQ29eXHPQjBZVIUqWbOVfdwsx0/Xu5T1e7yyXByQ3/oDulahtcoKPAFQ3J\nee6NJK655MdS7pM9hJnU2Rzu3qZ/GkM6YK7xTlMXVouPUZov/VbiaCKbqYDs8Dg+\nUKdeNXAT6+BMleGQzly1X7vjhgeA8ugVAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wHQYDVR0OBBYEFJdaPwpCf78UolFTEn6GO85/QwUIMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQwFAAOCAgEAWkxHIT3mers5YnZRSVjmpxCLivGj1jMB9VYC\niKqTAeIvD0940L0YaZgivQll5pue8UUcQ6M2uCdVVAsNJdmQ5XHIYiGOknYPtxzO\naO+bnZp7VIZw/vJ49hvH6RreA2bbxYMZO/ossYdcWsWbOKHFrRmAw0AhtK/my51g\nobV7eQg+WmlE5Iqc75ycUsoZdc3NimkjBi7LQoNP1HMvlLHlF71UZhQDdq+/WdV7\n0zmg+epkki1LjgMmuPyb+xWuYkFKT1/faX+Xs62hIm5BY+aI4if4RuQ+J//0pOSs\nUajrjTo+jLGB8A96jAe8HaFQenbwMjlaHRDAF0wvbkYrMr5a6EbneAB37V05QD0Y\nRh4L4RrSs9DX2hbSmS6iLDuPEjanHKzglF5ePEvnItbRvGGkynqDVlwF+Bqfnw8l\n0i8Hr1f1/LP1c075UjkvsHlUnGgPbLqA0rDdcxF8Fdlv1BunUjX0pVlz10Ha5M6P\nAdyWUOneOfaA5G7jjv7i9qg3r99JNs1/Lmyg/tV++gnWTAsSPFSSEte81kmPhlK3\n2UtAO47nOdTtk+q4VIRAwY1MaOR7wTFZPfer1mWs4RhKNu/odp8urEY87iIzbMWT\nQYO/4I6BGj9rEWNGncvR5XTowwIthMCj2KWKM3Z/JxvjVFylSf+s+FFfO1bNIm6h\nu3UBpZI=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICtDCCAjmgAwIBAgIQenQbcP/Zbj9JxvZ+jXbRnTAKBggqhkjOPQQDAzCBmTEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTIwMAYDVQQDDClBbWF6\nb24gUkRTIGV1LWNlbnRyYWwtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTAgFw0yMTA1MjEyMjMzMjRaGA8yMTIxMDUyMTIzMzMyNFowgZkxCzAJ\nBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMw\nEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1hem9u\nIFJEUyBldS1jZW50cmFsLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAATlBHiEM9LoEb1Hdnd5j2VpCDOU\n5nGuFoBD8ROUCkFLFh5mHrHfPXwBc63heW9WrP3qnDEm+UZEUvW7ROvtWCTPZdLz\nZ4XaqgAlSqeE2VfUyZOZzBSgUUJk7OlznXfkCMOjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wHQYDVR0OBBYEFDT/ThjQZl42Nv/4Z/7JYaPNMly2MA4GA1UdDwEB/wQEAwIB\nhjAKBggqhkjOPQQDAwNpADBmAjEAnZWmSgpEbmq+oiCa13l5aGmxSlfp9h12Orvw\nDq/W5cENJz891QD0ufOsic5oGq1JAjEAp5kSJj0MxJBTHQze1Aa9gG4sjHBxXn98\n4MP1VGsQuhfndNHQb4V0Au7OWnOeiobq\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIID/zCCAuegAwIBAgIRAMgnyikWz46xY6yRgiYwZ3swDQYJKoZIhvcNAQELBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyBldS13ZXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyMDE2NDkxMloYDzIwNjEwNTIwMTc0OTEyWjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGV1LXdlc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCi8JYOc9cYSgZH\ngYPxLk6Xcc7HqzamvsnjYU98Dcb98y6iDqS46Ra2Ne02MITtU5MDL+qjxb8WGDZV\nRUA9ZS69tkTO3gldW8QdiSh3J6hVNJQW81F0M7ZWgV0gB3n76WCmfT4IWos0AXHM\n5v7M/M4tqVmCPViQnZb2kdVlM3/Xc9GInfSMCgNfwHPTXl+PXX+xCdNBePaP/A5C\n5S0oK3HiXaKGQAy3K7VnaQaYdiv32XUatlM4K2WS4AMKt+2cw3hTCjlmqKRHvYFQ\nveWCXAuc+U5PQDJ9SuxB1buFJZhT4VP3JagOuZbh5NWpIbOTxlAJOb5pGEDuJTKi\n1gQQQVEFAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFNXm+N87\nOFxK9Af/bjSxDCiulGUzMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\nAQEAkqIbkgZ45spvrgRQ6n9VKzDLvNg+WciLtmVrqyohwwJbj4pYvWwnKQCkVc7c\nhUOSBmlSBa5REAPbH5o8bdt00FPRrD6BdXLXhaECKgjsHe1WW08nsequRKD8xVmc\n8bEX6sw/utBeBV3mB+3Zv7ejYAbDFM4vnRsWtO+XqgReOgrl+cwdA6SNQT9oW3e5\nrSQ+VaXgJtl9NhkiIysq9BeYigxqS/A13pHQp0COMwS8nz+kBPHhJTsajHCDc8F4\nHfLi6cgs9G0gaRhT8FCH66OdGSqn196sE7Y3bPFFFs/3U+vxvmQgoZC6jegQXAg5\nPrxd+VNXtNI/azitTysQPumH7A==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEBTCCAu2gAwIBAgIRAO8bekN7rUReuNPG8pSTKtEwDQYJKoZIhvcNAQELBQAw\ngZoxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEzMDEGA1UEAwwq\nQW1hem9uIFJEUyBldS1jZW50cmFsLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYD\nVQQHDAdTZWF0dGxlMCAXDTIxMDUyMTIyMjM0N1oYDzIwNjEwNTIxMjMyMzQ3WjCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIGV1LWNlbnRyYWwtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\nBAcMB1NlYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCTTYds\nTray+Q9VA5j5jTh5TunHKFQzn68ZbOzdqaoi/Rq4ohfC0xdLrxCpfqn2TGDHN6Zi\n2qGK1tWJZEd1H0trhzd9d1CtGK+3cjabUmz/TjSW/qBar7e9MA67/iJ74Gc+Ww43\nA0xPNIWcL4aLrHaLm7sHgAO2UCKsrBUpxErOAACERScVYwPAfu79xeFcX7DmcX+e\nlIqY16pQAvK2RIzrekSYfLFxwFq2hnlgKHaVgZ3keKP+nmXcXmRSHQYUUr72oYNZ\nHcNYl2+gxCc9ccPEHM7xncVEKmb5cWEWvVoaysgQ+osi5f5aQdzgC2X2g2daKbyA\nXL/z5FM9GHpS5BJjAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE\nFBDAiJ7Py9/A9etNa/ebOnx5l5MGMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0B\nAQsFAAOCAQEALMh/+81fFPdJV/RrJUeoUvFCGMp8iaANu97NpeJyKitNOv7RoeVP\nWjivS0KcCqZaDBs+p6IZ0sLI5ZH098LDzzytcfZg0PsGqUAb8a0MiU/LfgDCI9Ee\njsOiwaFB8k0tfUJK32NPcIoQYApTMT2e26lPzYORSkfuntme2PTHUnuC7ikiQrZk\nP+SZjWgRuMcp09JfRXyAYWIuix4Gy0eZ4rpRuaTK6mjAb1/LYoNK/iZ/gTeIqrNt\nl70OWRsWW8jEmSyNTIubGK/gGGyfuZGSyqoRX6OKHESkP6SSulbIZHyJ5VZkgtXo\n2XvyRyJ7w5pFyoofrL3Wv0UF8yt/GDszmg==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIF/zCCA+egAwIBAgIRAMDk/F+rrhdn42SfE+ghPC8wDQYJKoZIhvcNAQEMBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyBldS13ZXN0LTIgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyMTIyNTEyMloYDzIxMjEwNTIxMjM1MTIyWjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGV1LXdlc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC2twMALVg9vRVu\nVNqsr6N8thmp3Dy8jEGTsm3GCQ+C5P2YcGlD/T/5icfWW84uF7Sx3ezcGlvsqFMf\nUkj9sQyqtz7qfFFugyy7pa/eH9f48kWFHLbQYm9GEgbYBIrWMp1cy3vyxuMCwQN4\nDCncqU+yNpy0CprQJEha3PzY+3yJOjDQtc3zr99lyECCFJTDUucxHzyQvX89eL74\nuh8la0lKH3v9wPpnEoftbrwmm5jHNFdzj7uXUHUJ41N7af7z7QUfghIRhlBDiKtx\n5lYZemPCXajTc3ryDKUZC/b+B6ViXZmAeMdmQoPE0jwyEp/uaUcdp+FlUQwCfsBk\nayPFEApTWgPiku2isjdeTVmEgL8bJTDUZ6FYFR7ZHcYAsDzcwHgIu3GGEMVRS3Uf\nILmioiyly9vcK4Sa01ondARmsi/I0s7pWpKflaekyv5boJKD/xqwz9lGejmJHelf\n8Od2TyqJScMpB7Q8c2ROxBwqwB72jMCEvYigB+Wnbb8RipliqNflIGx938FRCzKL\nUQUBmNAznR/yRRL0wHf9UAE/8v9a09uZABeiznzOFAl/frHpgdAbC00LkFlnwwgX\ng8YfEFlkp4fLx5B7LtoO6uVNFVimLxtwirpyKoj3G4M/kvSTux8bTw0heBCmWmKR\n57MS6k7ODzbv+Kpeht2hqVZCNFMxoQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\nMB0GA1UdDgQWBBRuMnDhJjoj7DcKALj+HbxEqj3r6jAOBgNVHQ8BAf8EBAMCAYYw\nDQYJKoZIhvcNAQEMBQADggIBALSnXfx72C3ldhBP5kY4Mo2DDaGQ8FGpTOOiD95d\n0rf7I9LrsBGVqu/Nir+kqqP80PB70+Jy9fHFFigXwcPBX3MpKGxK8Cel7kVf8t1B\n4YD6A6bqlzP+OUL0uGWfZpdpDxwMDI2Flt4NEldHgXWPjvN1VblEKs0+kPnKowyg\njhRMgBbD/y+8yg0fIcjXUDTAw/+INcp21gWaMukKQr/8HswqC1yoqW9in2ijQkpK\n2RB9vcQ0/gXR0oJUbZQx0jn0OH8Agt7yfMAnJAdnHO4M3gjvlJLzIC5/4aGrRXZl\nJoZKfJ2fZRnrFMi0nhAYDeInoS+Rwx+QzaBk6fX5VPyCj8foZ0nmqvuYoydzD8W5\nmMlycgxFqS+DUmO+liWllQC4/MnVBlHGB1Cu3wTj5kgOvNs/k+FW3GXGzD3+rpv0\nQTLuwSbMr+MbEThxrSZRSXTCQzKfehyC+WZejgLb+8ylLJUA10e62o7H9PvCrwj+\nZDVmN7qj6amzvndCP98sZfX7CFZPLfcBd4wVIjHsFjSNEwWHOiFyLPPG7cdolGKA\nlOFvonvo4A1uRc13/zFeP0Xi5n5OZ2go8aOOeGYdI2vB2sgH9R2IASH/jHmr0gvY\n0dfBCcfXNgrS0toq0LX/y+5KkKOxh52vEYsJLdhqrveuZhQnsFEm/mFwjRXkyO7c\n2jpC\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGADCCA+igAwIBAgIQYe0HgSuFFP9ivYM2vONTrTANBgkqhkiG9w0BAQwFADCB\nmDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\nbWF6b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUxOTE4MzMyMVoYDzIxMjEwNTE5MTkzMzIxWjCBmDEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\nb24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAuO7QPKfPMTo2\nPOQWvzDLwi5f++X98hGjORI1zkN9kotCYH5pAzSBwBPoMNaIfedgmsIxGHj2fq5G\n4oXagNhNuGP79Zl6uKW5H7S74W7aWM8C0s8zuxMOI4GZy5h2IfQk3m/3AzZEX5w8\nUtNPkzo2feDVOkerHT+j+vjXgAxZ4wHnuMDcRT+K4r9EXlAH6X9b/RO0JlfEwmNz\nxlqqGxocq9qRC66N6W0HF2fNEAKP84n8H80xcZBOBthQORRi8HSmKcPdmrvwCuPz\nM+L+j18q6RAVaA0ABbD0jMWcTf0UvjUfBStn5mvu/wGlLjmmRkZsppUTRukfwqXK\nyltUsTq0tOIgCIpne5zA4v+MebbR5JBnsvd4gdh5BI01QH470yB7BkUefZ9bobOm\nOseAAVXcYFJKe4DAA6uLDrqOfFSxV+CzVvEp3IhLRaik4G5MwI/h2c/jEYDqkg2J\nHMflxc2gcSMdk7E5ByLz5f6QrFfSDFk02ZJTs4ssbbUEYohht9znPMQEaWVqATWE\n3n0VspqZyoBNkH/agE5GiGZ/k/QyeqzMNj+c9kr43Upu8DpLrz8v2uAp5xNj3YVg\nihaeD6GW8+PQoEjZ3mrCmH7uGLmHxh7Am59LfEyNrDn+8Rq95WvkmbyHSVxZnBmo\nh/6O3Jk+0/QhIXZ2hryMflPcYWeRGH0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB\n/zAdBgNVHQ4EFgQU2eFK7+R3x/me8roIBNxBrplkM6EwDgYDVR0PAQH/BAQDAgGG\nMA0GCSqGSIb3DQEBDAUAA4ICAQB5gWFe5s7ObQFj1fTO9L6gYgtFhnwdmxU0q8Ke\nHWCrdFmyXdC39qdAFOwM5/7fa9zKmiMrZvy9HNvCXEp4Z7z9mHhBmuqPZQx0qPgU\nuLdP8wGRuWryzp3g2oqkX9t31Z0JnkbIdp7kfRT6ME4I4VQsaY5Y3mh+hIHOUvcy\np+98i3UuEIcwJnVAV9wTTzrWusZl9iaQ1nSYbmkX9bBssJ2GmtW+T+VS/1hJ/Q4f\nAlE3dOQkLFoPPb3YRWBHr2n1LPIqMVwDNAuWavRA2dSfaLl+kzbn/dua7HTQU5D4\nb2Fu2vLhGirwRJe+V7zdef+tI7sngXqjgObyOeG5O2BY3s+um6D4fS0Th3QchMO7\n0+GwcIgSgcjIjlrt6/xJwJLE8cRkUUieYKq1C4McpZWTF30WnzOPUzRzLHkcNzNA\n0A7sKMK6QoYWo5Rmo8zewUxUqzc9oQSrYADP7PEwGncLtFe+dlRFx+PA1a+lcIgo\n1ZGfXigYtQ3VKkcknyYlJ+hN4eCMBHtD81xDy9iP2MLE41JhLnoB2rVEtewO5diF\n7o95Mwl84VMkLhhHPeGKSKzEbBtYYBifHNct+Bst8dru8UumTltgfX6urH3DN+/8\nJF+5h3U8oR2LL5y76cyeb+GWDXXy9zoQe2QvTyTy88LwZq1JzujYi2k8QiLLhFIf\nFEv9Bg==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICsDCCAjagAwIBAgIRAMgApnfGYPpK/fD0dbN2U4YwCgYIKoZIzj0EAwMwgZcx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwnQW1h\nem9uIFJEUyBldS1zb3V0aC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMCAXDTIxMDUxOTE4MzgxMVoYDzIxMjEwNTE5MTkzODExWjCBlzELMAkG\nA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzAR\nBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6b24g\nUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0\nbGUwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQfEWl6d4qSuIoECdZPp+39LaKsfsX7\nTHs3/RrtT0+h/jl3bjZ7Qc68k16x+HGcHbaayHfqD0LPdzH/kKtNSfQKqemdxDQh\nZ4pwkixJu8T1VpXZ5zzCvBXCl75UqgEFS92jQjBAMA8GA1UdEwEB/wQFMAMBAf8w\nHQYDVR0OBBYEFFPrSNtWS5JU+Tvi6ABV231XbjbEMA4GA1UdDwEB/wQEAwIBhjAK\nBggqhkjOPQQDAwNoADBlAjEA+a7hF1IrNkBd2N/l7IQYAQw8chnRZDzh4wiGsZsC\n6A83maaKFWUKIb3qZYXFSi02AjAbp3wxH3myAmF8WekDHhKcC2zDvyOiKLkg9Y6v\nZVmyMR043dscQbcsVoacOYv198c=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICtDCCAjqgAwIBAgIRAPhVkIsQ51JFhD2kjFK5uAkwCgYIKoZIzj0EAwMwgZkx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1h\nem9uIFJEUyBldS1jZW50cmFsLTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjIwNjA2MjEyOTE3WhgPMjEyMjA2MDYyMjI5MTdaMIGZMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMjAwBgNVBAMMKUFtYXpv\nbiBSRFMgZXUtY2VudHJhbC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEA5xnIEBtG5b2nmbj49UEwQza\nyX0844fXjccYzZ8xCDUe9dS2XOUi0aZlGblgSe/3lwjg8fMcKXLObGGQfgIx1+5h\nAIBjORis/dlyN5q/yH4U5sjS8tcR0GDGVHrsRUZCo0IwQDAPBgNVHRMBAf8EBTAD\nAQH/MB0GA1UdDgQWBBRK+lSGutXf4DkTjR3WNfv4+KeNFTAOBgNVHQ8BAf8EBAMC\nAYYwCgYIKoZIzj0EAwMDaAAwZQIxAJ4NxQ1Gerqr70ZrnUqc62Vl8NNqTzInamCG\nKce3FTsMWbS9qkgrjZkO9QqOcGIw/gIwSLrwUT+PKr9+H9eHyGvpq9/3AIYSnFkb\nCf3dyWPiLKoAtLFwjzB/CkJlsAS1c8dS\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIF/jCCA+agAwIBAgIQGZH12Q7x41qIh9vDu9ikTjANBgkqhkiG9w0BAQwFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIGV1LXdlc3QtMyBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTI1MjIyMjMzWhgPMjEyMTA1MjUyMzIyMzNaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgZXUtd2VzdC0zIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMqE47sHXWzdpuqj\nJHb+6jM9tDbQLDFnYjDWpq4VpLPZhb7xPNh9gnYYTPKG4avG421EblAHqzy9D2pN\n1z90yKbIfUb/Sy2MhQbmZomsObhONEra06fJ0Dydyjswf1iYRp2kwpx5AgkVoNo7\n3dlws73zFjD7ImKvUx2C7B75bhnw2pJWkFnGcswl8fZt9B5Yt95sFOKEz2MSJE91\nkZlHtya19OUxZ/cSGci4MlOySzqzbGwUqGxEIDlY8I39VMwXaYQ8uXUN4G780VcL\nu46FeyRGxZGz2n3hMc805WAA1V5uir87vuirTvoSVREET97HVRGVVNJJ/FM6GXr1\nVKtptybbo81nefYJg9KBysxAa2Ao2x2ry/2ZxwhS6VZ6v1+90bpZA1BIYFEDXXn/\ndW07HSCFnYSlgPtSc+Muh15mdr94LspYeDqNIierK9i4tB6ep7llJAnq0BU91fM2\nJPeqyoTtc3m06QhLf68ccSxO4l8Hmq9kLSHO7UXgtdjfRVaffngopTNk8qK7bIb7\nLrgkqhiQw/PRCZjUdyXL153/fUcsj9nFNe25gM4vcFYwH6c5trd2tUl31NTi1MfG\nMgp3d2dqxQBIYANkEjtBDMy3SqQLIo9EymqmVP8xx2A/gCBgaxvMAsI6FSWRoC7+\nhqJ8XH4mFnXSHKtYMe6WPY+/XZgtAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\nHQYDVR0OBBYEFIkXqTnllT/VJnI2NqipA4XV8rh1MA4GA1UdDwEB/wQEAwIBhjAN\nBgkqhkiG9w0BAQwFAAOCAgEAKjSle8eenGeHgT8pltWCw/HzWyQruVKhfYIBfKJd\nMhV4EnH5BK7LxBIvpXGsFUrb0ThzSw0fn0zoA9jBs3i/Sj6KyeZ9qUF6b8ycDXd+\nwHonmJiQ7nk7UuMefaYAfs06vosgl1rI7eBHC0itexIQmKh0aX+821l4GEgEoSMf\nloMFTLXv2w36fPHHCsZ67ODldgcZbKNnpCTX0YrCwEYO3Pz/L398btiRcWGrewrK\njdxAAyietra8DRno1Zl87685tfqc6HsL9v8rVw58clAo9XAQvT+fmSOFw/PogRZ7\nOMHUat3gu/uQ1M5S64nkLLFsKu7jzudBuoNmcJysPlzIbqJ7vYc82OUGe9ucF3wi\n3tbKQ983hdJiTExVRBLX/fYjPsGbG3JtPTv89eg2tjWHlPhCDMMxyRKl6isu2RTq\n6VT489Z2zQrC33MYF8ZqO1NKjtyMAMIZwxVu4cGLkVsqFmEV2ScDHa5RadDyD3Ok\nm+mqybhvEVm5tPgY6p0ILPMN3yvJsMSPSvuBXhO/X5ppNnpw9gnxpwbjQKNhkFaG\nM5pkADZ14uRguOLM4VthSwUSEAr5VQYCFZhEwK+UOyJAGiB/nJz6IxL5XBNUXmRM\nHl8Xvz4riq48LMQbjcVQj0XvH941yPh+P8xOi00SGaQRaWp55Vyr4YKGbV0mEDz1\nr1o=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIF/zCCA+egAwIBAgIRAKwYju1QWxUZpn6D1gOtwgQwDQYJKoZIhvcNAQEMBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyBldS13ZXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyMDE2NTM1NFoYDzIxMjEwNTIwMTc1MzU0WjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGV1LXdlc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCKdBP1U4lqWWkc\nCb25/BKRTsvNVnISiKocva8GAzJyKfcGRa85gmgu41U+Hz6+39K+XkRfM0YS4BvQ\nF1XxWT0bNyypuvwCvmYShSTjN1TY0ltncDddahTajE/4MdSOZb/c98u0yt03cH+G\nhVwRyT50h0v/UEol50VfwcVAEZEgcQQYhf1IFUFlIvKpmDOqLuFakOnc7c9akK+i\nivST+JO1tgowbnNkn2iLlSSgUWgb1gjaOsNfysagv1RXdlyPw3EyfwkFifAQvF2P\nQ0ayYZfYS640cccv7efM1MSVyFHR9PrrDsF/zr2S2sGPbeHr7R/HwLl+S5J/l9N9\ny0rk6IHAWV4dEkOvgpnuJKURwA48iu1Hhi9e4moNS6eqoK2KmY3VFpuiyWcA73nH\nGSmyaH+YuMrF7Fnuu7GEHZL/o6+F5cL3mj2SJJhL7sz0ryf5Cs5R4yN9BIEj/f49\nwh84pM6nexoI0Q4wiSFCxWiBpjSmOK6h7z6+2utaB5p20XDZHhxAlmlx4vMuWtjh\nXckgRFxc+ZpVMU3cAHUpVEoO49e/+qKEpPzp8Xg4cToKw2+AfTk3cmyyXQfGwXMQ\nZUHNZ3w9ILMWihGCM2aGUsLcGDRennvNmnmin/SENsOQ8Ku0/a3teEzwV9cmmdYz\n5iYs1YtgPvKFobY6+T2RXXh+A5kprwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\nMB0GA1UdDgQWBBSyUrsQVnKmA8z6/2Ech0rCvqpNmTAOBgNVHQ8BAf8EBAMCAYYw\nDQYJKoZIhvcNAQEMBQADggIBAFlj3IFmgiFz5lvTzFTRizhVofhTJsGr14Yfkuc7\nUrXPuXOwJomd4uot2d/VIeGJpfnuS84qGdmQyGewGTJ9inatHsGZgHl9NHNWRwKZ\nlTKTbBiq7aqgtUSFa06v202wpzU+1kadxJJePrbABxiXVfOmIW/a1a4hPNcT3syH\nFIEg1+CGsp71UNjBuwg3JTKWna0sLSKcxLOSOvX1fzxK5djzVpEsvQMB4PSAzXca\nvENgg2ErTwgTA+4s6rRtiBF9pAusN1QVuBahYP3ftrY6f3ycS4K65GnqscyfvKt5\nYgjtEKO3ZeeX8NpubMbzC+0Z6tVKfPFk/9TXuJtwvVeqow0YMrLLyRiYvK7EzJ97\nrrkxoKnHYQSZ+rH2tZ5SE392/rfk1PJL0cdHnkpDkUDO+8cKsFjjYKAQSNC52sKX\n74AVh6wMwxYwVZZJf2/2XxkjMWWhKNejsZhUkTISSmiLs+qPe3L67IM7GyKm9/m6\nR3r8x6NGjhTsKH64iYJg7AeKeax4b2e4hBb6GXFftyOs7unpEOIVkJJgM6gh3mwn\nR7v4gwFbLKADKt1vHuerSZMiTuNTGhSfCeDM53XI/mjZl2HeuCKP1mCDLlaO+gZR\nQ/G+E0sBKgEX4xTkAc3kgkuQGfExdGtnN2U2ehF80lBHB8+2y2E+xWWXih/ZyIcW\nwOx+\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGBDCCA+ygAwIBAgIQM4C8g5iFRucSWdC8EdqHeDANBgkqhkiG9w0BAQwFADCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIGV1LWNlbnRyYWwtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\nBAcMB1NlYXR0bGUwIBcNMjEwNTIxMjIyODI2WhgPMjEyMTA1MjEyMzI4MjZaMIGa\nMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\nLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\nYXpvbiBSRFMgZXUtY2VudHJhbC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANeTsD/u\n6saPiY4Sg0GlJlMXMBltnrcGAEkwq34OKQ0bCXqcoNJ2rcAMmuFC5x9Ho1Y3YzB7\nNO2GpIh6bZaO76GzSv4cnimcv9n/sQSYXsGbPD+bAtnN/RvNW1avt4C0q0/ghgF1\nVFS8JihIrgPYIArAmDtGNEdl5PUrdi9y6QGggbRfidMDdxlRdZBe1C18ZdgERSEv\nUgSTPRlVczONG5qcQkUGCH83MMqL5MKQiby/Br5ZyPq6rxQMwRnQ7tROuElzyYzL\n7d6kke+PNzG1mYy4cbYdjebwANCtZ2qYRSUHAQsOgybRcSoarv2xqcjO9cEsDiRU\nl97ToadGYa4VVERuTaNZxQwrld4mvzpyKuirqZltOqg0eoy8VUsaRPL3dc5aChR0\ndSrBgRYmSAClcR2/2ZCWpXemikwgt031Dsc0A/+TmVurrsqszwbr0e5xqMow9LzO\nMI/JtLd0VFtoOkL/7GG2tN8a+7gnLFxpv+AQ0DH5n4k/BY/IyS+H1erqSJhOTQ11\nvDOFTM5YplB9hWV9fp5PRs54ILlHTlZLpWGs3I2BrJwzRtg/rOlvsosqcge9ryai\nAKm2j+JBg5wJ19R8oxRy8cfrNTftZePpISaLTyV2B16w/GsSjqixjTQe9LRN2DHk\ncC+HPqYyzW2a3pUVyTGHhW6a7YsPBs9yzt6hAgMBAAGjQjBAMA8GA1UdEwEB/wQF\nMAMBAf8wHQYDVR0OBBYEFIqA8QkOs2cSirOpCuKuOh9VDfJfMA4GA1UdDwEB/wQE\nAwIBhjANBgkqhkiG9w0BAQwFAAOCAgEAOUI90mEIsa+vNJku0iUwdBMnHiO4gm7E\n5JloP7JG0xUr7d0hypDorMM3zVDAL+aZRHsq8n934Cywj7qEp1304UF6538ByGdz\ntkfacJsUSYfdlNJE9KbA4T+U+7SNhj9jvePpVjdQbhgzxITE9f8CxY/eM40yluJJ\nPhbaWvOiRagzo74wttlcDerzLT6Y/JrVpWhnB7IY8HvzK+BwAdaCsBUPC3HF+kth\nCIqLq7J3YArTToejWZAp5OOI6DLPM1MEudyoejL02w0jq0CChmZ5i55ElEMnapRX\n7GQTARHmjgAOqa95FjbHEZzRPqZ72AtZAWKFcYFNk+grXSeWiDgPFOsq6mDg8DDB\n0kfbYwKLFFCC9YFmYzR2YrWw2NxAScccUc2chOWAoSNHiqBbHR8ofrlJSWrtmKqd\nYRCXzn8wqXnTS3NNHNccqJ6dN+iMr9NGnytw8zwwSchiev53Fpc1mGrJ7BKTWH0t\nZrA6m32wzpMymtKozlOPYoE5mtZEzrzHEXfa44Rns7XIHxVQSXVWyBHLtIsZOrvW\nU5F41rQaFEpEeUQ7sQvqUoISfTUVRNDn6GK6YaccEhCji14APLFIvhRQUDyYMIiM\n4vll0F/xgVRHTgDVQ8b8sxdhSYlqB4Wc2Ym41YRz+X2yPqk3typEZBpc4P5Tt1/N\n89cEIGdbjsA=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEADCCAuigAwIBAgIQYjbPSg4+RNRD3zNxO1fuKDANBgkqhkiG9w0BAQsFADCB\nmDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\nbWF6b24gUkRTIGV1LW5vcnRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyNDIwNTkyMVoYDzIwNjEwNTI0MjE1OTIxWjCBmDEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\nb24gUkRTIGV1LW5vcnRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA179eQHxcV0YL\nXMkqEmhSBazHhnRVd8yICbMq82PitE3BZcnv1Z5Zs/oOgNmMkOKae4tCXO/41JCX\nwAgbs/eWWi+nnCfpQ/FqbLPg0h3dqzAgeszQyNl9IzTzX4Nd7JFRBVJXPIIKzlRf\n+GmFsAhi3rYgDgO27pz3ciahVSN+CuACIRYnA0K0s9lhYdddmrW/SYeWyoB7jPa2\nLmWpAs7bDOgS4LlP2H3eFepBPgNufRytSQUVA8f58lsE5w25vNiUSnrdlvDrIU5n\nQwzc7NIZCx4qJpRbSKWrUtbyJriWfAkGU7i0IoainHLn0eHp9bWkwb9D+C/tMk1X\nERZw2PDGkwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBSFmR7s\ndAblusFN+xhf1ae0KUqhWTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\nggEBAHsXOpjPMyH9lDhPM61zYdja1ebcMVgfUvsDvt+w0xKMKPhBzYDMs/cFOi1N\nQ8LV79VNNfI2NuvFmGygcvTIR+4h0pqqZ+wjWl3Kk5jVxCrbHg3RBX02QLumKd/i\nkwGcEtTUvTssn3SM8bgM0/1BDXgImZPC567ciLvWDo0s/Fe9dJJC3E0G7d/4s09n\nOMdextcxFuWBZrBm/KK3QF0ByA8MG3//VXaGO9OIeeOJCpWn1G1PjT1UklYhkg61\nEbsTiZVA2DLd1BGzfU4o4M5mo68l0msse/ndR1nEY6IywwpgIFue7+rEleDh6b9d\nPYkG1rHVw2I0XDG4o17aOn5E94I=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEADCCAuigAwIBAgIQC6W4HFghUkkgyQw14a6JljANBgkqhkiG9w0BAQsFADCB\nmDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\nbWF6b24gUkRTIGV1LXNvdXRoLTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIyMDUyMzE4MTYzMloYDzIwNjIwNTIzMTkxNjMyWjCBmDEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\nb24gUkRTIGV1LXNvdXRoLTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAiM/t4FV2R9Nx\nUQG203UY83jInTa/6TMq0SPyg617FqYZxvz2kkx09x3dmxepUg9ttGMlPgjsRZM5\nLCFEi1FWk+hxHzt7vAdhHES5tdjwds3aIkgNEillmRDVrUsbrDwufLaa+MMDO2E1\nwQ/JYFXw16WBCCi2g1EtyQ2Xp+tZDX5IWOTnvhZpW8vVDptZ2AcJ5rMhfOYO3OsK\n5EF0GGA5ldzuezP+BkrBYGJ4wVKGxeaq9+5AT8iVZrypjwRkD7Y5CurywK3+aBwm\ns9Q5Nd8t45JCOUzYp92rFKsCriD86n/JnEvgDfdP6Hvtm0/DkwXK40Wz2q0Zrd0k\nmjP054NRPwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRR7yqd\nSfKcX2Q8GzhcVucReIpewTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\nggEBAEszBRDwXcZyNm07VcFwI1Im94oKwKccuKYeJEsizTBsVon8VpEiMwDs+yGu\n3p8kBhvkLwWybkD/vv6McH7T5b9jDX2DoOudqYnnaYeypsPH/00Vh3LvKagqzQza\norWLx+0tLo8xW4BtU+Wrn3JId8LvAhxyYXTn9bm+EwPcStp8xGLwu53OPD1RXYuy\nuu+3ps/2piP7GVfou7H6PRaqbFHNfiGg6Y+WA0HGHiJzn8uLmrRJ5YRdIOOG9/xi\nqTmAZloUNM7VNuurcMM2hWF494tQpsQ6ysg2qPjbBqzlGoOt3GfBTOZmqmwmqtam\nK7juWM/mdMQAJ3SMlE5wI8nVdx4=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIICrjCCAjSgAwIBAgIRAL9SdzVPcpq7GOpvdGoM80IwCgYIKoZIzj0EAwMwgZYx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\nem9uIFJEUyBldS13ZXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTIwMTY1ODA3WhgPMjEyMTA1MjAxNzU4MDdaMIGWMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\nRFMgZXUtd2VzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\nMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEJWDgXebvwjR+Ce+hxKOLbnsfN5W5dOlP\nZn8kwWnD+SLkU81Eac/BDJsXGrMk6jFD1vg16PEkoSevsuYWlC8xR6FmT6F6pmeh\nfsMGOyJpfK4fyoEPhKeQoT23lFIc5Orjo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\nA1UdDgQWBBSVNAN1CHAz0eZ77qz2adeqjm31TzAOBgNVHQ8BAf8EBAMCAYYwCgYI\nKoZIzj0EAwMDaAAwZQIxAMlQeHbcjor49jqmcJ9gRLWdEWpXG8thIf6zfYQ/OEAg\nd7GDh4fR/OUk0VfjsBUN/gIwZB0bGdXvK38s6AAE/9IT051cz/wMe9GIrX1MnL1T\n1F5OqnXJdiwfZRRTHsRQ/L00\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGBDCCA+ygAwIBAgIQalr16vDfX4Rsr+gfQ4iVFDANBgkqhkiG9w0BAQwFADCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIGV1LWNlbnRyYWwtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\nBAcMB1NlYXR0bGUwIBcNMjIwNjA2MjEyNTIzWhgPMjEyMjA2MDYyMjI1MjNaMIGa\nMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\nLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\nYXpvbiBSRFMgZXUtY2VudHJhbC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANbHbFg7\n2VhZor1YNtez0VlNFaobS3PwOMcEn45BE3y7HONnElIIWXGQa0811M8V2FnyqnE8\nZ5aO1EuvijvWf/3D8DPZkdmAkIfh5hlZYY6Aatr65kEOckwIAm7ZZzrwFogYuaFC\nz/q0CW+8gxNK+98H/zeFx+IxiVoPPPX6UlrLvn+R6XYNERyHMLNgoZbbS5gGHk43\nKhENVv3AWCCcCc85O4rVd+DGb2vMVt6IzXdTQt6Kih28+RGph+WDwYmf+3txTYr8\nxMcCBt1+whyCPlMbC+Yn/ivtCO4LRf0MPZDRQrqTTrFf0h/V0BGEUmMGwuKgmzf5\nKl9ILdWv6S956ioZin2WgAxhcn7+z//sN++zkqLreSf90Vgv+A7xPRqIpTdJ/nWG\nJaAOUofBfsDsk4X4SUFE7xJa1FZAiu2lqB/E+y7jnWOvFRalzxVJ2Y+D/ZfUfrnK\n4pfKtyD1C6ni1celrZrAwLrJ3PoXPSg4aJKh8+CHex477SRsGj8KP19FG8r0P5AG\n8lS1V+enFCNvT5KqEBpDZ/Y5SQAhAYFUX+zH4/n4ql0l/emS+x23kSRrF+yMkB9q\nlhC/fMk6Pi3tICBjrDQ8XAxv56hfud9w6+/ljYB2uQ1iUYtlE3JdIiuE+3ws26O8\ni7PLMD9zQmo+sVi12pLHfBHQ6RRHtdVRXbXRAgMBAAGjQjBAMA8GA1UdEwEB/wQF\nMAMBAf8wHQYDVR0OBBYEFBFot08ipEL9ZUXCG4lagmF53C0/MA4GA1UdDwEB/wQE\nAwIBhjANBgkqhkiG9w0BAQwFAAOCAgEAi2mcZi6cpaeqJ10xzMY0F3L2eOKYnlEQ\nh6QyhmNKCUF05q5u+cok5KtznzqMwy7TFOZtbVHl8uUX+xvgq/MQCxqFAnuStBXm\ngr2dg1h509ZwvTdk7TDxGdftvPCfnPNJBFbMSq4CZtNcOFBg9Rj8c3Yj+Qvwd56V\nzWs65BUkDNJrXmxdvhJZjUkMa9vi/oFN+M84xXeZTaC5YDYNZZeW9706QqDbAVES\n5ulvKLavB8waLI/lhRBK5/k0YykCMl0A8Togt8D1QsQ0eWWbIM8/HYJMPVFhJ8Wj\nvT1p/YVeDA3Bo1iKDOttgC5vILf5Rw1ZEeDxjf/r8A7VS13D3OLjBmc31zxRTs3n\nXvHKP9MieQHn9GE44tEYPjK3/yC6BDFzCBlvccYHmqGb+jvDEXEBXKzimdC9mcDl\nf4BBQWGJBH5jkbU9p6iti19L/zHhz7qU6UJWbxY40w92L9jS9Utljh4A0LCTjlnR\nNQUgjnGC6K+jkw8hj0LTC5Ip87oqoT9w7Av5EJ3VJ4hcnmNMXJJ1DkWYdnytcGpO\nDMVITQzzDZRwhbitCVPHagTN2wdi9TEuYE33J0VmFeTc6FSI50wP2aOAZ0Q1/8Aj\nbxeM5jS25eaHc2CQAuhrc/7GLnxOcPwdWQb2XWT8eHudhMnoRikVv/KSK3mf6om4\n1YfpdH2jp30=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIID/jCCAuagAwIBAgIQTDc+UgTRtYO7ZGTQ8UWKDDANBgkqhkiG9w0BAQsFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIGV1LXdlc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTIxMjI0NjI0WhgPMjA2MTA1MjEyMzQ2MjRaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgZXUtd2VzdC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM1oGtthQ1YiVIC2\ni4u4swMAGxAjc/BZp0yq0eP5ZQFaxnxs7zFAPabEWsrjeDzrRhdVO0h7zskrertP\ngblGhfD20JfjvCHdP1RUhy/nzG+T+hn6Takan/GIgs8grlBMRHMgBYHW7tklhjaH\n3F7LujhceAHhhgp6IOrpb6YTaTTaJbF3GTmkqxSJ3l1LtEoWz8Al/nL/Ftzxrtez\nVs6ebpvd7sw37sxmXBWX2OlvUrPCTmladw9OrllGXtCFw4YyLe3zozBlZ3cHzQ0q\nlINhpRcajTMfZrsiGCkQtoJT+AqVJPS2sHjqsEH8yiySW9Jbq4zyMbM1yqQ2vnnx\nMJgoYMcCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUaQG88UnV\nJPTI+Pcti1P+q3H7pGYwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\nAQBAkgr75V0sEJimC6QRiTVWEuj2Khy7unjSfudbM6zumhXEU2/sUaVLiYy6cA/x\n3v0laDle6T07x9g64j5YastE/4jbzrGgIINFlY0JnaYmR3KZEjgi1s1fkRRf3llL\nPJm9u4Q1mbwAMQK/ZjLuuRcL3uRIHJek18nRqT5h43GB26qXyvJqeYYpYfIjL9+/\nYiZAbSRRZG+Li23cmPWrbA1CJY121SB+WybCbysbOXzhD3Sl2KSZRwSw4p2HrFtV\n1Prk0dOBtZxCG9luf87ultuDZpfS0w6oNBAMXocgswk24ylcADkkFxBWW+7BETn1\nEpK+t1Lm37mU4sxtuha00XAi\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIEADCCAuigAwIBAgIQcY44/8NUvBwr6LlHfRy7KjANBgkqhkiG9w0BAQsFADCB\nmDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\nbWF6b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUxOTE4MjcxOFoYDzIwNjEwNTE5MTkyNzE4WjCBmDEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\nb24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0UaBeC+Usalu\nEtXnV7+PnH+gi7/71tI/jkKVGKuhD2JDVvqLVoqbMHRh3+wGMvqKCjbHPcC2XMWv\n566fpAj4UZ9CLB5fVzss+QVNTl+FH2XhEzigopp+872ajsNzcZxrMkifxGb4i0U+\nt0Zi+UrbL5tsfP2JonKR1crOrbS6/DlzHBjIiJazGOQcMsJjNuTOItLbMohLpraA\n/nApa3kOvI7Ufool1/34MG0+wL3UUA4YkZ6oBJVxjZvvs6tI7Lzz/SnhK2widGdc\nsnbLqBpHNIZQSorVoiwcFaRBGYX/uzYkiw44Yfa4cK2V/B5zgu1Fbr0gbI2am4eh\nyVYyg4jPawIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBS9gM1m\nIIjyh9O5H/7Vj0R/akI7UzAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\nggEBAF0Sm9HC2AUyedBVnwgkVXMibnYChOzz7T+0Y+fOLXYAEXex2s8oqGeZdGYX\nJHkjBn7JXu7LM+TpTbPbFFDoc1sgMguD/ls+8XsqAl1CssW+amryIL+jfcfbgQ+P\nICwEUD9hGdjBgJ5WcuS+qqxHsEIlFNci3HxcxfBa9VsWs5TjI7Vsl4meL5lf7ZyL\nwDV7dHRuU+cImqG1MIvPRIlvPnT7EghrCYi2VCPhP2pM/UvShuwVnkz4MJ29ebIk\nWR9kpblFxFdE92D5UUvMCjC2kmtgzNiErvTcwIvOO9YCbBHzRB1fFiWrXUHhJWq9\nIkaxR5icb/IpAV0A1lYZEWMVsfQ=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIGATCCA+mgAwIBAgIRAMa0TPL+QgbWfUPpYXQkf8wwDQYJKoZIhvcNAQEMBQAw\ngZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\nQW1hem9uIFJEUyBldS1ub3J0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMTA1MjQyMTAzMjBaGA8yMTIxMDUyNDIyMDMyMFowgZgx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\nem9uIFJEUyBldS1ub3J0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANhS9LJVJyWp\n6Rudy9t47y6kzvgnFYDrvJVtgEK0vFn5ifdlHE7xqMz4LZqWBFTnS+3oidwVRqo7\ntqsuuElsouStO8m315/YUzKZEPmkw8h5ufWt/lg3NTCoUZNkB4p4skr7TspyMUwE\nVdlKQuWTCOLtofwmWT+BnFF3To6xTh3XPlT3ssancw27Gob8kJegD7E0TSMVsecP\nB8je65+3b8CGwcD3QB3kCTGLy87tXuS2+07pncHvjMRMBdDQQQqhXWsRSeUNg0IP\nxdHTWcuwMldYPWK5zus9M4dCNBDlmZjKdcZZVUOKeBBAm7Uo7CbJCk8r/Fvfr6mw\nnXXDtuWhqn/WhJiI/y0QU27M+Hy5CQMxBwFsfAjJkByBpdXmyYxUgTmMpLf43p7H\noWfH1xN0cT0OQEVmAQjMakauow4AQLNkilV+X6uAAu3STQVFRSrpvMen9Xx3EPC3\nG9flHueTa71bU65Xe8ZmEmFhGeFYHY0GrNPAFhq9RThPRY0IPyCZe0Th8uGejkek\njQjm0FHPOqs5jc8CD8eJs4jSEFt9lasFLVDcAhx0FkacLKQjGHvKAnnbRwhN/dF3\nxt4oL8Z4JGPCLau056gKnYaEyviN7PgO+IFIVOVIdKEBu2ASGE8/+QJB5bcHefNj\n04hEkDW0UYJbSfPpVbGAR0gFI/QpycKnAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wHQYDVR0OBBYEFFMXvvjoaGGUcul8GA3FT05DLbZcMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQwFAAOCAgEAQLwFhd2JKn4K/6salLyIA4mP58qbA/9BTB/r\nD9l0bEwDlVPSdY7R3gZCe6v7SWLfA9RjE5tdWDrQMi5IU6W2OVrVsZS/yGJfwnwe\na/9iUAYprA5QYKDg37h12XhVsDKlYCekHdC+qa5WwB1SL3YUprDLPWeaIQdg+Uh2\n+LxvpZGoxoEbca0fc7flwq9ke/3sXt/3V4wJDyY6AL2YNdjFzC+FtYjHHx8rYxHs\naesP7yunuN17KcfOZBBnSFRrx96k+Xm95VReTEEpwiBqAECqEpMbd+R0mFAayMb1\ncE77GaK5yeC2f67NLYGpkpIoPbO9p9rzoXLE5GpSizMjimnz6QCbXPFAFBDfSzim\nu6azp40kEUO6kWd7rBhqRwLc43D3TtNWQYxMve5mTRG4Od+eMKwYZmQz89BQCeqm\naZiJP9y9uwJw4p/A5V3lYHTDQqzmbOyhGUk6OdpdE8HXs/1ep1xTT20QDYOx3Ekt\nr4mmNYfH/8v9nHNRlYJOqFhmoh1i85IUl5IHhg6OT5ZTTwsGTSxvgQQXrmmHVrgZ\nrZIqyBKllCgVeB9sMEsntn4bGLig7CS/N1y2mYdW/745yCLZv2gj0NXhPqgEIdVV\nf9DhFD4ohE1C63XP0kOQee+LYg/MY5vH8swpCSWxQgX5icv5jVDz8YTdCKgUc5u8\nrM2p0kk=\n-----END CERTIFICATE-----\n"
  ];
  return defaults;
}
var proxies = {};
var hasRequiredProxies;
function requireProxies() {
  if (hasRequiredProxies) return proxies;
  hasRequiredProxies = 1;
  Object.defineProperty(proxies, "__esModule", { value: true });
  proxies.proxies = void 0;
  proxies.proxies = [
    "-----BEGIN CERTIFICATE-----\nMIIDQTCCAimgAwIBAgITBmyfz5m/jAo54vB4ikPmljZbyjANBgkqhkiG9w0BAQsF\nADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\nb24gUm9vdCBDQSAxMB4XDTE1MDUyNjAwMDAwMFoXDTM4MDExNzAwMDAwMFowOTEL\nMAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv\nb3QgQ0EgMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALJ4gHHKeNXj\nca9HgFB0fW7Y14h29Jlo91ghYPl0hAEvrAIthtOgQ3pOsqTQNroBvo3bSMgHFzZM\n9O6II8c+6zf1tRn4SWiw3te5djgdYZ6k/oI2peVKVuRF4fn9tBb6dNqcmzU5L/qw\nIFAGbHrQgLKm+a/sRxmPUDgH3KKHOVj4utWp+UhnMJbulHheb4mjUcAwhmahRWa6\nVOujw5H5SNz/0egwLX0tdHA114gk957EWW67c4cX8jJGKLhD+rcdqsq08p8kDi1L\n93FcXmn/6pUCyziKrlA4b9v7LWIbxcceVOF34GfID5yHI9Y/QCB/IIDEgEw+OyQm\njgSubJrIqg0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC\nAYYwHQYDVR0OBBYEFIQYzIU07LwMlJQuCFmcx7IQTgoIMA0GCSqGSIb3DQEBCwUA\nA4IBAQCY8jdaQZChGsV2USggNiMOruYou6r4lK5IpDB/G/wkjUu0yKGX9rbxenDI\nU5PMCCjjmCXPI6T53iHTfIUJrU6adTrCC2qJeHZERxhlbI1Bjjt/msv0tadQ1wUs\nN+gDS63pYaACbvXy8MWy7Vu33PqUXHeeE6V/Uq2V8viTO96LXFvKWlJbYK8U90vv\no/ufQJVtMVT8QtPHRh8jrdkPSHCa2XV4cdFyQzR1bldZwgJcJmApzyMZFo6IQ6XU\n5MsI+yMRQ+hDKXJioaldXgjUkK642M4UwtBV8ob2xJNDd2ZhwLnoQdeXeGADbkpy\nrqXRfboQnoZsG4q5WTP468SQvvG5\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIFQTCCAymgAwIBAgITBmyf0pY1hp8KD+WGePhbJruKNzANBgkqhkiG9w0BAQwF\nADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\nb24gUm9vdCBDQSAyMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTEL\nMAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv\nb3QgQ0EgMjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK2Wny2cSkxK\ngXlRmeyKy2tgURO8TW0G/LAIjd0ZEGrHJgw12MBvIITplLGbhQPDW9tK6Mj4kHbZ\nW0/jTOgGNk3Mmqw9DJArktQGGWCsN0R5hYGCrVo34A3MnaZMUnbqQ523BNFQ9lXg\n1dKmSYXpN+nKfq5clU1Imj+uIFptiJXZNLhSGkOQsL9sBbm2eLfq0OQ6PBJTYv9K\n8nu+NQWpEjTj82R0Yiw9AElaKP4yRLuH3WUnAnE72kr3H9rN9yFVkE8P7K6C4Z9r\n2UXTu/Bfh+08LDmG2j/e7HJV63mjrdvdfLC6HM783k81ds8P+HgfajZRRidhW+me\nz/CiVX18JYpvL7TFz4QuK/0NURBs+18bvBt+xa47mAExkv8LV/SasrlX6avvDXbR\n8O70zoan4G7ptGmh32n2M8ZpLpcTnqWHsFcQgTfJU7O7f/aS0ZzQGPSSbtqDT6Zj\nmUyl+17vIWR6IF9sZIUVyzfpYgwLKhbcAS4y2j5L9Z469hdAlO+ekQiG+r5jqFoz\n7Mt0Q5X5bGlSNscpb/xVA1wf+5+9R+vnSUeVC06JIglJ4PVhHvG/LopyboBZ/1c6\n+XUyo05f7O0oYtlNc/LMgRdg7c3r3NunysV+Ar3yVAhU/bQtCSwXVEqY0VThUWcI\n0u1ufm8/0i2BWSlmy5A5lREedCf+3euvAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSwDPBMMPQFWAJI/TPlUq9LhONm\nUjANBgkqhkiG9w0BAQwFAAOCAgEAqqiAjw54o+Ci1M3m9Zh6O+oAA7CXDpO8Wqj2\nLIxyh6mx/H9z/WNxeKWHWc8w4Q0QshNabYL1auaAn6AFC2jkR2vHat+2/XcycuUY\n+gn0oJMsXdKMdYV2ZZAMA3m3MSNjrXiDCYZohMr/+c8mmpJ5581LxedhpxfL86kS\nk5Nrp+gvU5LEYFiwzAJRGFuFjWJZY7attN6a+yb3ACfAXVU3dJnJUH/jWS5E4ywl\n7uxMMne0nxrpS10gxdr9HIcWxkPo1LsmmkVwXqkLN1PiRnsn/eBG8om3zEK2yygm\nbtmlyTrIQRNg91CMFa6ybRoVGld45pIq2WWQgj9sAq+uEjonljYE1x2igGOpm/Hl\nurR8FLBOybEfdF849lHqm/osohHUqS0nGkWxr7JOcQ3AWEbWaQbLU8uz/mtBzUF+\nfUwPfHJ5elnNXkoOrJupmHN5fLT0zLm4BwyydFy4x2+IoZCn9Kr5v2c69BoVYh63\nn749sSmvZ6ES8lgQGVMDMBu4Gon2nL2XA46jCfMdiyHxtN/kHNGfZQIG6lzWE7OE\n76KlXIx3KadowGuuQNKotOrN8I1LOJwZmhsoVLiJkO/KdYE+HvJkJMcYr07/R54H\n9jVlpNMKVv/1F2Rs76giJUmTtt8AF9pYfl3uxRuw0dFfIRDH+fO6AgonB8Xx1sfT\n4PsJYGw=\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIBtjCCAVugAwIBAgITBmyf1XSXNmY/Owua2eiedgPySjAKBggqhkjOPQQDAjA5\nMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g\nUm9vdCBDQSAzMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG\nA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg\nQ0EgMzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABCmXp8ZBf8ANm+gBG1bG8lKl\nui2yEujSLtf6ycXYqm0fc4E7O5hrOXwzpcVOho6AF2hiRVd9RFgdszflZwjrZt6j\nQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSr\nttvXBp43rDCGB5Fwx5zEGbF4wDAKBggqhkjOPQQDAgNJADBGAiEA4IWSoxe3jfkr\nBqWTrBqYaGFy+uGh0PsceGCmQ5nFuMQCIQCcAu/xlJyzlvnrxir4tiz+OpAUFteM\nYyRIHN8wfdVoOw==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIIB8jCCAXigAwIBAgITBmyf18G7EEwpQ+Vxe3ssyBrBDjAKBggqhkjOPQQDAzA5\nMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g\nUm9vdCBDQSA0MB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG\nA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg\nQ0EgNDB2MBAGByqGSM49AgEGBSuBBAAiA2IABNKrijdPo1MN/sGKe0uoe0ZLY7Bi\n9i0b2whxIdIA6GO9mif78DluXeo9pcmBqqNbIJhFXRbb/egQbeOc4OO9X4Ri83Bk\nM6DLJC9wuoihKqB1+IGuYgbEgds5bimwHvouXKNCMEAwDwYDVR0TAQH/BAUwAwEB\n/zAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYEFNPsxzplbszh2naaVvuc84ZtV+WB\nMAoGCCqGSM49BAMDA2gAMGUCMDqLIfG9fhGt0O9Yli/W651+kI0rz2ZVwyzjKKlw\nCkcO8DdZEv8tmZQoTipPNU0zWgIxAOp1AE47xDqUEpHJWEadIRNyp4iciuRMStuW\n1KyLa2tJElMzrdfkviT8tQp21KW8EA==\n-----END CERTIFICATE-----\n",
    "-----BEGIN CERTIFICATE-----\nMIID7zCCAtegAwIBAgIBADANBgkqhkiG9w0BAQsFADCBmDELMAkGA1UEBhMCVVMx\nEDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT\nHFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xOzA5BgNVBAMTMlN0YXJmaWVs\nZCBTZXJ2aWNlcyBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5\nMDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1OVowgZgxCzAJBgNVBAYTAlVTMRAwDgYD\nVQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYDVQQKExxTdGFy\nZmllbGQgVGVjaG5vbG9naWVzLCBJbmMuMTswOQYDVQQDEzJTdGFyZmllbGQgU2Vy\ndmljZXMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBANUMOsQq+U7i9b4Zl1+OiFOxHz/Lz58gE20p\nOsgPfTz3a3Y4Y9k2YKibXlwAgLIvWX/2h/klQ4bnaRtSmpDhcePYLQ1Ob/bISdm2\n8xpWriu2dBTrz/sm4xq6HZYuajtYlIlHVv8loJNwU4PahHQUw2eeBGg6345AWh1K\nTs9DkTvnVtYAcMtS7nt9rjrnvDH5RfbCYM8TWQIrgMw0R9+53pBlbQLPLJGmpufe\nhRhJfGZOozptqbXuNC66DQO4M99H67FrjSXZm86B0UVGMpZwh94CDklDhbZsc7tk\n6mFBrMnUVN+HL8cisibMn1lUaJ/8viovxFUcdUBgF4UCVTmLfwUCAwEAAaNCMEAw\nDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFJxfAN+q\nAdcwKziIorhtSpzyEZGDMA0GCSqGSIb3DQEBCwUAA4IBAQBLNqaEd2ndOxmfZyMI\nbw5hyf2E3F/YNoHN2BtBLZ9g3ccaaNnRbobhiCPPE95Dz+I0swSdHynVv/heyNXB\nve6SbzJ08pGCL72CQnqtKrcgfU28elUSwhXqvfdqlS5sdJ/PHLTyxQGjhdByPq1z\nqwubdQxtRbeOlKyWN7Wg0I8VRw7j6IPdj/3vQQF3zCepYoUz8jcI73HPdwbeyBkd\niEDPfUYd/x7H4c7/I9vG+o1VTqkC50cRRj70/b17KSa7qWFiNyi2LSr2EIZkyXCn\n0q23KXB56jzaYyWf/Wi3MOxw+3WKt21gZ7IeyLnp2KhvAotnDU0mV3HaIPzBSlCN\nsSi6\n-----END CERTIFICATE-----\n"
  ];
  return proxies;
}
var lib = lib$1.exports;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$1.exports;
  hasRequiredLib = 1;
  Object.defineProperty(lib, "__esModule", { value: true });
  const defaults_js_1 = requireDefaults();
  const proxies_js_1 = requireProxies();
  const proxyBundle = {
    ca: proxies_js_1.proxies
  };
  const profiles = {
    ca: [...defaults_js_1.defaults, ...proxies_js_1.proxies]
  };
  lib$1.exports = profiles;
  lib$1.exports.proxyBundle = proxyBundle;
  lib$1.exports.default = profiles;
  return lib$1.exports;
}
var hasRequiredSsl_profiles;
function requireSsl_profiles() {
  if (hasRequiredSsl_profiles) return ssl_profiles;
  hasRequiredSsl_profiles = 1;
  (function(exports$1) {
    const awsCaBundle = requireLib();
    exports$1["Amazon RDS"] = {
      ca: awsCaBundle.ca
    };
  })(ssl_profiles);
  return ssl_profiles;
}
var connection_config;
var hasRequiredConnection_config;
function requireConnection_config() {
  if (hasRequiredConnection_config) return connection_config;
  hasRequiredConnection_config = 1;
  const { URL: URL2 } = require$$2$2;
  const ClientConstants = requireClient();
  const Charsets = requireCharsets();
  const { version: version2 } = require$$3;
  let SSLProfiles = null;
  const validOptions = {
    authPlugins: 1,
    authSwitchHandler: 1,
    bigNumberStrings: 1,
    charset: 1,
    charsetNumber: 1,
    compress: 1,
    connectAttributes: 1,
    connectTimeout: 1,
    database: 1,
    dateStrings: 1,
    debug: 1,
    decimalNumbers: 1,
    enableKeepAlive: 1,
    flags: 1,
    host: 1,
    insecureAuth: 1,
    infileStreamFactory: 1,
    isServer: 1,
    keepAliveInitialDelay: 1,
    localAddress: 1,
    maxPreparedStatements: 1,
    multipleStatements: 1,
    namedPlaceholders: 1,
    nestTables: 1,
    password: 1,
    // with multi-factor authentication, the main password (used for the first
    // authentication factor) can be provided via password1
    password1: 1,
    password2: 1,
    password3: 1,
    passwordSha1: 1,
    pool: 1,
    port: 1,
    queryFormat: 1,
    rowsAsArray: 1,
    socketPath: 1,
    ssl: 1,
    stream: 1,
    stringifyObjects: 1,
    supportBigNumbers: 1,
    timezone: 1,
    trace: 1,
    typeCast: 1,
    uri: 1,
    user: 1,
    disableEval: 1,
    // These options are used for Pool
    connectionLimit: 1,
    maxIdle: 1,
    idleTimeout: 1,
    Promise: 1,
    queueLimit: 1,
    waitForConnections: 1,
    jsonStrings: 1,
    gracefulEnd: 1
  };
  class ConnectionConfig {
    constructor(options) {
      if (typeof options === "string") {
        options = ConnectionConfig.parseUrl(options);
      } else if (options && options.uri) {
        const uriOptions = ConnectionConfig.parseUrl(options.uri);
        for (const key in uriOptions) {
          if (!Object.prototype.hasOwnProperty.call(uriOptions, key)) continue;
          if (options[key]) continue;
          options[key] = uriOptions[key];
        }
      }
      for (const key in options) {
        if (!Object.prototype.hasOwnProperty.call(options, key)) continue;
        if (validOptions[key] !== 1) {
          console.error(
            `Ignoring invalid configuration option passed to Connection: ${key}. This is currently a warning, but in future versions of MySQL2, an error will be thrown if you pass an invalid configuration option to a Connection`
          );
        }
      }
      this.isServer = options.isServer;
      this.stream = options.stream;
      this.host = options.host || "localhost";
      this.port = (typeof options.port === "string" ? parseInt(options.port, 10) : options.port) || 3306;
      this.localAddress = options.localAddress;
      this.socketPath = options.socketPath;
      this.user = options.user || void 0;
      this.password = options.password || options.password1 || void 0;
      this.password2 = options.password2 || void 0;
      this.password3 = options.password3 || void 0;
      this.passwordSha1 = options.passwordSha1 || void 0;
      this.database = options.database;
      this.connectTimeout = isNaN(options.connectTimeout) ? 10 * 1e3 : options.connectTimeout;
      this.insecureAuth = options.insecureAuth || false;
      this.infileStreamFactory = options.infileStreamFactory || void 0;
      this.supportBigNumbers = options.supportBigNumbers || false;
      this.bigNumberStrings = options.bigNumberStrings || false;
      this.decimalNumbers = options.decimalNumbers || false;
      this.dateStrings = options.dateStrings || false;
      this.debug = options.debug;
      this.trace = options.trace !== false;
      this.stringifyObjects = options.stringifyObjects || false;
      this.enableKeepAlive = options.enableKeepAlive !== false;
      this.keepAliveInitialDelay = options.keepAliveInitialDelay;
      if (options.timezone && !/^(?:local|Z|[ +-]\d\d:\d\d)$/.test(options.timezone)) {
        console.error(
          `Ignoring invalid timezone passed to Connection: ${options.timezone}. This is currently a warning, but in future versions of MySQL2, an error will be thrown if you pass an invalid configuration option to a Connection`
        );
        this.timezone = "Z";
      } else {
        this.timezone = options.timezone || "local";
      }
      this.queryFormat = options.queryFormat;
      this.pool = options.pool || void 0;
      this.ssl = typeof options.ssl === "string" ? ConnectionConfig.getSSLProfile(options.ssl) : options.ssl || false;
      this.multipleStatements = options.multipleStatements || false;
      this.rowsAsArray = options.rowsAsArray || false;
      this.namedPlaceholders = options.namedPlaceholders || false;
      this.nestTables = options.nestTables === void 0 ? void 0 : options.nestTables;
      this.typeCast = options.typeCast === void 0 ? true : options.typeCast;
      this.disableEval = Boolean(options.disableEval);
      if (this.timezone[0] === " ") {
        this.timezone = `+${this.timezone.slice(1)}`;
      }
      if (this.ssl) {
        if (typeof this.ssl !== "object") {
          throw new TypeError(
            `SSL profile must be an object, instead it's a ${typeof this.ssl}`
          );
        }
        this.ssl.rejectUnauthorized = this.ssl.rejectUnauthorized !== false;
      }
      this.maxPacketSize = 0;
      this.charsetNumber = options.charset ? ConnectionConfig.getCharsetNumber(options.charset) : options.charsetNumber || Charsets.UTF8MB4_UNICODE_CI;
      this.compress = options.compress || false;
      this.authPlugins = options.authPlugins;
      this.authSwitchHandler = options.authSwitchHandler;
      this.clientFlags = ConnectionConfig.mergeFlags(
        ConnectionConfig.getDefaultFlags(options),
        options.flags || ""
      );
      const defaultConnectAttributes = {
        _client_name: "Node-MySQL-2",
        _client_version: version2
      };
      this.connectAttributes = {
        ...defaultConnectAttributes,
        ...options.connectAttributes || {}
      };
      this.maxPreparedStatements = options.maxPreparedStatements || 16e3;
      this.jsonStrings = options.jsonStrings || false;
      this.gracefulEnd = options.gracefulEnd || false;
    }
    static mergeFlags(default_flags, user_flags) {
      let flags = 0, i;
      if (!Array.isArray(user_flags)) {
        user_flags = String(user_flags || "").toUpperCase().split(/\s*,+\s*/);
      }
      for (i in default_flags) {
        if (user_flags.indexOf(`-${default_flags[i]}`) >= 0) {
          continue;
        }
        flags |= ClientConstants[default_flags[i]] || 0;
      }
      for (i in user_flags) {
        if (user_flags[i][0] === "-") {
          continue;
        }
        if (default_flags.indexOf(user_flags[i]) >= 0) {
          continue;
        }
        flags |= ClientConstants[user_flags[i]] || 0;
      }
      return flags;
    }
    static getDefaultFlags(options) {
      const defaultFlags = [
        "LONG_PASSWORD",
        "FOUND_ROWS",
        "LONG_FLAG",
        "CONNECT_WITH_DB",
        "ODBC",
        "LOCAL_FILES",
        "IGNORE_SPACE",
        "PROTOCOL_41",
        "IGNORE_SIGPIPE",
        "TRANSACTIONS",
        "RESERVED",
        "SECURE_CONNECTION",
        "MULTI_RESULTS",
        "TRANSACTIONS",
        "SESSION_TRACK",
        "CONNECT_ATTRS"
      ];
      if (options && options.multipleStatements) {
        defaultFlags.push("MULTI_STATEMENTS");
      }
      defaultFlags.push("PLUGIN_AUTH");
      defaultFlags.push("PLUGIN_AUTH_LENENC_CLIENT_DATA");
      return defaultFlags;
    }
    static getCharsetNumber(charset) {
      const num = Charsets[charset.toUpperCase()];
      if (num === void 0) {
        throw new TypeError(`Unknown charset '${charset}'`);
      }
      return num;
    }
    static getSSLProfile(name) {
      if (!SSLProfiles) {
        SSLProfiles = requireSsl_profiles();
      }
      const ssl = SSLProfiles[name];
      if (ssl === void 0) {
        throw new TypeError(`Unknown SSL profile '${name}'`);
      }
      return ssl;
    }
    static parseUrl(url) {
      const parsedUrl = new URL2(url);
      const options = {
        host: decodeURIComponent(parsedUrl.hostname),
        port: parseInt(parsedUrl.port, 10),
        database: decodeURIComponent(parsedUrl.pathname.slice(1)),
        user: decodeURIComponent(parsedUrl.username),
        password: decodeURIComponent(parsedUrl.password)
      };
      parsedUrl.searchParams.forEach((value, key) => {
        try {
          options[key] = JSON.parse(value);
        } catch {
          options[key] = value;
        }
      });
      return options;
    }
  }
  connection_config = ConnectionConfig;
  return connection_config;
}
var namedPlaceholders = { exports: {} };
var hasRequiredNamedPlaceholders;
function requireNamedPlaceholders() {
  if (hasRequiredNamedPlaceholders) return namedPlaceholders.exports;
  hasRequiredNamedPlaceholders = 1;
  const RE_PARAM = /(?:\?)|(?::(\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/g, DQUOTE = 34, SQUOTE = 39, BSLASH = 92;
  function parse(query2) {
    let ppos = RE_PARAM.exec(query2);
    let curpos = 0;
    let start = 0;
    let end;
    const parts = [];
    let inQuote = false;
    let escape = false;
    let qchr;
    const tokens = [];
    let qcnt = 0;
    let lastTokenEndPos = 0;
    let i;
    if (ppos) {
      do {
        for (i = curpos, end = ppos.index; i < end; ++i) {
          const chr = query2.charCodeAt(i);
          if (chr === BSLASH) escape = !escape;
          else {
            if (escape) {
              escape = false;
              continue;
            }
            if (inQuote && chr === qchr) {
              if (query2.charCodeAt(i + 1) === qchr) {
                ++i;
                continue;
              }
              inQuote = false;
            } else if (!inQuote && (chr === DQUOTE || chr === SQUOTE)) {
              inQuote = true;
              qchr = chr;
            }
          }
        }
        if (!inQuote) {
          parts.push(query2.substring(start, end));
          tokens.push(ppos[0].length === 1 ? qcnt++ : ppos[1]);
          start = end + ppos[0].length;
          lastTokenEndPos = start;
        }
        curpos = end + ppos[0].length;
      } while (ppos = RE_PARAM.exec(query2));
      if (tokens.length) {
        if (curpos < query2.length) {
          parts.push(query2.substring(lastTokenEndPos));
        }
        return [parts, tokens];
      }
    }
    return [query2];
  }
  function createCompiler(config) {
    if (!config) config = {};
    if (!config.placeholder) {
      config.placeholder = "?";
    }
    let ncache = 100;
    let cache;
    if (typeof config.cache === "number") {
      ncache = config.cache;
    }
    if (typeof config.cache === "object") {
      cache = config.cache;
    }
    if (config.cache !== false && !cache) {
      cache = requireLib$2().createLRU({ max: ncache });
    }
    function toArrayParams(tree, params) {
      const arr = [];
      if (tree.length === 1) {
        return [tree[0], []];
      }
      if (typeof params === "undefined")
        throw new Error(
          "Named query contains placeholders, but parameters object is undefined"
        );
      const tokens = tree[1];
      for (let i = 0; i < tokens.length; ++i) {
        arr.push(params[tokens[i]]);
      }
      return [tree[0], arr];
    }
    function noTailingSemicolon(s) {
      if (s.slice(-1) === ":") {
        return s.slice(0, -1);
      }
      return s;
    }
    function join(tree) {
      if (tree.length === 1) {
        return tree;
      }
      let unnamed = noTailingSemicolon(tree[0][0]);
      for (let i = 1; i < tree[0].length; ++i) {
        if (tree[0][i - 1].slice(-1) === ":") {
          unnamed += config.placeholder;
        }
        unnamed += config.placeholder;
        unnamed += noTailingSemicolon(tree[0][i]);
      }
      const last = tree[0][tree[0].length - 1];
      if (tree[0].length === tree[1].length) {
        if (last.slice(-1) === ":") {
          unnamed += config.placeholder;
        }
        unnamed += config.placeholder;
      }
      return [unnamed, tree[1]];
    }
    function compile(query2, paramsObj) {
      let tree;
      if (cache && (tree = cache.get(query2))) {
        return toArrayParams(tree, paramsObj);
      }
      tree = join(parse(query2));
      if (cache) {
        cache.set(query2, tree);
      }
      return toArrayParams(tree, paramsObj);
    }
    compile.parse = parse;
    return compile;
  }
  function toNumbered(q, params) {
    const tree = parse(q);
    const paramsArr = [];
    if (tree.length === 1) {
      return [tree[0], paramsArr];
    }
    const pIndexes = {};
    let pLastIndex = 0;
    let qs = "";
    let varIndex;
    const varNames = [];
    for (let i = 0; i < tree[0].length; ++i) {
      varIndex = pIndexes[tree[1][i]];
      if (!varIndex) {
        varIndex = ++pLastIndex;
        pIndexes[tree[1][i]] = varIndex;
      }
      if (tree[1][i]) {
        varNames[varIndex - 1] = tree[1][i];
        qs += `${tree[0][i]}$${varIndex}`;
      } else {
        qs += tree[0][i];
      }
    }
    return [qs, varNames.map((n) => params[n])];
  }
  namedPlaceholders.exports = createCompiler;
  namedPlaceholders.exports.toNumbered = toNumbered;
  return namedPlaceholders.exports;
}
var connection$2;
var hasRequiredConnection$2;
function requireConnection$2() {
  if (hasRequiredConnection$2) return connection$2;
  hasRequiredConnection$2 = 1;
  const Net = require$$0$7;
  const Tls = require$$2$3;
  const Timers = require$$1$8;
  const EventEmitter = require$$0$3.EventEmitter;
  const Readable = require$$0$2.Readable;
  const Queue = requireDenque();
  const SqlString2 = requireSqlstring();
  const { createLRU } = requireLib$2();
  const PacketParser = requirePacket_parser();
  const Packets = requirePackets();
  const Commands = requireCommands();
  const ConnectionConfig = requireConnection_config();
  const CharsetToEncoding = requireCharset_encodings();
  let _connectionId = 0;
  let convertNamedPlaceholders = null;
  class BaseConnection extends EventEmitter {
    constructor(opts) {
      super();
      this.config = opts.config;
      if (!opts.config.stream) {
        if (opts.config.socketPath) {
          this.stream = Net.connect(opts.config.socketPath);
        } else {
          this.stream = Net.connect(opts.config.port, opts.config.host);
          if (this.config.enableKeepAlive) {
            this.stream.on("connect", () => {
              this.stream.setKeepAlive(true, this.config.keepAliveInitialDelay);
            });
          }
          this.stream.setNoDelay(true);
        }
      } else if (typeof opts.config.stream === "function") {
        this.stream = opts.config.stream(opts);
      } else {
        this.stream = opts.config.stream;
      }
      this._internalId = _connectionId++;
      this._commands = new Queue();
      this._command = null;
      this._paused = false;
      this._paused_packets = new Queue();
      this._statements = createLRU({
        max: this.config.maxPreparedStatements,
        onEviction: function(_, statement) {
          statement.close();
        }
      });
      this.serverCapabilityFlags = 0;
      this.authorized = false;
      this.sequenceId = 0;
      this.compressedSequenceId = 0;
      this.threadId = null;
      this._handshakePacket = null;
      this._fatalError = null;
      this._protocolError = null;
      this._outOfOrderPackets = [];
      this.clientEncoding = CharsetToEncoding[this.config.charsetNumber];
      this.stream.on("error", this._handleNetworkError.bind(this));
      this.packetParser = new PacketParser((p) => {
        this.handlePacket(p);
      });
      this.stream.on("data", (data) => {
        if (this.connectTimeout) {
          Timers.clearTimeout(this.connectTimeout);
          this.connectTimeout = null;
        }
        this.packetParser.execute(data);
      });
      this.stream.on("end", () => {
        this.emit("end");
      });
      this.stream.on("close", () => {
        if (this._closing) {
          return;
        }
        if (!this._protocolError) {
          this._protocolError = new Error(
            "Connection lost: The server closed the connection."
          );
          this._protocolError.fatal = true;
          this._protocolError.code = "PROTOCOL_CONNECTION_LOST";
        }
        this._notifyError(this._protocolError);
      });
      let handshakeCommand;
      if (!this.config.isServer) {
        handshakeCommand = new Commands.ClientHandshake(this.config.clientFlags);
        handshakeCommand.on("end", () => {
          if (!handshakeCommand.handshake || this._fatalError || this._protocolError) {
            return;
          }
          this._handshakePacket = handshakeCommand.handshake;
          this.threadId = handshakeCommand.handshake.connectionId;
          this.emit("connect", handshakeCommand.handshake);
        });
        handshakeCommand.on("error", (err) => {
          this._closing = true;
          this._notifyError(err);
        });
        this.addCommand(handshakeCommand);
      }
      this.serverEncoding = "utf8";
      if (this.config.connectTimeout) {
        const timeoutHandler = this._handleTimeoutError.bind(this);
        this.connectTimeout = Timers.setTimeout(
          timeoutHandler,
          this.config.connectTimeout
        );
      }
    }
    _addCommandClosedState(cmd) {
      const err = new Error(
        "Can't add new command when connection is in closed state"
      );
      err.fatal = true;
      if (cmd.onResult) {
        cmd.onResult(err);
      } else {
        this.emit("error", err);
      }
    }
    _handleFatalError(err) {
      err.fatal = true;
      this.stream.removeAllListeners("data");
      this.addCommand = this._addCommandClosedState;
      this.write = () => {
        this.emit("error", new Error("Can't write in closed state"));
      };
      this._notifyError(err);
      this._fatalError = err;
    }
    _handleNetworkError(err) {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      }
      if (err.code === "ECONNRESET" && this._closing) {
        return;
      }
      this._handleFatalError(err);
    }
    _handleTimeoutError() {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      }
      this.stream.destroy && this.stream.destroy();
      const err = new Error("connect ETIMEDOUT");
      err.errorno = "ETIMEDOUT";
      err.code = "ETIMEDOUT";
      err.syscall = "connect";
      this._handleNetworkError(err);
    }
    // notify all commands in the queue and bubble error as connection "error"
    // called on stream error or unexpected termination
    _notifyError(err) {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      }
      if (this._fatalError) {
        return;
      }
      let command2;
      let bubbleErrorToConnection = !this._command;
      if (this._command && this._command.onResult) {
        this._command.onResult(err);
        this._command = null;
      } else if (!(this._command && this._command.constructor === Commands.ClientHandshake && this._commands.length > 0)) {
        bubbleErrorToConnection = true;
      }
      while (command2 = this._commands.shift()) {
        if (command2.onResult) {
          command2.onResult(err);
        } else {
          bubbleErrorToConnection = true;
        }
      }
      if (bubbleErrorToConnection || this._pool) {
        this.emit("error", err);
      }
      if (err.fatal) {
        this.close();
      }
    }
    write(buffer) {
      const result = this.stream.write(buffer, (err) => {
        if (err) {
          this._handleNetworkError(err);
        }
      });
      if (!result) {
        this.stream.emit("pause");
      }
    }
    // http://dev.mysql.com/doc/internals/en/sequence-id.html
    //
    // The sequence-id is incremented with each packet and may wrap around.
    // It starts at 0 and is reset to 0 when a new command
    // begins in the Command Phase.
    // http://dev.mysql.com/doc/internals/en/example-several-mysql-packets.html
    _resetSequenceId() {
      this.sequenceId = 0;
      this.compressedSequenceId = 0;
    }
    _bumpCompressedSequenceId(numPackets) {
      this.compressedSequenceId += numPackets;
      this.compressedSequenceId %= 256;
    }
    _bumpSequenceId(numPackets) {
      this.sequenceId += numPackets;
      this.sequenceId %= 256;
    }
    writePacket(packet2) {
      const MAX_PACKET_LENGTH = 16777215;
      const length = packet2.length();
      let chunk, offset, header;
      if (length < MAX_PACKET_LENGTH) {
        packet2.writeHeader(this.sequenceId);
        if (this.config.debug) {
          console.log(
            `${this._internalId} ${this.connectionId} <== ${this._command._commandName}#${this._command.stateName()}(${[this.sequenceId, packet2._name, packet2.length()].join(",")})`
          );
          console.log(
            `${this._internalId} ${this.connectionId} <== ${packet2.buffer.toString("hex")}`
          );
        }
        this._bumpSequenceId(1);
        this.write(packet2.buffer);
      } else {
        if (this.config.debug) {
          console.log(
            `${this._internalId} ${this.connectionId} <== Writing large packet, raw content not written:`
          );
          console.log(
            `${this._internalId} ${this.connectionId} <== ${this._command._commandName}#${this._command.stateName()}(${[this.sequenceId, packet2._name, packet2.length()].join(",")})`
          );
        }
        for (offset = 4; offset < 4 + length; offset += MAX_PACKET_LENGTH) {
          chunk = packet2.buffer.slice(offset, offset + MAX_PACKET_LENGTH);
          if (chunk.length === MAX_PACKET_LENGTH) {
            header = Buffer.from([255, 255, 255, this.sequenceId]);
          } else {
            header = Buffer.from([
              chunk.length & 255,
              chunk.length >> 8 & 255,
              chunk.length >> 16 & 255,
              this.sequenceId
            ]);
          }
          this._bumpSequenceId(1);
          this.write(header);
          this.write(chunk);
        }
      }
    }
    // 0.11+ environment
    startTLS(onSecure) {
      if (this.config.debug) {
        console.log("Upgrading connection to TLS");
      }
      const secureContext = Tls.createSecureContext({
        ca: this.config.ssl.ca,
        cert: this.config.ssl.cert,
        ciphers: this.config.ssl.ciphers,
        key: this.config.ssl.key,
        passphrase: this.config.ssl.passphrase,
        minVersion: this.config.ssl.minVersion,
        maxVersion: this.config.ssl.maxVersion
      });
      const rejectUnauthorized = this.config.ssl.rejectUnauthorized;
      const verifyIdentity = this.config.ssl.verifyIdentity;
      const servername = Net.isIP(this.config.host) ? void 0 : this.config.host;
      let secureEstablished = false;
      this.stream.removeAllListeners("data");
      const secureSocket = Tls.connect(
        {
          rejectUnauthorized,
          requestCert: rejectUnauthorized,
          checkServerIdentity: verifyIdentity ? Tls.checkServerIdentity : function() {
            return void 0;
          },
          secureContext,
          isServer: false,
          socket: this.stream,
          servername
        },
        () => {
          secureEstablished = true;
          if (rejectUnauthorized) {
            if (typeof servername === "string" && verifyIdentity) {
              const cert = secureSocket.getPeerCertificate(true);
              const serverIdentityCheckError = Tls.checkServerIdentity(
                servername,
                cert
              );
              if (serverIdentityCheckError) {
                onSecure(serverIdentityCheckError);
                return;
              }
            }
          }
          onSecure();
        }
      );
      secureSocket.on("error", (err) => {
        if (secureEstablished) {
          this._handleNetworkError(err);
        } else {
          onSecure(err);
        }
      });
      secureSocket.on("data", (data) => {
        this.packetParser.execute(data);
      });
      this.stream = secureSocket;
    }
    protocolError(message, code) {
      if (this._closing) {
        return;
      }
      const err = new Error(message);
      err.fatal = true;
      err.code = code || "PROTOCOL_ERROR";
      this.emit("error", err);
    }
    get state() {
      if (this._fatalError || this._protocolError) {
        return "error";
      }
      if (this._closing || this.stream && this.stream.destroyed) {
        return "disconnected";
      }
      if (this.authorized) {
        return "authenticated";
      }
      if (this._handshakePacket) {
        return "connected";
      }
      if (this.stream && !this.stream.destroyed) {
        return "protocol_handshake";
      }
      return "disconnected";
    }
    get fatalError() {
      return this._fatalError;
    }
    handlePacket(packet2) {
      if (this._paused) {
        this._paused_packets.push(packet2);
        return;
      }
      if (this.config.debug) {
        if (packet2) {
          console.log(
            ` raw: ${packet2.buffer.slice(packet2.offset, packet2.offset + packet2.length()).toString("hex")}`
          );
          console.trace();
          const commandName = this._command ? this._command._commandName : "(no command)";
          const stateName = this._command ? this._command.stateName() : "(no command)";
          console.log(
            `${this._internalId} ${this.connectionId} ==> ${commandName}#${stateName}(${[packet2.sequenceId, packet2.type(), packet2.length()].join(",")})`
          );
        }
      }
      if (!this._command) {
        const marker = packet2.peekByte();
        if (marker === 255) {
          const error2 = Packets.Error.fromPacket(packet2);
          this.protocolError(error2.message, error2.code);
        } else {
          this.protocolError(
            "Unexpected packet while no commands in the queue",
            "PROTOCOL_UNEXPECTED_PACKET"
          );
        }
        this.close();
        return;
      }
      if (packet2) {
        if (this.sequenceId !== packet2.sequenceId) {
          const err = new Error(
            `Warning: got packets out of order. Expected ${this.sequenceId} but received ${packet2.sequenceId}`
          );
          err.expected = this.sequenceId;
          err.received = packet2.sequenceId;
          this.emit("warn", err);
          console.error(err.message);
        }
        this._bumpSequenceId(packet2.numPackets);
      }
      try {
        if (this._fatalError) {
          return;
        }
        const done = this._command.execute(packet2, this);
        if (done) {
          this._command = this._commands.shift();
          if (this._command) {
            this.sequenceId = 0;
            this.compressedSequenceId = 0;
            this.handlePacket();
          }
        }
      } catch (err) {
        this._handleFatalError(err);
        this.stream.destroy();
      }
    }
    addCommand(cmd) {
      if (this.config.debug) {
        const commandName = cmd.constructor.name;
        console.log(`Add command: ${commandName}`);
        cmd._commandName = commandName;
      }
      if (!this._command) {
        this._command = cmd;
        this.handlePacket();
      } else {
        this._commands.push(cmd);
      }
      return cmd;
    }
    format(sql, values) {
      if (typeof this.config.queryFormat === "function") {
        return this.config.queryFormat.call(
          this,
          sql,
          values,
          this.config.timezone
        );
      }
      const opts = {
        sql,
        values
      };
      this._resolveNamedPlaceholders(opts);
      return SqlString2.format(
        opts.sql,
        opts.values,
        this.config.stringifyObjects,
        this.config.timezone
      );
    }
    escape(value) {
      return SqlString2.escape(value, false, this.config.timezone);
    }
    escapeId(value) {
      return SqlString2.escapeId(value, false);
    }
    raw(sql) {
      return SqlString2.raw(sql);
    }
    _resolveNamedPlaceholders(options) {
      let unnamed;
      if (this.config.namedPlaceholders || options.namedPlaceholders) {
        if (Array.isArray(options.values)) {
          return;
        }
        if (convertNamedPlaceholders === null) {
          convertNamedPlaceholders = requireNamedPlaceholders()();
        }
        unnamed = convertNamedPlaceholders(options.sql, options.values);
        options.sql = unnamed[0];
        options.values = unnamed[1];
      }
    }
    query(sql, values, cb) {
      let cmdQuery;
      if (sql.constructor === Commands.Query) {
        cmdQuery = sql;
      } else {
        cmdQuery = BaseConnection.createQuery(sql, values, cb, this.config);
      }
      this._resolveNamedPlaceholders(cmdQuery);
      const rawSql = this.format(
        cmdQuery.sql,
        cmdQuery.values !== void 0 ? cmdQuery.values : []
      );
      cmdQuery.sql = rawSql;
      return this.addCommand(cmdQuery);
    }
    pause() {
      this._paused = true;
      this.stream.pause();
    }
    resume() {
      let packet2;
      this._paused = false;
      while (packet2 = this._paused_packets.shift()) {
        this.handlePacket(packet2);
        if (this._paused) {
          return;
        }
      }
      this.stream.resume();
    }
    // TODO: named placeholders support
    prepare(options, cb) {
      if (typeof options === "string") {
        options = { sql: options };
      }
      return this.addCommand(new Commands.Prepare(options, cb));
    }
    unprepare(sql) {
      let options = {};
      if (typeof sql === "object") {
        options = sql;
      } else {
        options.sql = sql;
      }
      const key = BaseConnection.statementKey(options);
      const stmt = this._statements.get(key);
      if (stmt) {
        this._statements.delete(key);
        stmt.close();
      }
      return stmt;
    }
    execute(sql, values, cb) {
      let options = {
        infileStreamFactory: this.config.infileStreamFactory
      };
      if (typeof sql === "object") {
        options = {
          ...options,
          ...sql,
          sql: sql.sql,
          values: sql.values
        };
        if (typeof values === "function") {
          cb = values;
        } else {
          options.values = options.values || values;
        }
      } else if (typeof values === "function") {
        cb = values;
        options.sql = sql;
        options.values = void 0;
      } else {
        options.sql = sql;
        options.values = values;
      }
      this._resolveNamedPlaceholders(options);
      if (options.values) {
        if (!Array.isArray(options.values)) {
          throw new TypeError(
            "Bind parameters must be array if namedPlaceholders parameter is not enabled"
          );
        }
        options.values.forEach((val) => {
          if (!Array.isArray(options.values)) {
            throw new TypeError(
              "Bind parameters must be array if namedPlaceholders parameter is not enabled"
            );
          }
          if (val === void 0) {
            throw new TypeError(
              "Bind parameters must not contain undefined. To pass SQL NULL specify JS null"
            );
          }
          if (typeof val === "function") {
            throw new TypeError(
              "Bind parameters must not contain function(s). To pass the body of a function as a string call .toString() first"
            );
          }
        });
      }
      const executeCommand = new Commands.Execute(options, cb);
      const prepareCommand = new Commands.Prepare(options, (err, stmt) => {
        if (err) {
          executeCommand.start = function() {
            return null;
          };
          if (cb) {
            cb(err);
          } else {
            executeCommand.emit("error", err);
          }
          executeCommand.emit("end");
          return;
        }
        executeCommand.statement = stmt;
      });
      this.addCommand(prepareCommand);
      this.addCommand(executeCommand);
      return executeCommand;
    }
    changeUser(options, callback) {
      if (!callback && typeof options === "function") {
        callback = options;
        options = {};
      }
      const charsetNumber = options.charset ? ConnectionConfig.getCharsetNumber(options.charset) : this.config.charsetNumber;
      return this.addCommand(
        new Commands.ChangeUser(
          {
            user: options.user || this.config.user,
            // for the purpose of multi-factor authentication, or not, the main
            // password (used for the 1st authentication factor) can also be
            // provided via the "password1" option
            password: options.password || options.password1 || this.config.password || this.config.password1,
            password2: options.password2 || this.config.password2,
            password3: options.password3 || this.config.password3,
            passwordSha1: options.passwordSha1 || this.config.passwordSha1,
            database: options.database || this.config.database,
            timeout: options.timeout,
            charsetNumber,
            currentConfig: this.config
          },
          (err) => {
            if (err) {
              err.fatal = true;
            }
            if (callback) {
              callback(err);
            }
          }
        )
      );
    }
    // transaction helpers
    beginTransaction(cb) {
      return this.query("START TRANSACTION", cb);
    }
    commit(cb) {
      return this.query("COMMIT", cb);
    }
    rollback(cb) {
      return this.query("ROLLBACK", cb);
    }
    ping(cb) {
      return this.addCommand(new Commands.Ping(cb));
    }
    _registerSlave(opts, cb) {
      return this.addCommand(new Commands.RegisterSlave(opts, cb));
    }
    _binlogDump(opts, cb) {
      return this.addCommand(new Commands.BinlogDump(opts, cb));
    }
    // currently just alias to close
    destroy() {
      this.close();
    }
    close() {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      }
      this._closing = true;
      this.stream.end();
      this.addCommand = this._addCommandClosedState;
    }
    createBinlogStream(opts) {
      let test = 1;
      const stream = new Readable({ objectMode: true });
      stream._read = function() {
        return {
          data: test++
        };
      };
      this._registerSlave(opts, () => {
        const dumpCmd = this._binlogDump(opts);
        dumpCmd.on("event", (ev) => {
          stream.push(ev);
        });
        dumpCmd.on("eof", () => {
          stream.push(null);
          if (opts.flags && opts.flags & 1) {
            this.close();
          }
        });
      });
      return stream;
    }
    connect(cb) {
      if (!cb) {
        return;
      }
      if (this._fatalError || this._protocolError) {
        return cb(this._fatalError || this._protocolError);
      }
      if (this._handshakePacket) {
        return cb(null, this);
      }
      let connectCalled = 0;
      function callbackOnce(isErrorHandler) {
        return function(param) {
          if (!connectCalled) {
            if (isErrorHandler) {
              cb(param);
            } else {
              cb(null, param);
            }
          }
          connectCalled = 1;
        };
      }
      this.once("error", callbackOnce(true));
      this.once("connect", callbackOnce(false));
    }
    // ===================================
    // outgoing server connection methods
    // ===================================
    writeColumns(columns) {
      this.writePacket(Packets.ResultSetHeader.toPacket(columns.length));
      columns.forEach((column) => {
        this.writePacket(
          Packets.ColumnDefinition.toPacket(column, this.serverConfig.encoding)
        );
      });
      this.writeEof();
    }
    // row is array of columns, not hash
    writeTextRow(column) {
      this.writePacket(
        Packets.TextRow.toPacket(column, this.serverConfig.encoding)
      );
    }
    writeBinaryRow(column) {
      this.writePacket(
        Packets.BinaryRow.toPacket(column, this.serverConfig.encoding)
      );
    }
    writeTextResult(rows, columns, binary2 = false) {
      this.writeColumns(columns);
      rows.forEach((row) => {
        const arrayRow = new Array(columns.length);
        columns.forEach((column) => {
          arrayRow.push(row[column.name]);
        });
        if (binary2) {
          this.writeBinaryRow(arrayRow);
        } else this.writeTextRow(arrayRow);
      });
      this.writeEof();
    }
    writeEof(warnings, statusFlags) {
      this.writePacket(Packets.EOF.toPacket(warnings, statusFlags));
    }
    writeOk(args) {
      if (!args) {
        args = { affectedRows: 0 };
      }
      this.writePacket(Packets.OK.toPacket(args, this.serverConfig.encoding));
    }
    writeError(args) {
      const encoding = this.serverConfig ? this.serverConfig.encoding : "cesu8";
      this.writePacket(Packets.Error.toPacket(args, encoding));
    }
    serverHandshake(args) {
      this.serverConfig = args;
      this.serverConfig.encoding = CharsetToEncoding[this.serverConfig.characterSet];
      return this.addCommand(new Commands.ServerHandshake(args));
    }
    // ===============================================================
    end(callback) {
      if (this.config.isServer) {
        this._closing = true;
        const quitCmd2 = new EventEmitter();
        setImmediate(() => {
          this.stream.end();
          quitCmd2.emit("end");
        });
        return quitCmd2;
      }
      const quitCmd = this.addCommand(new Commands.Quit(callback));
      this.addCommand = this._addCommandClosedState;
      return quitCmd;
    }
    static createQuery(sql, values, cb, config) {
      let options = {
        rowsAsArray: config.rowsAsArray,
        infileStreamFactory: config.infileStreamFactory
      };
      if (typeof sql === "object") {
        options = {
          ...options,
          ...sql,
          sql: sql.sql,
          values: sql.values
        };
        if (typeof values === "function") {
          cb = values;
        } else if (values !== void 0) {
          options.values = values;
        }
      } else if (typeof values === "function") {
        cb = values;
        options.sql = sql;
        options.values = void 0;
      } else {
        options.sql = sql;
        options.values = values;
      }
      return new Commands.Query(options, cb);
    }
    static statementKey(options) {
      return `${typeof options.nestTables}/${options.nestTables}/${options.rowsAsArray}${options.sql}`;
    }
  }
  connection$2 = BaseConnection;
  return connection$2;
}
var pool_connection$2;
var hasRequiredPool_connection$2;
function requirePool_connection$2() {
  if (hasRequiredPool_connection$2) return pool_connection$2;
  hasRequiredPool_connection$2 = 1;
  const BaseConnection = requireConnection$2();
  class BasePoolConnection extends BaseConnection {
    constructor(pool2, options) {
      super(options);
      this._pool = pool2;
      this.lastActiveTime = Date.now();
      this.once("end", () => {
        this._removeFromPool();
      });
      this.once("error", () => {
        this._removeFromPool();
      });
    }
    release() {
      if (!this._pool || this._pool._closed) {
        return;
      }
      this.lastActiveTime = Date.now();
      this._pool.releaseConnection(this);
    }
    end() {
      if (this.config.gracefulEnd) {
        this._removeFromPool();
        super.end();
        return;
      }
      const err = new Error(
        "Calling conn.end() to release a pooled connection is deprecated. In next version calling conn.end() will be restored to default conn.end() behavior. Use conn.release() instead."
      );
      this.emit("warn", err);
      console.warn(err.message);
      this.release();
    }
    destroy() {
      this._removeFromPool();
      super.destroy();
    }
    _removeFromPool() {
      if (!this._pool || this._pool._closed) {
        return;
      }
      const pool2 = this._pool;
      this._pool = null;
      pool2._removeConnection(this);
    }
  }
  BasePoolConnection.statementKey = BaseConnection.statementKey;
  pool_connection$2 = BasePoolConnection;
  BasePoolConnection.prototype._realEnd = BaseConnection.prototype.end;
  return pool_connection$2;
}
var make_done_cb;
var hasRequiredMake_done_cb;
function requireMake_done_cb() {
  if (hasRequiredMake_done_cb) return make_done_cb;
  hasRequiredMake_done_cb = 1;
  function makeDoneCb(resolve, reject, localErr) {
    return function(err, rows, fields) {
      if (err) {
        localErr.message = err.message;
        localErr.code = err.code;
        localErr.errno = err.errno;
        localErr.sql = err.sql;
        localErr.sqlState = err.sqlState;
        localErr.sqlMessage = err.sqlMessage;
        reject(localErr);
      } else {
        resolve([rows, fields]);
      }
    };
  }
  make_done_cb = makeDoneCb;
  return make_done_cb;
}
var prepared_statement_info;
var hasRequiredPrepared_statement_info;
function requirePrepared_statement_info() {
  if (hasRequiredPrepared_statement_info) return prepared_statement_info;
  hasRequiredPrepared_statement_info = 1;
  const makeDoneCb = requireMake_done_cb();
  class PromisePreparedStatementInfo {
    constructor(statement, promiseImpl) {
      this.statement = statement;
      this.Promise = promiseImpl;
    }
    execute(parameters) {
      const s = this.statement;
      const localErr = new Error();
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        if (parameters) {
          s.execute(parameters, done);
        } else {
          s.execute(done);
        }
      });
    }
    close() {
      return new this.Promise((resolve) => {
        this.statement.close();
        resolve();
      });
    }
  }
  prepared_statement_info = PromisePreparedStatementInfo;
  return prepared_statement_info;
}
var inherit_events;
var hasRequiredInherit_events;
function requireInherit_events() {
  if (hasRequiredInherit_events) return inherit_events;
  hasRequiredInherit_events = 1;
  function inheritEvents(source, target, events) {
    const listeners = {};
    target.on("newListener", (eventName) => {
      if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {
        source.on(
          eventName,
          listeners[eventName] = function() {
            const args = [].slice.call(arguments);
            args.unshift(eventName);
            target.emit.apply(target, args);
          }
        );
      }
    }).on("removeListener", (eventName) => {
      if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {
        source.removeListener(eventName, listeners[eventName]);
        delete listeners[eventName];
      }
    });
  }
  inherit_events = inheritEvents;
  return inherit_events;
}
var connection$1;
var hasRequiredConnection$1;
function requireConnection$1() {
  if (hasRequiredConnection$1) return connection$1;
  hasRequiredConnection$1 = 1;
  const EventEmitter = require$$0$3.EventEmitter;
  const PromisePreparedStatementInfo = requirePrepared_statement_info();
  const makeDoneCb = requireMake_done_cb();
  const inheritEvents = requireInherit_events();
  const BaseConnection = requireConnection$2();
  class PromiseConnection extends EventEmitter {
    constructor(connection2, promiseImpl) {
      super();
      this.connection = connection2;
      this.Promise = promiseImpl || Promise;
      inheritEvents(connection2, this, [
        "error",
        "drain",
        "connect",
        "end",
        "enqueue"
      ]);
    }
    release() {
      this.connection.release();
    }
    query(query2, params) {
      const c = this.connection;
      const localErr = new Error();
      if (typeof params === "function") {
        throw new Error(
          "Callback function is not available with promise clients."
        );
      }
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        if (params !== void 0) {
          c.query(query2, params, done);
        } else {
          c.query(query2, done);
        }
      });
    }
    execute(query2, params) {
      const c = this.connection;
      const localErr = new Error();
      if (typeof params === "function") {
        throw new Error(
          "Callback function is not available with promise clients."
        );
      }
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        if (params !== void 0) {
          c.execute(query2, params, done);
        } else {
          c.execute(query2, done);
        }
      });
    }
    end() {
      return new this.Promise((resolve) => {
        this.connection.end(resolve);
      });
    }
    beginTransaction() {
      const c = this.connection;
      const localErr = new Error();
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        c.beginTransaction(done);
      });
    }
    commit() {
      const c = this.connection;
      const localErr = new Error();
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        c.commit(done);
      });
    }
    rollback() {
      const c = this.connection;
      const localErr = new Error();
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        c.rollback(done);
      });
    }
    ping() {
      const c = this.connection;
      const localErr = new Error();
      return new this.Promise((resolve, reject) => {
        c.ping((err) => {
          if (err) {
            localErr.message = err.message;
            localErr.code = err.code;
            localErr.errno = err.errno;
            localErr.sqlState = err.sqlState;
            localErr.sqlMessage = err.sqlMessage;
            reject(localErr);
          } else {
            resolve(true);
          }
        });
      });
    }
    connect() {
      const c = this.connection;
      const localErr = new Error();
      return new this.Promise((resolve, reject) => {
        c.connect((err, param) => {
          if (err) {
            localErr.message = err.message;
            localErr.code = err.code;
            localErr.errno = err.errno;
            localErr.sqlState = err.sqlState;
            localErr.sqlMessage = err.sqlMessage;
            reject(localErr);
          } else {
            resolve(param);
          }
        });
      });
    }
    prepare(options) {
      const c = this.connection;
      const promiseImpl = this.Promise;
      const localErr = new Error();
      return new this.Promise((resolve, reject) => {
        c.prepare(options, (err, statement) => {
          if (err) {
            localErr.message = err.message;
            localErr.code = err.code;
            localErr.errno = err.errno;
            localErr.sqlState = err.sqlState;
            localErr.sqlMessage = err.sqlMessage;
            reject(localErr);
          } else {
            const wrappedStatement = new PromisePreparedStatementInfo(
              statement,
              promiseImpl
            );
            resolve(wrappedStatement);
          }
        });
      });
    }
    changeUser(options) {
      const c = this.connection;
      const localErr = new Error();
      return new this.Promise((resolve, reject) => {
        c.changeUser(options, (err) => {
          if (err) {
            localErr.message = err.message;
            localErr.code = err.code;
            localErr.errno = err.errno;
            localErr.sqlState = err.sqlState;
            localErr.sqlMessage = err.sqlMessage;
            reject(localErr);
          } else {
            resolve();
          }
        });
      });
    }
    get config() {
      return this.connection.config;
    }
    get threadId() {
      return this.connection.threadId;
    }
  }
  (function(functionsToWrap) {
    for (let i = 0; functionsToWrap && i < functionsToWrap.length; i++) {
      const func = functionsToWrap[i];
      if (typeof BaseConnection.prototype[func] === "function" && PromiseConnection.prototype[func] === void 0) {
        PromiseConnection.prototype[func] = /* @__PURE__ */ (function factory(funcName) {
          return function() {
            return BaseConnection.prototype[funcName].apply(
              this.connection,
              arguments
            );
          };
        })(func);
      }
    }
  })([
    // synchronous functions
    "close",
    "createBinlogStream",
    "destroy",
    "escape",
    "escapeId",
    "format",
    "pause",
    "pipe",
    "resume",
    "unprepare"
  ]);
  connection$1 = PromiseConnection;
  return connection$1;
}
var pool_connection$1;
var hasRequiredPool_connection$1;
function requirePool_connection$1() {
  if (hasRequiredPool_connection$1) return pool_connection$1;
  hasRequiredPool_connection$1 = 1;
  const PromiseConnection = requireConnection$1();
  const BasePoolConnection = requirePool_connection$2();
  class PromisePoolConnection extends PromiseConnection {
    constructor(connection2, promiseImpl) {
      super(connection2, promiseImpl);
    }
    destroy() {
      return BasePoolConnection.prototype.destroy.apply(
        this.connection,
        arguments
      );
    }
  }
  pool_connection$1 = PromisePoolConnection;
  return pool_connection$1;
}
var pool_connection;
var hasRequiredPool_connection;
function requirePool_connection() {
  if (hasRequiredPool_connection) return pool_connection;
  hasRequiredPool_connection = 1;
  const BasePoolConnection = requirePool_connection$2();
  class PoolConnection extends BasePoolConnection {
    promise(promiseImpl) {
      const PromisePoolConnection = requirePool_connection$1();
      return new PromisePoolConnection(this, promiseImpl);
    }
  }
  pool_connection = PoolConnection;
  return pool_connection;
}
var pool$2;
var hasRequiredPool$2;
function requirePool$2() {
  if (hasRequiredPool$2) return pool$2;
  hasRequiredPool$2 = 1;
  const process2 = require$$0$6;
  const SqlString2 = requireSqlstring();
  const EventEmitter = require$$0$3.EventEmitter;
  const PoolConnection = requirePool_connection();
  const Queue = requireDenque();
  const BaseConnection = requireConnection$2();
  function spliceConnection(queue, connection2) {
    const len = queue.length;
    for (let i = 0; i < len; i++) {
      if (queue.get(i) === connection2) {
        queue.removeOne(i);
        break;
      }
    }
  }
  class BasePool extends EventEmitter {
    constructor(options) {
      super();
      this.config = options.config;
      this.config.connectionConfig.pool = this;
      this._allConnections = new Queue();
      this._freeConnections = new Queue();
      this._connectionQueue = new Queue();
      this._closed = false;
      if (this.config.maxIdle < this.config.connectionLimit) {
        this._removeIdleTimeoutConnections();
      }
    }
    getConnection(cb) {
      if (this._closed) {
        return process2.nextTick(() => cb(new Error("Pool is closed.")));
      }
      let connection2;
      if (this._freeConnections.length > 0) {
        connection2 = this._freeConnections.pop();
        this.emit("acquire", connection2);
        return process2.nextTick(() => cb(null, connection2));
      }
      if (this.config.connectionLimit === 0 || this._allConnections.length < this.config.connectionLimit) {
        connection2 = new PoolConnection(this, {
          config: this.config.connectionConfig
        });
        this._allConnections.push(connection2);
        return connection2.connect((err) => {
          if (this._closed) {
            return cb(new Error("Pool is closed."));
          }
          if (err) {
            return cb(err);
          }
          this.emit("connection", connection2);
          this.emit("acquire", connection2);
          return cb(null, connection2);
        });
      }
      if (!this.config.waitForConnections) {
        return process2.nextTick(() => cb(new Error("No connections available.")));
      }
      if (this.config.queueLimit && this._connectionQueue.length >= this.config.queueLimit) {
        return cb(new Error("Queue limit reached."));
      }
      this.emit("enqueue");
      return this._connectionQueue.push(cb);
    }
    releaseConnection(connection2) {
      let cb;
      if (!connection2._pool) {
        if (this._connectionQueue.length) {
          cb = this._connectionQueue.shift();
          process2.nextTick(this.getConnection.bind(this, cb));
        }
      } else if (this._connectionQueue.length) {
        cb = this._connectionQueue.shift();
        process2.nextTick(cb.bind(null, null, connection2));
      } else {
        this._freeConnections.push(connection2);
        this.emit("release", connection2);
      }
    }
    end(cb) {
      this._closed = true;
      clearTimeout(this._removeIdleTimeoutConnectionsTimer);
      if (typeof cb !== "function") {
        cb = function(err) {
          if (err) {
            throw err;
          }
        };
      }
      let calledBack = false;
      let closedConnections = 0;
      let connection2;
      const endCB = (function(err) {
        if (calledBack) {
          return;
        }
        if (err || ++closedConnections >= this._allConnections.length) {
          calledBack = true;
          cb(err);
          return;
        }
      }).bind(this);
      if (this._allConnections.length === 0) {
        endCB();
        return;
      }
      for (let i = 0; i < this._allConnections.length; i++) {
        connection2 = this._allConnections.get(i);
        connection2._realEnd(endCB);
      }
    }
    query(sql, values, cb) {
      const cmdQuery = BaseConnection.createQuery(
        sql,
        values,
        cb,
        this.config.connectionConfig
      );
      if (typeof cmdQuery.namedPlaceholders === "undefined") {
        cmdQuery.namedPlaceholders = this.config.connectionConfig.namedPlaceholders;
      }
      this.getConnection((err, conn) => {
        if (err) {
          if (typeof cmdQuery.onResult === "function") {
            cmdQuery.onResult(err);
          } else {
            cmdQuery.emit("error", err);
          }
          return;
        }
        try {
          conn.query(cmdQuery).once("end", () => {
            conn.release();
          });
        } catch (e) {
          conn.release();
          throw e;
        }
      });
      return cmdQuery;
    }
    execute(sql, values, cb) {
      if (typeof values === "function") {
        cb = values;
        values = [];
      }
      this.getConnection((err, conn) => {
        if (err) {
          return cb(err);
        }
        try {
          conn.execute(sql, values, cb).once("end", () => {
            conn.release();
          });
        } catch (e) {
          conn.release();
          return cb(e);
        }
      });
    }
    _removeConnection(connection2) {
      spliceConnection(this._allConnections, connection2);
      spliceConnection(this._freeConnections, connection2);
      this.releaseConnection(connection2);
    }
    _removeIdleTimeoutConnections() {
      if (this._removeIdleTimeoutConnectionsTimer) {
        clearTimeout(this._removeIdleTimeoutConnectionsTimer);
      }
      this._removeIdleTimeoutConnectionsTimer = setTimeout(() => {
        try {
          while (this._freeConnections.length > this.config.maxIdle || this._freeConnections.length > 0 && Date.now() - this._freeConnections.get(0).lastActiveTime > this.config.idleTimeout) {
            if (this.config.connectionConfig.gracefulEnd) {
              this._freeConnections.get(0).end();
            } else {
              this._freeConnections.get(0).destroy();
            }
          }
        } finally {
          this._removeIdleTimeoutConnections();
        }
      }, 1e3);
    }
    format(sql, values) {
      return SqlString2.format(
        sql,
        values,
        this.config.connectionConfig.stringifyObjects,
        this.config.connectionConfig.timezone
      );
    }
    escape(value) {
      return SqlString2.escape(
        value,
        this.config.connectionConfig.stringifyObjects,
        this.config.connectionConfig.timezone
      );
    }
    escapeId(value) {
      return SqlString2.escapeId(value, false);
    }
  }
  pool$2 = BasePool;
  return pool$2;
}
var pool$1;
var hasRequiredPool$1;
function requirePool$1() {
  if (hasRequiredPool$1) return pool$1;
  hasRequiredPool$1 = 1;
  const EventEmitter = require$$0$3.EventEmitter;
  const makeDoneCb = requireMake_done_cb();
  const PromisePoolConnection = requirePool_connection$1();
  const inheritEvents = requireInherit_events();
  const BasePool = requirePool$2();
  class PromisePool extends EventEmitter {
    constructor(pool2, thePromise) {
      super();
      this.pool = pool2;
      this.Promise = thePromise || Promise;
      inheritEvents(pool2, this, ["acquire", "connection", "enqueue", "release"]);
    }
    getConnection() {
      const corePool = this.pool;
      return new this.Promise((resolve, reject) => {
        corePool.getConnection((err, coreConnection) => {
          if (err) {
            reject(err);
          } else {
            resolve(new PromisePoolConnection(coreConnection, this.Promise));
          }
        });
      });
    }
    releaseConnection(connection2) {
      if (connection2 instanceof PromisePoolConnection) connection2.release();
    }
    query(sql, args) {
      const corePool = this.pool;
      const localErr = new Error();
      if (typeof args === "function") {
        throw new Error(
          "Callback function is not available with promise clients."
        );
      }
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        if (args !== void 0) {
          corePool.query(sql, args, done);
        } else {
          corePool.query(sql, done);
        }
      });
    }
    execute(sql, args) {
      const corePool = this.pool;
      const localErr = new Error();
      if (typeof args === "function") {
        throw new Error(
          "Callback function is not available with promise clients."
        );
      }
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        if (args) {
          corePool.execute(sql, args, done);
        } else {
          corePool.execute(sql, done);
        }
      });
    }
    end() {
      const corePool = this.pool;
      const localErr = new Error();
      return new this.Promise((resolve, reject) => {
        corePool.end((err) => {
          if (err) {
            localErr.message = err.message;
            localErr.code = err.code;
            localErr.errno = err.errno;
            localErr.sqlState = err.sqlState;
            localErr.sqlMessage = err.sqlMessage;
            reject(localErr);
          } else {
            resolve();
          }
        });
      });
    }
  }
  (function(functionsToWrap) {
    for (let i = 0; functionsToWrap && i < functionsToWrap.length; i++) {
      const func = functionsToWrap[i];
      if (typeof BasePool.prototype[func] === "function" && PromisePool.prototype[func] === void 0) {
        PromisePool.prototype[func] = /* @__PURE__ */ (function factory(funcName) {
          return function() {
            return BasePool.prototype[funcName].apply(this.pool, arguments);
          };
        })(func);
      }
    }
  })([
    // synchronous functions
    "escape",
    "escapeId",
    "format"
  ]);
  pool$1 = PromisePool;
  return pool$1;
}
var pool;
var hasRequiredPool;
function requirePool() {
  if (hasRequiredPool) return pool;
  hasRequiredPool = 1;
  const BasePool = requirePool$2();
  class Pool extends BasePool {
    promise(promiseImpl) {
      const PromisePool = requirePool$1();
      return new PromisePool(this, promiseImpl);
    }
  }
  pool = Pool;
  return pool;
}
var pool_config;
var hasRequiredPool_config;
function requirePool_config() {
  if (hasRequiredPool_config) return pool_config;
  hasRequiredPool_config = 1;
  const ConnectionConfig = requireConnection_config();
  class PoolConfig {
    constructor(options) {
      if (typeof options === "string") {
        options = ConnectionConfig.parseUrl(options);
      }
      this.connectionConfig = new ConnectionConfig(options);
      this.waitForConnections = options.waitForConnections === void 0 ? true : Boolean(options.waitForConnections);
      this.connectionLimit = isNaN(options.connectionLimit) ? 10 : Number(options.connectionLimit);
      this.maxIdle = isNaN(options.maxIdle) ? this.connectionLimit : Number(options.maxIdle);
      this.idleTimeout = isNaN(options.idleTimeout) ? 6e4 : Number(options.idleTimeout);
      this.queueLimit = isNaN(options.queueLimit) ? 0 : Number(options.queueLimit);
    }
  }
  pool_config = PoolConfig;
  return pool_config;
}
var connection;
var hasRequiredConnection;
function requireConnection() {
  if (hasRequiredConnection) return connection;
  hasRequiredConnection = 1;
  const BaseConnection = requireConnection$2();
  class Connection extends BaseConnection {
    promise(promiseImpl) {
      const PromiseConnection = requireConnection$1();
      return new PromiseConnection(this, promiseImpl);
    }
  }
  connection = Connection;
  return connection;
}
var pool_cluster$1;
var hasRequiredPool_cluster$1;
function requirePool_cluster$1() {
  if (hasRequiredPool_cluster$1) return pool_cluster$1;
  hasRequiredPool_cluster$1 = 1;
  const process2 = require$$0$6;
  const Pool = requirePool();
  const PoolConfig = requirePool_config();
  const Connection = requireConnection();
  const EventEmitter = require$$0$3.EventEmitter;
  const makeSelector = {
    RR() {
      let index = 0;
      return (clusterIds) => clusterIds[index++ % clusterIds.length];
    },
    RANDOM() {
      return (clusterIds) => clusterIds[Math.floor(Math.random() * clusterIds.length)];
    },
    ORDER() {
      return (clusterIds) => clusterIds[0];
    }
  };
  const getMonotonicMilliseconds = function() {
    let ms2;
    if (typeof process2.hrtime === "function") {
      ms2 = process2.hrtime();
      ms2 = ms2[0] * 1e3 + ms2[1] * 1e-6;
    } else {
      ms2 = process2.uptime() * 1e3;
    }
    return Math.floor(ms2);
  };
  const patternRegExp = function(pattern) {
    if (pattern instanceof RegExp) {
      return pattern;
    }
    const source = pattern.replace(/([.+?^=!:${}()|[\]/\\])/g, "\\$1").replace(/\*/g, ".*");
    return new RegExp(`^${source}$`);
  };
  class PoolNamespace {
    constructor(cluster, pattern, selector) {
      this._cluster = cluster;
      this._pattern = pattern;
      this._selector = makeSelector[selector]();
    }
    getConnection(cb) {
      const clusterNode = this._getClusterNode();
      if (clusterNode === null) {
        let err = new Error("Pool does Not exist.");
        err.code = "POOL_NOEXIST";
        if (this._cluster._findNodeIds(this._pattern, true).length !== 0) {
          err = new Error("Pool does Not have online node.");
          err.code = "POOL_NONEONLINE";
        }
        return cb(err);
      }
      return this._cluster._getConnection(clusterNode, (err, connection2) => {
        if (err) {
          if (this._cluster._canRetry && this._cluster._findNodeIds(this._pattern).length !== 0) {
            this._cluster.emit("warn", err);
            return this.getConnection(cb);
          }
          return cb(err);
        }
        return cb(null, connection2);
      });
    }
    /**
     * pool cluster query
     * @param {*} sql
     * @param {*} values
     * @param {*} cb
     * @returns query
     */
    query(sql, values, cb) {
      const query2 = Connection.createQuery(sql, values, cb, {});
      this.getConnection((err, conn) => {
        if (err) {
          if (typeof query2.onResult === "function") {
            query2.onResult(err);
          } else {
            query2.emit("error", err);
          }
          return;
        }
        try {
          conn.query(query2).once("end", () => {
            conn.release();
          });
        } catch (e) {
          conn.release();
          throw e;
        }
      });
      return query2;
    }
    /**
     * pool cluster execute
     * @param {*} sql
     * @param {*} values
     * @param {*} cb
     */
    execute(sql, values, cb) {
      if (typeof values === "function") {
        cb = values;
        values = [];
      }
      this.getConnection((err, conn) => {
        if (err) {
          return cb(err);
        }
        try {
          conn.execute(sql, values, cb).once("end", () => {
            conn.release();
          });
        } catch (e) {
          conn.release();
          throw e;
        }
      });
    }
    _getClusterNode() {
      const foundNodeIds = this._cluster._findNodeIds(this._pattern);
      if (foundNodeIds.length === 0) {
        return null;
      }
      const nodeId = foundNodeIds.length === 1 ? foundNodeIds[0] : this._selector(foundNodeIds);
      return this._cluster._getNode(nodeId);
    }
  }
  class PoolCluster extends EventEmitter {
    constructor(config) {
      super();
      config = config || {};
      this._canRetry = typeof config.canRetry === "undefined" ? true : config.canRetry;
      this._removeNodeErrorCount = config.removeNodeErrorCount || 5;
      this._restoreNodeTimeout = config.restoreNodeTimeout || 0;
      this._defaultSelector = config.defaultSelector || "RR";
      this._closed = false;
      this._lastId = 0;
      this._nodes = {};
      this._serviceableNodeIds = [];
      this._namespaces = {};
      this._findCaches = {};
    }
    of(pattern, selector) {
      pattern = pattern || "*";
      selector = selector || this._defaultSelector;
      selector = selector.toUpperCase();
      if (!makeSelector[selector] === "undefined") {
        selector = this._defaultSelector;
      }
      const key = pattern + selector;
      if (typeof this._namespaces[key] === "undefined") {
        this._namespaces[key] = new PoolNamespace(this, pattern, selector);
      }
      return this._namespaces[key];
    }
    add(id, config) {
      if (typeof id === "object") {
        config = id;
        id = `CLUSTER::${++this._lastId}`;
      }
      if (typeof this._nodes[id] === "undefined") {
        this._nodes[id] = {
          id,
          errorCount: 0,
          pool: new Pool({ config: new PoolConfig(config) }),
          _offlineUntil: 0
        };
        this._serviceableNodeIds.push(id);
        this._clearFindCaches();
      }
    }
    remove(pattern) {
      const foundNodeIds = this._findNodeIds(pattern, true);
      for (let i = 0; i < foundNodeIds.length; i++) {
        const node2 = this._getNode(foundNodeIds[i]);
        if (node2) {
          this._removeNode(node2);
        }
      }
    }
    getConnection(pattern, selector, cb) {
      let namespace;
      if (typeof pattern === "function") {
        cb = pattern;
        namespace = this.of();
      } else {
        if (typeof selector === "function") {
          cb = selector;
          selector = this._defaultSelector;
        }
        namespace = this.of(pattern, selector);
      }
      namespace.getConnection(cb);
    }
    end(callback) {
      const cb = callback !== void 0 ? callback : (err) => {
        if (err) {
          throw err;
        }
      };
      if (this._closed) {
        process2.nextTick(cb);
        return;
      }
      this._closed = true;
      let calledBack = false;
      let waitingClose = 0;
      const onEnd = (err) => {
        if (!calledBack && (err || --waitingClose <= 0)) {
          calledBack = true;
          return cb(err);
        }
      };
      for (const id in this._nodes) {
        waitingClose++;
        this._nodes[id].pool.end(onEnd);
      }
      if (waitingClose === 0) {
        process2.nextTick(onEnd);
      }
    }
    _findNodeIds(pattern, includeOffline) {
      let currentTime = 0;
      let foundNodeIds = this._findCaches[pattern];
      if (foundNodeIds === void 0) {
        const expression = patternRegExp(pattern);
        foundNodeIds = this._serviceableNodeIds.filter(
          (id) => id.match(expression)
        );
      }
      this._findCaches[pattern] = foundNodeIds;
      if (includeOffline) {
        return foundNodeIds;
      }
      return foundNodeIds.filter((nodeId) => {
        const node2 = this._getNode(nodeId);
        if (!node2._offlineUntil) {
          return true;
        }
        if (!currentTime) {
          currentTime = getMonotonicMilliseconds();
        }
        return node2._offlineUntil <= currentTime;
      });
    }
    _getNode(id) {
      return this._nodes[id] || null;
    }
    _increaseErrorCount(node2) {
      const errorCount = ++node2.errorCount;
      if (this._removeNodeErrorCount > errorCount) {
        return;
      }
      if (this._restoreNodeTimeout > 0) {
        node2._offlineUntil = getMonotonicMilliseconds() + this._restoreNodeTimeout;
        this.emit("offline", node2.id);
        return;
      }
      this._removeNode(node2);
      this.emit("remove", node2.id);
    }
    _decreaseErrorCount(node2) {
      let errorCount = node2.errorCount;
      if (errorCount > this._removeNodeErrorCount) {
        errorCount = this._removeNodeErrorCount;
      }
      if (errorCount < 1) {
        errorCount = 1;
      }
      node2.errorCount = errorCount - 1;
      if (node2._offlineUntil) {
        node2._offlineUntil = 0;
        this.emit("online", node2.id);
      }
    }
    _getConnection(node2, cb) {
      node2.pool.getConnection((err, connection2) => {
        if (err) {
          this._increaseErrorCount(node2);
          return cb(err);
        }
        this._decreaseErrorCount(node2);
        connection2._clusterId = node2.id;
        return cb(null, connection2);
      });
    }
    _removeNode(node2) {
      const index = this._serviceableNodeIds.indexOf(node2.id);
      if (index !== -1) {
        this._serviceableNodeIds.splice(index, 1);
        delete this._nodes[node2.id];
        this._clearFindCaches();
        node2.pool.end();
      }
    }
    _clearFindCaches() {
      this._findCaches = {};
    }
  }
  pool_cluster$1 = PoolCluster;
  return pool_cluster$1;
}
var create_connection;
var hasRequiredCreate_connection;
function requireCreate_connection() {
  if (hasRequiredCreate_connection) return create_connection;
  hasRequiredCreate_connection = 1;
  const Connection = requireConnection();
  const ConnectionConfig = requireConnection_config();
  function createConnection(opts) {
    return new Connection({ config: new ConnectionConfig(opts) });
  }
  create_connection = createConnection;
  return create_connection;
}
var create_pool;
var hasRequiredCreate_pool;
function requireCreate_pool() {
  if (hasRequiredCreate_pool) return create_pool;
  hasRequiredCreate_pool = 1;
  const Pool = requirePool();
  const PoolConfig = requirePool_config();
  function createPool(config) {
    return new Pool({ config: new PoolConfig(config) });
  }
  create_pool = createPool;
  return create_pool;
}
var create_pool_cluster;
var hasRequiredCreate_pool_cluster;
function requireCreate_pool_cluster() {
  if (hasRequiredCreate_pool_cluster) return create_pool_cluster;
  hasRequiredCreate_pool_cluster = 1;
  const PoolCluster = requirePool_cluster$1();
  function createPoolCluster(config) {
    return new PoolCluster(config);
  }
  create_pool_cluster = createPoolCluster;
  return create_pool_cluster;
}
var pool_cluster;
var hasRequiredPool_cluster;
function requirePool_cluster() {
  if (hasRequiredPool_cluster) return pool_cluster;
  hasRequiredPool_cluster = 1;
  const PromisePoolConnection = requirePool_connection$1();
  const makeDoneCb = requireMake_done_cb();
  class PromisePoolNamespace {
    constructor(poolNamespace, thePromise) {
      this.poolNamespace = poolNamespace;
      this.Promise = thePromise || Promise;
    }
    getConnection() {
      const corePoolNamespace = this.poolNamespace;
      return new this.Promise((resolve, reject) => {
        corePoolNamespace.getConnection((err, coreConnection) => {
          if (err) {
            reject(err);
          } else {
            resolve(new PromisePoolConnection(coreConnection, this.Promise));
          }
        });
      });
    }
    query(sql, values) {
      const corePoolNamespace = this.poolNamespace;
      const localErr = new Error();
      if (typeof values === "function") {
        throw new Error(
          "Callback function is not available with promise clients."
        );
      }
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        corePoolNamespace.query(sql, values, done);
      });
    }
    execute(sql, values) {
      const corePoolNamespace = this.poolNamespace;
      const localErr = new Error();
      if (typeof values === "function") {
        throw new Error(
          "Callback function is not available with promise clients."
        );
      }
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        corePoolNamespace.execute(sql, values, done);
      });
    }
  }
  pool_cluster = PromisePoolNamespace;
  return pool_cluster;
}
var hasRequiredPromise;
function requirePromise() {
  if (hasRequiredPromise) return promise;
  hasRequiredPromise = 1;
  (function(exports$1) {
    const SqlString2 = requireSqlstring();
    const EventEmitter = require$$0$3.EventEmitter;
    const parserCache = requireParser_cache();
    const PoolCluster = requirePool_cluster$1();
    const createConnection = requireCreate_connection();
    const createPool = requireCreate_pool();
    const createPoolCluster = requireCreate_pool_cluster();
    const PromiseConnection = requireConnection$1();
    const PromisePool = requirePool$1();
    const makeDoneCb = requireMake_done_cb();
    const PromisePoolConnection = requirePool_connection$1();
    const inheritEvents = requireInherit_events();
    const PromisePoolNamespace = requirePool_cluster();
    function createConnectionPromise(opts) {
      const coreConnection = createConnection(opts);
      const createConnectionErr = new Error();
      const thePromise = opts.Promise || Promise;
      if (!thePromise) {
        throw new Error(
          "no Promise implementation available.Use promise-enabled node version or pass userland Promise implementation as parameter, for example: { Promise: require('bluebird') }"
        );
      }
      return new thePromise((resolve, reject) => {
        coreConnection.once("connect", () => {
          resolve(new PromiseConnection(coreConnection, thePromise));
        });
        coreConnection.once("error", (err) => {
          createConnectionErr.message = err.message;
          createConnectionErr.code = err.code;
          createConnectionErr.errno = err.errno;
          createConnectionErr.sqlState = err.sqlState;
          reject(createConnectionErr);
        });
      });
    }
    function createPromisePool(opts) {
      const corePool = createPool(opts);
      const thePromise = opts.Promise || Promise;
      if (!thePromise) {
        throw new Error(
          "no Promise implementation available.Use promise-enabled node version or pass userland Promise implementation as parameter, for example: { Promise: require('bluebird') }"
        );
      }
      return new PromisePool(corePool, thePromise);
    }
    class PromisePoolCluster extends EventEmitter {
      constructor(poolCluster, thePromise) {
        super();
        this.poolCluster = poolCluster;
        this.Promise = thePromise || Promise;
        inheritEvents(poolCluster, this, ["warn", "remove", "online", "offline"]);
      }
      getConnection(pattern, selector) {
        const corePoolCluster = this.poolCluster;
        return new this.Promise((resolve, reject) => {
          corePoolCluster.getConnection(
            pattern,
            selector,
            (err, coreConnection) => {
              if (err) {
                reject(err);
              } else {
                resolve(new PromisePoolConnection(coreConnection, this.Promise));
              }
            }
          );
        });
      }
      query(sql, args) {
        const corePoolCluster = this.poolCluster;
        const localErr = new Error();
        if (typeof args === "function") {
          throw new Error(
            "Callback function is not available with promise clients."
          );
        }
        return new this.Promise((resolve, reject) => {
          const done = makeDoneCb(resolve, reject, localErr);
          corePoolCluster.query(sql, args, done);
        });
      }
      execute(sql, args) {
        const corePoolCluster = this.poolCluster;
        const localErr = new Error();
        if (typeof args === "function") {
          throw new Error(
            "Callback function is not available with promise clients."
          );
        }
        return new this.Promise((resolve, reject) => {
          const done = makeDoneCb(resolve, reject, localErr);
          corePoolCluster.execute(sql, args, done);
        });
      }
      of(pattern, selector) {
        return new PromisePoolNamespace(
          this.poolCluster.of(pattern, selector),
          this.Promise
        );
      }
      end() {
        const corePoolCluster = this.poolCluster;
        const localErr = new Error();
        return new this.Promise((resolve, reject) => {
          corePoolCluster.end((err) => {
            if (err) {
              localErr.message = err.message;
              localErr.code = err.code;
              localErr.errno = err.errno;
              localErr.sqlState = err.sqlState;
              localErr.sqlMessage = err.sqlMessage;
              reject(localErr);
            } else {
              resolve();
            }
          });
        });
      }
    }
    (function(functionsToWrap) {
      for (let i = 0; functionsToWrap && i < functionsToWrap.length; i++) {
        const func = functionsToWrap[i];
        if (typeof PoolCluster.prototype[func] === "function" && PromisePoolCluster.prototype[func] === void 0) {
          PromisePoolCluster.prototype[func] = /* @__PURE__ */ (function factory(funcName) {
            return function() {
              return PoolCluster.prototype[funcName].apply(
                this.poolCluster,
                arguments
              );
            };
          })(func);
        }
      }
    })(["add", "remove"]);
    function createPromisePoolCluster(opts) {
      const corePoolCluster = createPoolCluster(opts);
      const thePromise = opts && opts.Promise || Promise;
      if (!thePromise) {
        throw new Error(
          "no Promise implementation available.Use promise-enabled node version or pass userland Promise implementation as parameter, for example: { Promise: require('bluebird') }"
        );
      }
      return new PromisePoolCluster(corePoolCluster, thePromise);
    }
    exports$1.createConnection = createConnectionPromise;
    exports$1.createPool = createPromisePool;
    exports$1.createPoolCluster = createPromisePoolCluster;
    exports$1.escape = SqlString2.escape;
    exports$1.escapeId = SqlString2.escapeId;
    exports$1.format = SqlString2.format;
    exports$1.raw = SqlString2.raw;
    exports$1.PromisePool = PromisePool;
    exports$1.PromiseConnection = PromiseConnection;
    exports$1.PromisePoolConnection = PromisePoolConnection;
    exports$1.__defineGetter__("Types", () => requireTypes());
    exports$1.__defineGetter__(
      "Charsets",
      () => requireCharsets()
    );
    exports$1.__defineGetter__(
      "CharsetToEncoding",
      () => requireCharset_encodings()
    );
    exports$1.setMaxParserCache = function(max) {
      parserCache.setMaxCache(max);
    };
    exports$1.clearParserCache = function() {
      parserCache.clearCache();
    };
  })(promise);
  return promise;
}
var promiseExports = requirePromise();
const mysql = /* @__PURE__ */ getDefaultExportFromCjs(promiseExports);
const require$1 = module$1.createRequire(typeof document === "undefined" ? require("url").pathToFileURL(__filename).href : _documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === "SCRIPT" && _documentCurrentScript.src || new URL("index.js", document.baseURI).href);
const sqlite3 = require$1("sqlite3");
const { Client } = pg;
class SQLiteDriver {
  constructor(config) {
    this.config = config;
  }
  db = null;
  async connect() {
    return new Promise((resolve, reject) => {
      this.db = new sqlite3.Database(this.config.database, (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }
  async disconnect() {
    return new Promise((resolve, reject) => {
      this.db?.close((err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }
  async getDatabases() {
    return ["main"];
  }
  async useDatabase(dbName) {
  }
  async getTables() {
    if (!this.db) throw new Error("Not connected");
    return new Promise((resolve, reject) => {
      this.db.all("SELECT name FROM sqlite_master WHERE type='table'", (err, rows) => {
        if (err) reject(err);
        else resolve(rows);
      });
    });
  }
  async getTableColumns(tableName) {
    if (!this.db) throw new Error("Not connected");
    return new Promise((resolve, reject) => {
      this.db.all(`PRAGMA table_info(${tableName})`, (err, rows) => {
        if (err) reject(err);
        else {
          this.db.all(`SELECT name, sql FROM sqlite_master WHERE type='table' AND name='${tableName}'`, (err2, masterRows) => {
            const tableSql = masterRows[0]?.sql || "";
            resolve(rows.map((c) => ({
              name: c.name,
              type: c.type,
              nullable: c.notnull === 0,
              primaryKey: c.pk === 1,
              defaultValue: c.dflt_value,
              autoIncrement: tableSql.toUpperCase().includes("AUTOINCREMENT") && c.pk === 1
            })));
          });
        }
      });
    });
  }
  async getTableIndexes(tableName) {
    if (!this.db) throw new Error("Not connected");
    return new Promise((resolve, reject) => {
      this.db.all(`PRAGMA index_list(${tableName})`, (err, rows) => {
        if (err) reject(err);
        else {
          const indexes = [];
          const promises = rows.map((row) => {
            return new Promise((res, rej) => {
              this.db.all(`PRAGMA index_info(${row.name})`, (err2, infoRows) => {
                if (err2) rej(err2);
                else {
                  indexes.push({
                    name: row.name,
                    unique: row.unique === 1,
                    columns: infoRows.map((ir) => ir.name)
                  });
                  res();
                }
              });
            });
          });
          Promise.all(promises).then(() => resolve(indexes)).catch(reject);
        }
      });
    });
  }
  async getTableData(tableName, limit = 100, offset = 0, orderBy, orderDir = "ASC") {
    if (!this.db) throw new Error("Not connected");
    return new Promise((resolve, reject) => {
      this.db.get(`SELECT COUNT(*) as count FROM ${tableName}`, (err, countRow) => {
        if (err) return reject(err);
        let sql = `SELECT * FROM ${tableName}`;
        if (orderBy) {
          sql += ` ORDER BY ${orderBy} ${orderDir}`;
        }
        sql += ` LIMIT ${limit} OFFSET ${offset}`;
        this.db.all(sql, (err2, rows) => {
          if (err2) reject(err2);
          else resolve({ data: rows, total: countRow.count });
        });
      });
    });
  }
  async renameTable(oldName, newName) {
    if (!this.db) throw new Error("Not connected");
    return new Promise((resolve, reject) => {
      this.db.run(`ALTER TABLE ${oldName} RENAME TO ${newName}`, (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }
  async deleteTable(tableName) {
    if (!this.db) throw new Error("Not connected");
    return new Promise((resolve, reject) => {
      this.db.run(`DROP TABLE ${tableName}`, (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }
  async createTable(tableName, columns, indexes) {
    if (!this.db) throw new Error("Not connected");
    const colDefs = columns.map((c) => {
      let def = `${c.name} ${c.type}`;
      if (c.primaryKey) def += " PRIMARY KEY";
      if (c.autoIncrement) def += " AUTOINCREMENT";
      if (!c.nullable) def += " NOT NULL";
      if (c.defaultValue !== void 0 && c.defaultValue !== null) {
        def += ` DEFAULT ${typeof c.defaultValue === "string" ? `'${c.defaultValue}'` : c.defaultValue}`;
      }
      return def;
    }).join(", ");
    const sql = `CREATE TABLE ${tableName} (${colDefs})`;
    return new Promise(async (resolve, reject) => {
      this.db.serialize(async () => {
        this.db.run(sql, async (err) => {
          if (err) return reject(err);
          if (indexes && indexes.length > 0) {
            try {
              for (const idx of indexes) {
                const unique = idx.unique ? "UNIQUE" : "";
                const idxSql = `CREATE ${unique} INDEX ${idx.name} ON ${tableName} (${idx.columns.join(", ")})`;
                await new Promise((res, rej) => this.db.run(idxSql, (e) => e ? rej(e) : res()));
              }
              resolve();
            } catch (e) {
              reject(e);
            }
          } else {
            resolve();
          }
        });
      });
    });
  }
  async updateTableSchema(tableName, changes) {
    if (!this.db) throw new Error("Not connected");
    return new Promise(async (resolve, reject) => {
      try {
        for (const col of changes.added) {
          const sql = `ALTER TABLE ${tableName} ADD COLUMN ${col.name} ${col.type} ${col.nullable ? "" : "NOT NULL"} ${col.defaultValue !== void 0 ? `DEFAULT ${col.defaultValue}` : ""}`;
          await new Promise((res, rej) => this.db.run(sql, (err) => err ? rej(err) : res()));
        }
        if (changes.modified.length > 0 || changes.removed.length > 0) {
          for (const mod of changes.modified) {
            if (mod.oldName !== mod.column.name) {
              await new Promise((res, rej) => this.db.run(`ALTER TABLE ${tableName} RENAME COLUMN ${mod.oldName} TO ${mod.column.name}`, (err) => err ? rej(err) : res()));
            }
          }
          for (const colName of changes.removed) {
            await new Promise((res, rej) => this.db.run(`ALTER TABLE ${tableName} DROP COLUMN ${colName}`, (err) => err ? rej(err) : res()));
          }
        }
        if (changes.indexes) {
          for (const idxName of changes.indexes.removed) {
            await new Promise((res, rej) => this.db.run(`DROP INDEX IF EXISTS ${idxName}`, (err) => err ? rej(err) : res()));
          }
          for (const idx of changes.indexes.added) {
            const unique = idx.unique ? "UNIQUE" : "";
            const sql = `CREATE ${unique} INDEX ${idx.name} ON ${tableName} (${idx.columns.join(", ")})`;
            await new Promise((res, rej) => this.db.run(sql, (err) => err ? rej(err) : res()));
          }
        }
        resolve();
      } catch (err) {
        reject(err);
      }
    });
  }
  async exportDatabase(includeData) {
    if (!this.db) throw new Error("Not connected");
    const tables = await this.getTables();
    let sqlOutput = `-- AiSqlBoy SQLite Export
-- Date: ${(/* @__PURE__ */ new Date()).toLocaleString()}

PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;

`;
    for (const table of tables) {
      await this.getTableColumns(table.name);
      const createSql = await new Promise((res, rej) => {
        this.db.get(`SELECT sql FROM sqlite_master WHERE type='table' AND name='${table.name}'`, (err, row) => err ? rej(err) : res(row));
      });
      sqlOutput += `${createSql.sql};

`;
      if (includeData) {
        const data = await new Promise((res, rej) => {
          this.db.all(`SELECT * FROM ${table.name}`, (err, rows) => err ? rej(err) : res(rows));
        });
        for (const row of data) {
          const keys = Object.keys(row);
          const values = keys.map((k) => {
            const v = row[k];
            if (v === null) return "NULL";
            if (typeof v === "string") return `'${v.replace(/'/g, "''")}'`;
            return v;
          });
          sqlOutput += `INSERT INTO ${table.name} (${keys.join(", ")}) VALUES (${values.join(", ")});
`;
        }
        sqlOutput += "\n";
      }
    }
    sqlOutput += `COMMIT;`;
    return sqlOutput;
  }
  async deleteDatabase(dbName) {
    throw new Error("SQLite ");
  }
  async executeQuery(sql) {
    if (!this.db) throw new Error("Not connected");
    return new Promise((resolve, reject) => {
      const isSelect = sql.trim().toUpperCase().startsWith("SELECT") || sql.trim().toUpperCase().startsWith("PRAGMA") || sql.trim().toUpperCase().startsWith("SHOW") || sql.trim().toUpperCase().startsWith("EXPLAIN");
      if (isSelect) {
        this.db.all(sql, (err, rows) => {
          if (err) reject(err);
          else {
            const columns = rows.length > 0 ? Object.keys(rows[0]) : [];
            resolve({ data: rows, columns });
          }
        });
      } else {
        this.db.run(sql, function(err) {
          if (err) reject(err);
          else {
            resolve({
              data: [{
                : "",
                : this.changes,
                ID: this.lastID
              }],
              columns: ["", "", "ID"]
            });
          }
        });
      }
    });
  }
  async ping() {
    if (!this.db) return;
    return new Promise((resolve, reject) => {
      this.db.get("SELECT 1", (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }
}
class MySQLDriver {
  constructor(config) {
    this.config = config;
  }
  connection = null;
  async connect() {
    this.connection = await mysql.createConnection({
      host: this.config.host,
      port: this.config.port,
      user: this.config.user,
      password: this.config.password,
      database: this.config.database,
      // 
      multipleStatements: true
      //  SQL 
    });
  }
  async disconnect() {
    await this.connection?.end();
  }
  async getDatabases() {
    if (!this.connection) throw new Error("Not connected");
    const [rows] = await this.connection.query("SHOW DATABASES");
    return rows.map((row) => Object.values(row)[0]);
  }
  async useDatabase(dbName) {
    if (!this.connection) throw new Error("Not connected");
    await this.connection.query(`USE ${dbName}`);
  }
  async getTables() {
    if (!this.connection) throw new Error("Not connected");
    const [rows] = await this.connection.query("SHOW TABLES");
    return rows.map((row) => ({
      name: Object.values(row)[0]
    }));
  }
  async getTableColumns(tableName) {
    if (!this.connection) throw new Error("Not connected");
    const [rows] = await this.connection.query(`SHOW FULL COLUMNS FROM ${tableName}`);
    return rows.map((row) => ({
      name: row.Field,
      type: row.Type,
      nullable: row.Null === "YES",
      primaryKey: row.Key === "PRI",
      defaultValue: row.Default,
      autoIncrement: row.Extra.includes("auto_increment"),
      comment: row.Comment
    }));
  }
  async getTableIndexes(tableName) {
    if (!this.connection) throw new Error("Not connected");
    const [rows] = await this.connection.query(`SHOW INDEX FROM ${tableName}`);
    const indexMap = /* @__PURE__ */ new Map();
    for (const row of rows) {
      const name = row.Key_name;
      if (!indexMap.has(name)) {
        indexMap.set(name, {
          name,
          unique: row.Non_unique === 0,
          columns: [],
          type: row.Index_type
        });
      }
      indexMap.get(name).columns.push(row.Column_name);
    }
    return Array.from(indexMap.values());
  }
  async getTableData(tableName, limit = 100, offset = 0, orderBy, orderDir = "ASC") {
    if (!this.connection) throw new Error("Not connected");
    const [[{ total }]] = await this.connection.query(`SELECT COUNT(*) as total FROM ${tableName}`);
    let sql = `SELECT * FROM ${tableName}`;
    if (orderBy) {
      sql += ` ORDER BY ${orderBy} ${orderDir}`;
    }
    sql += ` LIMIT ${limit} OFFSET ${offset}`;
    const [rows] = await this.connection.query(sql);
    return { data: rows, total };
  }
  async renameTable(oldName, newName) {
    if (!this.connection) throw new Error("Not connected");
    await this.connection.query(`RENAME TABLE ${oldName} TO ${newName}`);
  }
  async deleteTable(tableName) {
    if (!this.connection) throw new Error("Not connected");
    await this.connection.query(`DROP TABLE ${tableName}`);
  }
  async createTable(tableName, columns, indexes) {
    if (!this.connection) throw new Error("Not connected");
    const colDefs = columns.map((c) => {
      let def = `${c.name} ${c.type}`;
      if (!c.nullable) def += " NOT NULL";
      if (c.defaultValue !== void 0 && c.defaultValue !== null) {
        def += ` DEFAULT '${c.defaultValue}'`;
      }
      if (c.autoIncrement) def += " AUTO_INCREMENT";
      if (c.primaryKey) def += " PRIMARY KEY";
      if (c.comment) def += ` COMMENT '${c.comment}'`;
      return def;
    });
    if (indexes && indexes.length > 0) {
      for (const idx of indexes) {
        const unique = idx.unique ? "UNIQUE" : "";
        const type2 = idx.type ? `USING ${idx.type}` : "";
        colDefs.push(`${unique} INDEX ${idx.name} (${idx.columns.join(", ")}) ${type2}`);
      }
    }
    const sql = `CREATE TABLE ${tableName} (${colDefs.join(", ")})`;
    await this.connection.query(sql);
  }
  async updateTableSchema(tableName, changes) {
    if (!this.connection) throw new Error("Not connected");
    const sqlParts = [];
    for (const colName of changes.removed) {
      sqlParts.push(`DROP COLUMN ${colName}`);
    }
    for (const mod of changes.modified) {
      const col = mod.column;
      const definition = `${col.name} ${col.type} ${col.nullable ? "NULL" : "NOT NULL"} ${col.defaultValue !== null && col.defaultValue !== void 0 ? `DEFAULT '${col.defaultValue}'` : ""} ${col.autoIncrement ? "AUTO_INCREMENT" : ""} ${col.comment ? `COMMENT '${col.comment}'` : ""}`;
      if (mod.oldName !== col.name) {
        sqlParts.push(`CHANGE COLUMN ${mod.oldName} ${definition}`);
      } else {
        sqlParts.push(`MODIFY COLUMN ${definition}`);
      }
    }
    for (const col of changes.added) {
      const definition = `${col.name} ${col.type} ${col.nullable ? "NULL" : "NOT NULL"} ${col.defaultValue !== null && col.defaultValue !== void 0 ? `DEFAULT '${col.defaultValue}'` : ""} ${col.autoIncrement ? "AUTO_INCREMENT" : ""} ${col.comment ? `COMMENT '${col.comment}'` : ""}`;
      sqlParts.push(`ADD COLUMN ${definition}`);
    }
    if (changes.indexes) {
      for (const idxName of changes.indexes.removed) {
        if (idxName === "PRIMARY") {
          sqlParts.push(`DROP PRIMARY KEY`);
        } else {
          sqlParts.push(`DROP INDEX ${idxName}`);
        }
      }
      for (const idx of changes.indexes.added) {
        const unique = idx.unique ? "UNIQUE" : "";
        const type2 = idx.type ? `USING ${idx.type}` : "";
        sqlParts.push(`ADD ${unique} INDEX ${idx.name} (${idx.columns.join(", ")}) ${type2}`);
      }
    }
    if (sqlParts.length > 0) {
      const sql = `ALTER TABLE ${tableName} ${sqlParts.join(", ")}`;
      await this.connection.query(sql);
    }
  }
  async exportDatabase(includeData) {
    if (!this.connection) throw new Error("Not connected");
    const tables = await this.getTables();
    let sqlOutput = `-- AiSqlBoy MySQL Export
-- Date: ${(/* @__PURE__ */ new Date()).toLocaleString()}

SET FOREIGN_KEY_CHECKS=0;

`;
    for (const table of tables) {
      const [createRes] = await this.connection.query(`SHOW CREATE TABLE ${table.name}`);
      sqlOutput += `${createRes[0]["Create Table"]};

`;
      if (includeData) {
        const [rows] = await this.connection.query(`SELECT * FROM ${table.name}`);
        for (const row of rows) {
          const keys = Object.keys(row);
          const values = keys.map((k) => {
            const v = row[k];
            if (v === null) return "NULL";
            if (typeof v === "string") return `'${v.replace(/'/g, "''")}'`;
            if (v instanceof Date) return `'${v.toISOString().slice(0, 19).replace("T", " ")}'`;
            return v;
          });
          sqlOutput += `INSERT INTO ${table.name} (${keys.join(", ")}) VALUES (${values.join(", ")});
`;
        }
        sqlOutput += "\n";
      }
    }
    sqlOutput += `SET FOREIGN_KEY_CHECKS=1;`;
    return sqlOutput;
  }
  async deleteDatabase(dbName) {
    if (!this.connection) throw new Error("Not connected");
    await this.connection.query(`DROP DATABASE ${dbName}`);
  }
  processResults(results, fields) {
    if (Array.isArray(results) && (fields === void 0 || Array.isArray(fields))) {
      const isMulti = results.length > 0 && (results[0]?.constructor?.name === "ResultSetHeader" || results[0]?.constructor?.name === "OkPacket" || Array.isArray(results[0]));
      if (isMulti) {
        const allData = [];
        const multiResults = results;
        const multiFields = Array.isArray(fields) ? fields : [];
        multiResults.forEach((res, index) => {
          const f = multiFields[index];
          if (!f || !Array.isArray(f)) {
            allData.push({
              : index + 1,
              : "",
              : res.affectedRows !== void 0 ? res.affectedRows : res.length || 0,
              : res.info || res.message || ""
            });
          } else {
            allData.push({
              : index + 1,
              : ` ${res.length} `,
              : " SELECT "
            });
          }
        });
        return {
          data: allData,
          columns: allData.length > 0 ? Object.keys(allData[0]) : [""]
        };
      }
    }
    if (!fields || Array.isArray(fields) && fields.length === 0) {
      const header = results;
      return {
        data: [{
          : "",
          : header.affectedRows || 0,
          ID: header.insertId || 0,
          : header.info || header.message || ""
        }],
        columns: ["", "", "ID", ""]
      };
    }
    const fieldArray = Array.isArray(fields) ? fields : [];
    const columns = fieldArray.map((f) => f && typeof f === "object" ? f.name : "") || [];
    return { data: Array.isArray(results) ? results : [], columns };
  }
  async executeQuery(sql) {
    if (!this.connection) throw new Error("Not connected");
    try {
      const [results, fields] = await this.connection.query(sql);
      return this.processResults(results, fields);
    } catch (error2) {
      const isConnectionError = error2.code === "PROTOCOL_CONNECTION_LOST" || error2.code === "ECONNRESET" || error2.code === "PROTOCOL_ENQUEUE_AFTER_FATAL_ERROR" || error2.message.includes("closed") || error2.message.includes("connection lost");
      if (isConnectionError) {
        try {
          await this.connect();
          const [results, fields] = await this.connection.query(sql);
          return this.processResults(results, fields);
        } catch (reconnectError) {
          throw new Error(`: ${reconnectError.message}`);
        }
      }
      throw error2;
    }
  }
  async ping() {
    if (!this.connection) return;
    try {
      await this.connection.query("SELECT 1");
    } catch (error2) {
      await this.connect();
    }
  }
}
class PostgreSQLDriver {
  constructor(config) {
    this.config = config;
  }
  client = null;
  async connect() {
    this.client = new Client({
      host: this.config.host,
      port: this.config.port,
      user: this.config.user,
      password: this.config.password,
      database: this.config.database
    });
    await this.client.connect();
  }
  async disconnect() {
    await this.client?.end();
  }
  async getDatabases() {
    if (!this.client) throw new Error("Not connected");
    const res = await this.client.query("SELECT datname FROM pg_database WHERE datistemplate = false");
    return res.rows.map((row) => row.datname);
  }
  async useDatabase(dbName) {
    if (this.config.database === dbName) return;
    await this.disconnect();
    this.config.database = dbName;
    await this.connect();
  }
  async getTables() {
    if (!this.client) throw new Error("Not connected");
    const res = await this.client.query("SELECT tablename as name FROM pg_catalog.pg_tables WHERE schemaname != 'pg_catalog' AND schemaname != 'information_schema'");
    return res.rows;
  }
  async getTableColumns(tableName) {
    if (!this.client) throw new Error("Not connected");
    const res = await this.client.query(`
      SELECT 
        column_name as name, 
        data_type as type, 
        is_nullable as nullable, 
        column_default as "defaultValue"
      FROM information_schema.columns 
      WHERE table_name = $1
    `, [tableName]);
    const pkRes = await this.client.query(`
      SELECT a.attname
      FROM pg_index i
      JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey)
      WHERE i.indrelid = $1::regclass AND i.indisprimary;
    `, [tableName]);
    const pks = new Set(pkRes.rows.map((r) => r.attname));
    return res.rows.map((row) => ({
      name: row.name,
      type: row.type,
      nullable: row.nullable === "YES",
      primaryKey: pks.has(row.name),
      defaultValue: row.defaultValue,
      autoIncrement: row.defaultValue?.includes("nextval")
    }));
  }
  async getTableIndexes(tableName) {
    if (!this.client) throw new Error("Not connected");
    const res = await this.client.query(`
      SELECT
        i.relname as name,
        ix.indisunique as unique,
        a.attname as column_name
      FROM
        pg_class t,
        pg_class i,
        pg_index ix,
        pg_attribute a
      WHERE
        t.oid = ix.indrelid
        AND i.oid = ix.indexrelid
        AND a.attrelid = t.oid
        AND a.attnum = ANY(ix.indkey)
        AND t.relkind = 'r'
        AND t.relname = $1
    `, [tableName]);
    const indexMap = /* @__PURE__ */ new Map();
    for (const row of res.rows) {
      if (!indexMap.has(row.name)) {
        indexMap.set(row.name, {
          name: row.name,
          unique: row.unique,
          columns: []
        });
      }
      indexMap.get(row.name).columns.push(row.column_name);
    }
    return Array.from(indexMap.values());
  }
  async getTableData(tableName, limit = 100, offset = 0, orderBy, orderDir = "ASC") {
    if (!this.client) throw new Error("Not connected");
    const countRes = await this.client.query(`SELECT COUNT(*) as total FROM "${tableName}"`);
    const total = parseInt(countRes.rows[0].total);
    let sql = `SELECT * FROM "${tableName}"`;
    if (orderBy) {
      sql += ` ORDER BY "${orderBy}" ${orderDir}`;
    }
    sql += ` LIMIT ${limit} OFFSET ${offset}`;
    const res = await this.client.query(sql);
    return { data: res.rows, total };
  }
  async renameTable(oldName, newName) {
    if (!this.client) throw new Error("Not connected");
    await this.client.query(`ALTER TABLE "${oldName}" RENAME TO "${newName}"`);
  }
  async deleteTable(tableName) {
    if (!this.client) throw new Error("Not connected");
    await this.client.query(`DROP TABLE "${tableName}"`);
  }
  async createTable(tableName, columns, indexes) {
    if (!this.client) throw new Error("Not connected");
    const colDefs = columns.map((c) => {
      let def = `"${c.name}" ${c.type}`;
      if (c.primaryKey) def += " PRIMARY KEY";
      if (!c.nullable) def += " NOT NULL";
      if (c.defaultValue !== void 0 && c.defaultValue !== null) {
        def += ` DEFAULT ${c.defaultValue}`;
      }
      return def;
    });
    const sql = `CREATE TABLE "${tableName}" (${colDefs.join(", ")})`;
    await this.client.query(sql);
    if (indexes && indexes.length > 0) {
      for (const idx of indexes) {
        const unique = idx.unique ? "UNIQUE" : "";
        const idxSql = `CREATE ${unique} INDEX "${idx.name}" ON "${tableName}" (${idx.columns.map((c) => `"${c}"`).join(", ")})`;
        await this.client.query(idxSql);
      }
    }
  }
  async updateTableSchema(tableName, changes) {
    if (!this.client) throw new Error("Not connected");
    for (const col of changes.removed) {
      await this.client.query(`ALTER TABLE "${tableName}" DROP COLUMN "${col}"`);
    }
    for (const mod of changes.modified) {
      if (mod.oldName !== mod.column.name) {
        await this.client.query(`ALTER TABLE "${tableName}" RENAME COLUMN "${mod.oldName}" TO "${mod.column.name}"`);
      }
    }
    for (const col of changes.added) {
      await this.client.query(`ALTER TABLE "${tableName}" ADD COLUMN "${col.name}" ${col.type} ${col.nullable ? "" : "NOT NULL"}`);
    }
  }
  async exportDatabase(includeData) {
    if (!this.client) throw new Error("Not connected");
    const tables = await this.getTables();
    let sqlOutput = `-- AiSqlBoy PostgreSQL Export
-- Date: ${(/* @__PURE__ */ new Date()).toLocaleString()}

`;
    for (const table of tables) {
      const cols = await this.getTableColumns(table.name);
      const colDefs = cols.map((c) => `"${c.name}" ${c.type} ${c.nullable ? "" : "NOT NULL"}`).join(", ");
      sqlOutput += `CREATE TABLE "${table.name}" (${colDefs});

`;
      if (includeData) {
        const res = await this.client.query(`SELECT * FROM "${table.name}"`);
        for (const row of res.rows) {
          const keys = Object.keys(row);
          const values = keys.map((k) => {
            const v = row[k];
            if (v === null) return "NULL";
            if (typeof v === "string") return `'${v.replace(/'/g, "''")}'`;
            return v;
          });
          sqlOutput += `INSERT INTO "${table.name}" (${keys.map((k) => `"${k}"`).join(", ")}) VALUES (${values.join(", ")});
`;
        }
        sqlOutput += "\n";
      }
    }
    return sqlOutput;
  }
  async deleteDatabase(dbName) {
    if (!this.client) throw new Error("Not connected");
    await this.client.query(`DROP DATABASE "${dbName}"`);
  }
  async executeQuery(sql) {
    if (!this.client) throw new Error("Not connected");
    try {
      const res = await this.client.query(sql);
      if (Array.isArray(res)) {
        const lastRes = res[res.length - 1];
        return {
          data: lastRes.rows,
          columns: lastRes.fields?.map((f) => f.name) || []
        };
      }
      if (res.command !== "SELECT" && res.command !== "SHOW") {
        return {
          data: [{
            : "",
            : res.command,
            : res.rowCount || 0
          }],
          columns: ["", "", ""]
        };
      }
      return {
        data: res.rows,
        columns: res.fields?.map((f) => f.name) || []
      };
    } catch (error2) {
      const isConnectionError = error2.message.includes("closed") || error2.message.includes("terminating") || error2.message.includes("connection lost") || error2.code === "ECONNRESET";
      if (isConnectionError) {
        try {
          await this.connect();
          const res = await this.client.query(sql);
          const finalRes = Array.isArray(res) ? res[res.length - 1] : res;
          if (finalRes.command !== "SELECT" && finalRes.command !== "SHOW") {
            return {
              data: [{ : "", : finalRes.command, : finalRes.rowCount || 0 }],
              columns: ["", "", ""]
            };
          }
          return { data: finalRes.rows, columns: finalRes.fields?.map((f) => f.name) || [] };
        } catch (reconnectError) {
          throw new Error(`: ${reconnectError.message}`);
        }
      }
      throw error2;
    }
  }
  async ping() {
    if (!this.client) return;
    try {
      await this.client.query("SELECT 1");
    } catch (error2) {
      await this.connect();
    }
  }
}
class RedisDriver {
  constructor(config) {
    this.config = config;
  }
  client = null;
  async connect() {
    let url = "redis://";
    if (this.config.user) {
      url += `${this.config.user}:${this.config.password || ""}@`;
    } else if (this.config.password) {
      url += `:${this.config.password}@`;
    }
    url += `${this.config.host || "localhost"}:${this.config.port || 6379}`;
    this.client = redis.createClient({ url });
    await this.client.connect();
  }
  async disconnect() {
    await this.client?.quit();
  }
  async getDatabases() {
    return Array.from({ length: 16 }, (_, i) => i.toString());
  }
  async useDatabase(dbName) {
    if (!this.client) throw new Error("Not connected");
    await this.client.select(parseInt(dbName));
  }
  async getTables() {
    if (!this.client) throw new Error("Not connected");
    return [{ name: "Keys" }];
  }
  async getTableColumns(tableName) {
    return [
      { name: "key", type: "string", nullable: false, primaryKey: true },
      { name: "type", type: "string", nullable: false, primaryKey: false },
      { name: "value", type: "string", nullable: true, primaryKey: false },
      { name: "ttl", type: "number", nullable: true, primaryKey: false }
    ];
  }
  async getTableIndexes(tableName) {
    return [];
  }
  async getTableData(tableName, limit = 100, offset = 0, orderBy, orderDir = "ASC") {
    if (!this.client) throw new Error("Not connected");
    const keys = await this.client.keys("*");
    const total = keys.length;
    const pagedKeys = keys.slice(offset, offset + limit);
    const data = await Promise.all(pagedKeys.map(async (key) => {
      const type2 = await this.client.type(key);
      const ttl = await this.client.ttl(key);
      let value = "";
      if (type2 === "string") value = await this.client.get(key);
      else if (type2 === "hash") value = JSON.stringify(await this.client.hGetAll(key));
      else if (type2 === "list") value = JSON.stringify(await this.client.lRange(key, 0, -1));
      else if (type2 === "set") value = JSON.stringify(await this.client.sMembers(key));
      else if (type2 === "zset") value = JSON.stringify(await this.client.zRange(key, 0, -1));
      return { key, type: type2, value, ttl };
    }));
    return { data, total };
  }
  async renameTable(oldName, newName) {
    throw new Error("Redis ");
  }
  async deleteTable(tableName) {
    if (!this.client) throw new Error("Not connected");
    await this.client.del(tableName);
  }
  async createTable(tableName, columns, indexes) {
    throw new Error("Redis ");
  }
  async updateTableSchema(tableName, changes) {
    throw new Error("Redis ");
  }
  async exportDatabase(includeData) {
    if (!this.client) throw new Error("Not connected");
    const keys = await this.client.keys("*");
    let output = `# AiSqlBoy Redis Export
# Date: ${(/* @__PURE__ */ new Date()).toLocaleString()}

`;
    for (const key of keys) {
      const type2 = await this.client.type(key);
      if (type2 === "string") {
        const val = await this.client.get(key);
        output += `SET "${key}" "${val}"
`;
      }
    }
    return output;
  }
  async deleteDatabase(dbName) {
    if (!this.client) throw new Error("Not connected");
    await this.client.flushDb();
  }
  async executeQuery(sql) {
    if (!this.client) throw new Error("Not connected");
    const parseCommand = (cmdStr) => {
      const args2 = [];
      let current = "";
      let inQuotes = false;
      let quoteChar = "";
      for (let i = 0; i < cmdStr.length; i++) {
        const char = cmdStr[i];
        if (inQuotes) {
          if (char === quoteChar) {
            inQuotes = false;
          } else if (char === "\\" && i + 1 < cmdStr.length) {
            current += cmdStr[++i];
          } else {
            current += char;
          }
        } else {
          if (char === '"' || char === "'") {
            inQuotes = true;
            quoteChar = char;
          } else if (/\s/.test(char)) {
            if (current) {
              args2.push(current);
              current = "";
            }
          } else {
            current += char;
          }
        }
      }
      if (current) args2.push(current);
      return args2;
    };
    const args = parseCommand(sql.trim());
    if (args.length === 0) return { data: [], columns: [] };
    try {
      const res = await this.client.sendCommand(args);
      const formatResult = (val) => {
        if (val === null) return "null";
        if (val === void 0) return "undefined";
        if (Array.isArray(val)) {
          return `[${val.map(formatResult).join(", ")}]`;
        }
        if (typeof val === "object") {
          return JSON.stringify(val);
        }
        return val.toString();
      };
      return {
        data: [{ : formatResult(res) }],
        columns: [""]
      };
    } catch (err) {
      const isConnectionError = err.message.includes("closed") || err.message.includes("Socket") || err.message.includes("reconnecting") || err.message.includes("connection lost");
      if (isConnectionError) {
        try {
          await this.connect();
          const res = await this.client.sendCommand(args);
          return {
            data: [{ : res === null ? "null" : typeof res === "object" ? JSON.stringify(res) : res.toString() }],
            columns: [""]
          };
        } catch (reconnectError) {
          throw new Error(`Redis : ${reconnectError.message}`);
        }
      }
      throw new Error(`Redis : ${err.message}`);
    }
  }
  async ping() {
    if (!this.client) return;
    try {
      await this.client.ping();
    } catch (error2) {
      await this.connect();
    }
  }
}
class AIService {
  async getApiKey() {
    return await internalDB.getSetting("deepseek_api_key");
  }
  async chat(messages) {
    const apiKey = await this.getApiKey();
    if (!apiKey) {
      throw new Error(" DeepSeek API Key");
    }
    try {
      const response = await fetch("https://api.deepseek.com/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: "deepseek-chat",
          messages,
          stream: false
        })
      });
      if (!response.ok) {
        const error2 = await response.json();
        throw new Error(error2.message || `: ${response.status}`);
      }
      const data = await response.json();
      return data.choices[0].message.content;
    } catch (error2) {
      console.error("DeepSeek API Error:", error2);
      throw error2;
    }
  }
}
const aiService = new AIService();
mainExports.autoUpdater.autoDownload = false;
mainExports.autoUpdater.autoInstallOnAppQuit = true;
let mainWindow = null;
let currentDriver = null;
let heartbeatTimer = null;
function startHeartbeat() {
  if (heartbeatTimer) clearInterval(heartbeatTimer);
  heartbeatTimer = setInterval(async () => {
    if (currentDriver) {
      try {
        await currentDriver.ping();
      } catch (e) {
        console.log("Heartbeat failed, connection might be lost");
      }
    }
  }, 3e4);
}
function stopHeartbeat() {
  if (heartbeatTimer) {
    clearInterval(heartbeatTimer);
    heartbeatTimer = null;
  }
}
const isDev = !!process.env.VITE_DEV_SERVER_URL;
const DIST_PATH = require$$1$3.join(__dirname, "../..");
if (isDev) {
  mainExports.autoUpdater.forceDevUpdateConfig = true;
}
function createWindow() {
  mainWindow = new require$$1$5.BrowserWindow({
    width: 1200,
    height: 800,
    icon: isDev ? require$$1$3.join(__dirname, "../../src/assets/app.ico") : require$$1$3.join(DIST_PATH, "dist/app.ico"),
    webPreferences: {
      preload: require$$1$3.join(__dirname, "../preload/index.js"),
      nodeIntegration: true,
      contextIsolation: true
    }
  });
  if (process.env.VITE_DEV_SERVER_URL) {
    mainWindow.loadURL(process.env.VITE_DEV_SERVER_URL);
  } else {
    mainWindow.loadFile(require$$1$3.join(DIST_PATH, "dist/index.html"));
  }
}
require$$1$5.app.whenReady().then(() => {
  createWindow();
  require$$1$5.app.on("activate", () => {
    if (require$$1$5.BrowserWindow.getAllWindows().length === 0) createWindow();
  });
  mainExports.autoUpdater.on("checking-for-update", () => {
    mainWindow?.webContents.send("update-message", "...");
  });
  mainExports.autoUpdater.on("update-available", (info) => {
    mainWindow?.webContents.send("update-available", info);
  });
  mainExports.autoUpdater.on("update-not-available", (info) => {
    mainWindow?.webContents.send("update-not-available", info);
  });
  mainExports.autoUpdater.on("error", (err) => {
    mainWindow?.webContents.send("update-error", err.message);
  });
  mainExports.autoUpdater.on("download-progress", (progressObj) => {
    mainWindow?.webContents.send("download-progress", progressObj);
  });
  mainExports.autoUpdater.on("update-downloaded", (info) => {
    mainWindow?.webContents.send("update-downloaded", info);
  });
  mainExports.autoUpdater.checkForUpdatesAndNotify();
});
require$$1$5.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") require$$1$5.app.quit();
});
require$$1$5.ipcMain.handle("check-for-updates", async () => {
  return mainExports.autoUpdater.checkForUpdates();
});
require$$1$5.ipcMain.handle("download-update", async () => {
  return mainExports.autoUpdater.downloadUpdate();
});
require$$1$5.ipcMain.handle("quit-and-install", async () => {
  mainExports.autoUpdater.quitAndInstall();
});
require$$1$5.ipcMain.handle("get-app-version", () => {
  return require$$1$5.app.getVersion();
});
require$$1$5.ipcMain.handle("get-saved-connections", async () => {
  return internalDB.getConnections();
});
require$$1$5.ipcMain.handle("save-connection", async (_, config) => {
  return internalDB.saveConnection(config);
});
require$$1$5.ipcMain.handle("delete-connection", async (_, id) => {
  return internalDB.deleteConnection(id);
});
require$$1$5.ipcMain.handle("get-consoles", async (_, connectionId) => {
  return internalDB.getConsoles(connectionId);
});
require$$1$5.ipcMain.handle("save-console", async (_, console2) => {
  return internalDB.saveConsole(console2);
});
require$$1$5.ipcMain.handle("delete-console", async (_, id) => {
  return internalDB.deleteConsole(id);
});
require$$1$5.ipcMain.handle("connect-db", async (_, config) => {
  try {
    if (currentDriver) {
      await currentDriver.disconnect();
    }
    if (config.type === "sqlite") {
      currentDriver = new SQLiteDriver(config);
    } else if (config.type === "mysql") {
      currentDriver = new MySQLDriver(config);
    } else if (config.type === "postgresql") {
      currentDriver = new PostgreSQLDriver(config);
    } else if (config.type === "redis") {
      currentDriver = new RedisDriver(config);
    } else {
      throw new Error("Unsupported database type");
    }
    await currentDriver.connect();
    startHeartbeat();
    return { success: true };
  } catch (error2) {
    stopHeartbeat();
    return { success: false, error: error2.message };
  }
});
require$$1$5.ipcMain.handle("get-databases", async () => {
  if (!currentDriver) return [];
  try {
    return await currentDriver.getDatabases();
  } catch (error2) {
    console.error("Error fetching databases:", error2);
    return [];
  }
});
require$$1$5.ipcMain.handle("use-database", async (_, dbName) => {
  if (!currentDriver) return { success: false, error: "Not connected" };
  try {
    await currentDriver.useDatabase(dbName);
    return { success: true };
  } catch (error2) {
    return { success: false, error: error2.message };
  }
});
require$$1$5.ipcMain.handle("get-tables", async () => {
  if (!currentDriver) return [];
  try {
    return await currentDriver.getTables();
  } catch (error2) {
    console.error("Error fetching tables:", error2);
    return [];
  }
});
require$$1$5.ipcMain.handle("get-table-data", async (_, tableName, limit, offset, orderBy, orderDir) => {
  if (!currentDriver) return { data: [], total: 0 };
  try {
    return await currentDriver.getTableData(tableName, limit, offset, orderBy, orderDir);
  } catch (error2) {
    console.error(`Error fetching data from ${tableName}:`, error2);
    return { data: [], total: 0 };
  }
});
require$$1$5.ipcMain.handle("get-table-columns", async (_, tableName) => {
  if (!currentDriver) return [];
  try {
    return await currentDriver.getTableColumns(tableName);
  } catch (error2) {
    console.error(`Error fetching columns for ${tableName}:`, error2);
    return [];
  }
});
require$$1$5.ipcMain.handle("get-table-indexes", async (_, tableName) => {
  if (!currentDriver) return [];
  try {
    return await currentDriver.getTableIndexes(tableName);
  } catch (error2) {
    console.error(`Error fetching indexes for ${tableName}:`, error2);
    return [];
  }
});
require$$1$5.ipcMain.handle("rename-table", async (_, oldName, newName) => {
  if (!currentDriver) return { success: false, error: "Not connected" };
  try {
    await currentDriver.renameTable(oldName, newName);
    return { success: true };
  } catch (error2) {
    return { success: false, error: error2.message };
  }
});
require$$1$5.ipcMain.handle("delete-table", async (_, tableName) => {
  if (!currentDriver) return { success: false, error: "Not connected" };
  try {
    await currentDriver.deleteTable(tableName);
    return { success: true };
  } catch (error2) {
    return { success: false, error: error2.message };
  }
});
require$$1$5.ipcMain.handle("create-table", async (_, tableName, columns, indexes) => {
  if (!currentDriver) return { success: false, error: "Not connected" };
  try {
    await currentDriver.createTable(tableName, columns, indexes);
    return { success: true };
  } catch (error2) {
    return { success: false, error: error2.message };
  }
});
require$$1$5.ipcMain.handle("update-table-schema", async (_, tableName, changes) => {
  if (!currentDriver) return { success: false, error: "Not connected" };
  try {
    await currentDriver.updateTableSchema(tableName, changes);
    return { success: true };
  } catch (error2) {
    return { success: false, error: error2.message };
  }
});
require$$1$5.ipcMain.handle("export-database", async (_, includeData) => {
  if (!currentDriver) return { success: false, error: "Not connected" };
  try {
    const sql = await currentDriver.exportDatabase(includeData);
    const { filePath } = await require$$1$5.dialog.showSaveDialog(mainWindow, {
      title: " SQL",
      defaultPath: `export_${Date.now()}.sql`,
      filters: [{ name: "SQL Files", extensions: ["sql"] }]
    });
    if (filePath) {
      require$$1$2.writeFileSync(filePath, sql);
      return { success: true };
    }
    return { success: false, error: "User cancelled" };
  } catch (error2) {
    return { success: false, error: error2.message };
  }
});
require$$1$5.ipcMain.handle("delete-database", async (_, dbName) => {
  if (!currentDriver) return { success: false, error: "Not connected" };
  try {
    await currentDriver.deleteDatabase(dbName);
    return { success: true };
  } catch (error2) {
    return { success: false, error: error2.message };
  }
});
require$$1$5.ipcMain.handle("execute-query", async (_, sql) => {
  if (!currentDriver) return { success: false, error: "Not connected" };
  try {
    const MAX_ROWS_PER_FETCH = 1e4;
    const hasLimit = /\blimit\b\s+\d+/i.test(sql);
    let executionSql = sql;
    const isSelect = sql.trim().toUpperCase().startsWith("SELECT");
    let autoLimited = false;
    if (isSelect && !hasLimit) {
      executionSql = `${sql.trim().replace(/;$/, "")} LIMIT ${MAX_ROWS_PER_FETCH + 1}`;
      autoLimited = true;
    }
    const result = await currentDriver.executeQuery(executionSql);
    let hasMore = false;
    if (autoLimited && result.data && result.data.length > MAX_ROWS_PER_FETCH) {
      result.data = result.data.slice(0, MAX_ROWS_PER_FETCH);
      hasMore = true;
    }
    return {
      success: true,
      ...result,
      hasMore,
      totalCount: result.data ? result.data.length : 0,
      isAutoLimited: autoLimited
    };
  } catch (error2) {
    return { success: false, error: error2.message };
  }
});
require$$1$5.ipcMain.handle("ai-chat", async (_, messages) => {
  try {
    const response = await aiService.chat(messages);
    return { success: true, response };
  } catch (error2) {
    return { success: false, error: error2.message };
  }
});
require$$1$5.ipcMain.handle("save-setting", async (_, key, value) => {
  return internalDB.saveSetting(key, value);
});
require$$1$5.ipcMain.handle("get-setting", async (_, key) => {
  return internalDB.getSetting(key);
});
require$$1$5.ipcMain.handle("show-confirm-dialog", async (_, options) => {
  if (!mainWindow) return false;
  const result = await require$$1$5.dialog.showMessageBox(mainWindow, {
    type: options.type || "question",
    buttons: options.buttons || ["", ""],
    defaultId: 0,
    cancelId: options.buttons ? options.buttons.length - 1 : 1,
    title: options.title || "",
    message: options.message,
    detail: ""
  });
  if (options.buttons) {
    return result.response;
  }
  return result.response === 0;
});
